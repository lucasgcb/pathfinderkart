
FREERTOS_PERIPHERAL_CONTROL1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000062bc  00080000  00080000  00010000  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000006ec  20070000  000862bc  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  2 .bss          00004cf4  200706ec  000869a8  000206ec  2**2
                  ALLOC
  3 .stack        00002000  200753e0  0008b69c  000206ec  2**0
                  ALLOC
  4 .ARM.attributes 00000029  00000000  00000000  000206ec  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020715  2**0
                  CONTENTS, READONLY
  6 .debug_info   000322b2  00000000  00000000  0002076e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006a40  00000000  00000000  00052a20  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000f224  00000000  00000000  00059460  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000013f0  00000000  00000000  00068684  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000016b8  00000000  00000000  00069a74  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  00022836  00000000  00000000  0006b12c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00020c05  00000000  00000000  0008d962  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0007caf8  00000000  00000000  000ae567  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003424  00000000  00000000  0012b060  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <exception_table>:
   80000:	e0 73 07 20 6d 34 08 00 69 34 08 00 69 34 08 00     .s. m4..i4..i4..
   80010:	69 34 08 00 69 34 08 00 69 34 08 00 00 00 00 00     i4..i4..i4......
	...
   8002c:	a1 39 08 00 69 34 08 00 00 00 00 00 41 3a 08 00     .9..i4......A:..
   8003c:	85 3a 08 00 69 34 08 00 69 34 08 00 69 34 08 00     .:..i4..i4..i4..
   8004c:	69 34 08 00 69 34 08 00 69 34 08 00 69 34 08 00     i4..i4..i4..i4..
   8005c:	69 34 08 00 01 08 08 00 69 34 08 00 00 00 00 00     i4......i4......
   8006c:	e9 1e 08 00 fd 1e 08 00 11 1f 08 00 25 1f 08 00     ............%...
	...
   80084:	5d 0f 08 00 6d 0f 08 00 7d 0f 08 00 8d 0f 08 00     ]...m...}.......
   80094:	69 34 08 00 f5 06 08 00 05 07 08 00 69 34 08 00     i4..........i4..
   800a4:	00 00 00 00 69 34 08 00 69 34 08 00 69 34 08 00     ....i4..i4..i4..
   800b4:	69 34 08 00 69 34 08 00 69 34 08 00 69 34 08 00     i4..i4..i4..i4..
   800c4:	69 34 08 00 69 34 08 00 69 34 08 00 69 34 08 00     i4..i4..i4..i4..
   800d4:	69 34 08 00 69 34 08 00 69 34 08 00 11 26 08 00     i4..i4..i4...&..
   800e4:	69 34 08 00 69 34 08 00 69 34 08 00 69 34 08 00     i4..i4..i4..i4..

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	200706ec 	.word	0x200706ec
   80110:	00000000 	.word	0x00000000
   80114:	000862bc 	.word	0x000862bc

00080118 <frame_dummy>:
   80118:	4b0c      	ldr	r3, [pc, #48]	; (8014c <frame_dummy+0x34>)
   8011a:	b143      	cbz	r3, 8012e <frame_dummy+0x16>
   8011c:	480c      	ldr	r0, [pc, #48]	; (80150 <frame_dummy+0x38>)
   8011e:	b510      	push	{r4, lr}
   80120:	490c      	ldr	r1, [pc, #48]	; (80154 <frame_dummy+0x3c>)
   80122:	f3af 8000 	nop.w
   80126:	480c      	ldr	r0, [pc, #48]	; (80158 <frame_dummy+0x40>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b923      	cbnz	r3, 80136 <frame_dummy+0x1e>
   8012c:	bd10      	pop	{r4, pc}
   8012e:	480a      	ldr	r0, [pc, #40]	; (80158 <frame_dummy+0x40>)
   80130:	6803      	ldr	r3, [r0, #0]
   80132:	b933      	cbnz	r3, 80142 <frame_dummy+0x2a>
   80134:	4770      	bx	lr
   80136:	4b09      	ldr	r3, [pc, #36]	; (8015c <frame_dummy+0x44>)
   80138:	2b00      	cmp	r3, #0
   8013a:	d0f7      	beq.n	8012c <frame_dummy+0x14>
   8013c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   80140:	4718      	bx	r3
   80142:	4b06      	ldr	r3, [pc, #24]	; (8015c <frame_dummy+0x44>)
   80144:	2b00      	cmp	r3, #0
   80146:	d0f5      	beq.n	80134 <frame_dummy+0x1c>
   80148:	4718      	bx	r3
   8014a:	bf00      	nop
   8014c:	00000000 	.word	0x00000000
   80150:	000862bc 	.word	0x000862bc
   80154:	200706f0 	.word	0x200706f0
   80158:	000862bc 	.word	0x000862bc
   8015c:	00000000 	.word	0x00000000

00080160 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
   80160:	b510      	push	{r4, lr}
	struct pll_config pllcfg;

	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
   80162:	480e      	ldr	r0, [pc, #56]	; (8019c <sysclk_init+0x3c>)
   80164:	4b0e      	ldr	r3, [pc, #56]	; (801a0 <sysclk_init+0x40>)
   80166:	4798      	blx	r3
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
   80168:	213e      	movs	r1, #62	; 0x3e
   8016a:	2000      	movs	r0, #0
   8016c:	4b0d      	ldr	r3, [pc, #52]	; (801a4 <sysclk_init+0x44>)
   8016e:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
   80170:	4c0d      	ldr	r4, [pc, #52]	; (801a8 <sysclk_init+0x48>)
   80172:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
   80174:	2800      	cmp	r0, #0
   80176:	d0fc      	beq.n	80172 <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
   80178:	4b0c      	ldr	r3, [pc, #48]	; (801ac <sysclk_init+0x4c>)
   8017a:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
   8017c:	4a0c      	ldr	r2, [pc, #48]	; (801b0 <sysclk_init+0x50>)
   8017e:	4b0d      	ldr	r3, [pc, #52]	; (801b4 <sysclk_init+0x54>)
   80180:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
   80182:	4c0d      	ldr	r4, [pc, #52]	; (801b8 <sysclk_init+0x58>)
   80184:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
   80186:	2800      	cmp	r0, #0
   80188:	d0fc      	beq.n	80184 <sysclk_init+0x24>
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
   8018a:	2010      	movs	r0, #16
   8018c:	4b0b      	ldr	r3, [pc, #44]	; (801bc <sysclk_init+0x5c>)
   8018e:	4798      	blx	r3
		pll_wait_for_lock(1);
		pmc_switch_mck_to_upllck(CONFIG_SYSCLK_PRES);
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
   80190:	4b0b      	ldr	r3, [pc, #44]	; (801c0 <sysclk_init+0x60>)
   80192:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
   80194:	4801      	ldr	r0, [pc, #4]	; (8019c <sysclk_init+0x3c>)
   80196:	4b02      	ldr	r3, [pc, #8]	; (801a0 <sysclk_init+0x40>)
   80198:	4798      	blx	r3
   8019a:	bd10      	pop	{r4, pc}
   8019c:	0501bd00 	.word	0x0501bd00
   801a0:	200700a5 	.word	0x200700a5
   801a4:	00081f9d 	.word	0x00081f9d
   801a8:	00081ff1 	.word	0x00081ff1
   801ac:	00082001 	.word	0x00082001
   801b0:	200d3f01 	.word	0x200d3f01
   801b4:	400e0600 	.word	0x400e0600
   801b8:	00082011 	.word	0x00082011
   801bc:	00081f39 	.word	0x00081f39
   801c0:	00083505 	.word	0x00083505

000801c4 <get_pdc_peripheral_details>:
 * peripheral that has the start address specified by peripheral_to_find.
 */
portBASE_TYPE get_pdc_peripheral_details(
		const freertos_pdc_peripheral_parameters_t peripheral_array[],
		size_t array_size, void *peripheral_to_find)
{
   801c4:	b410      	push	{r4}
	size_t x;

	for (x = 0; x < array_size; x++) {
   801c6:	460c      	mov	r4, r1
   801c8:	b169      	cbz	r1, 801e6 <get_pdc_peripheral_details+0x22>
		if (peripheral_array[x].peripheral_base_address ==
   801ca:	6803      	ldr	r3, [r0, #0]
   801cc:	429a      	cmp	r2, r3
   801ce:	d00c      	beq.n	801ea <get_pdc_peripheral_details+0x26>
   801d0:	4603      	mov	r3, r0
   801d2:	2000      	movs	r0, #0
	for (x = 0; x < array_size; x++) {
   801d4:	3001      	adds	r0, #1
   801d6:	4284      	cmp	r4, r0
   801d8:	d003      	beq.n	801e2 <get_pdc_peripheral_details+0x1e>
		if (peripheral_array[x].peripheral_base_address ==
   801da:	f853 1f10 	ldr.w	r1, [r3, #16]!
   801de:	4291      	cmp	r1, r2
   801e0:	d1f8      	bne.n	801d4 <get_pdc_peripheral_details+0x10>
			break;
		}
	}

	return x;
}
   801e2:	bc10      	pop	{r4}
   801e4:	4770      	bx	lr
	for (x = 0; x < array_size; x++) {
   801e6:	4608      	mov	r0, r1
   801e8:	e7fb      	b.n	801e2 <get_pdc_peripheral_details+0x1e>
   801ea:	2000      	movs	r0, #0
   801ec:	e7f9      	b.n	801e2 <get_pdc_peripheral_details+0x1e>

000801ee <check_requested_operating_mode>:
		portBASE_TYPE num_valid_operating_modes)
{
	bool return_value = false;
	portBASE_TYPE index_position;

	for (index_position = 0; index_position < num_valid_operating_modes;
   801ee:	2a00      	cmp	r2, #0
   801f0:	dd10      	ble.n	80214 <check_requested_operating_mode+0x26>
			index_position++) {
		if (requested_operation_mode ==
   801f2:	780b      	ldrb	r3, [r1, #0]
   801f4:	4283      	cmp	r3, r0
   801f6:	d00f      	beq.n	80218 <check_requested_operating_mode+0x2a>
   801f8:	1c4b      	adds	r3, r1, #1
   801fa:	4411      	add	r1, r2
	for (index_position = 0; index_position < num_valid_operating_modes;
   801fc:	428b      	cmp	r3, r1
   801fe:	d00f      	beq.n	80220 <check_requested_operating_mode+0x32>
{
   80200:	b410      	push	{r4}
				valid_operating_modes[index_position]) {
   80202:	f813 4b01 	ldrb.w	r4, [r3], #1
		if (requested_operation_mode ==
   80206:	4284      	cmp	r4, r0
   80208:	d008      	beq.n	8021c <check_requested_operating_mode+0x2e>
	for (index_position = 0; index_position < num_valid_operating_modes;
   8020a:	428b      	cmp	r3, r1
   8020c:	d1f9      	bne.n	80202 <check_requested_operating_mode+0x14>
	bool return_value = false;
   8020e:	2000      	movs	r0, #0
			break;
		}
	}

	return return_value;
}
   80210:	bc10      	pop	{r4}
   80212:	4770      	bx	lr
	bool return_value = false;
   80214:	2000      	movs	r0, #0
   80216:	4770      	bx	lr
			return_value = true;
   80218:	2001      	movs	r0, #1
   8021a:	4770      	bx	lr
   8021c:	2001      	movs	r0, #1
   8021e:	e7f7      	b.n	80210 <check_requested_operating_mode+0x22>
	bool return_value = false;
   80220:	2000      	movs	r0, #0
}
   80222:	4770      	bx	lr

00080224 <create_peripheral_control_semaphores>:
 * with the bits set in the options_flags value.
 */
void create_peripheral_control_semaphores(const uint8_t options_flags,
		freertos_dma_event_control_t *tx_dma_control,
		freertos_dma_event_control_t *rx_dma_control)
{
   80224:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   80226:	4604      	mov	r4, r0
   80228:	460d      	mov	r5, r1
   8022a:	4616      	mov	r6, r2
	/* If the tx driver is to be thread aware then create an access control
	semaphore.  An Rx access mutex is not created in this function as half duplex
	peripherals need only use a single access mutex, and the Tx semaphore is used
	for the purpose.  Full duplex peripherals have extra configuration steps
	that are performed separately. */
	if ((options_flags & USE_TX_ACCESS_SEM) != 0) {
   8022c:	f010 0f01 	tst.w	r0, #1
   80230:	d11e      	bne.n	80270 <create_peripheral_control_semaphores+0x4c>
		xSemaphoreGive(tx_dma_control->peripheral_access_sem);
	}

	/* If the transmit function is only going to return once the transmit is
	complete then create an internal notification semaphore. */
	if ((options_flags & WAIT_TX_COMPLETE) != 0) {
   80232:	f014 0f04 	tst.w	r4, #4
   80236:	d135      	bne.n	802a4 <create_peripheral_control_semaphores+0x80>
		available (it has only just been created). */
		xSemaphoreTake(
				tx_dma_control->transaction_complete_notification_semaphore,
				0);
	} else {
		tx_dma_control->transaction_complete_notification_semaphore = NULL;
   80238:	2300      	movs	r3, #0
   8023a:	602b      	str	r3, [r5, #0]
	}

	/* If the receive function is only going to return once the receive
	is complete then create an internal notification semaphore. */
	if (((options_flags & WAIT_RX_COMPLETE) != 0) &&
   8023c:	f014 0f08 	tst.w	r4, #8
   80240:	d04d      	beq.n	802de <create_peripheral_control_semaphores+0xba>
   80242:	2e00      	cmp	r6, #0
   80244:	d04b      	beq.n	802de <create_peripheral_control_semaphores+0xba>
			(rx_dma_control != NULL)) {
		vSemaphoreCreateBinary(
   80246:	2203      	movs	r2, #3
   80248:	2100      	movs	r1, #0
   8024a:	2001      	movs	r0, #1
   8024c:	4b25      	ldr	r3, [pc, #148]	; (802e4 <create_peripheral_control_semaphores+0xc0>)
   8024e:	4798      	blx	r3
   80250:	6030      	str	r0, [r6, #0]
   80252:	2800      	cmp	r0, #0
   80254:	d03e      	beq.n	802d4 <create_peripheral_control_semaphores+0xb0>
   80256:	2300      	movs	r3, #0
   80258:	461a      	mov	r2, r3
   8025a:	4619      	mov	r1, r3
   8025c:	4c22      	ldr	r4, [pc, #136]	; (802e8 <create_peripheral_control_semaphores+0xc4>)
   8025e:	47a0      	blx	r4
				rx_dma_control->transaction_complete_notification_semaphore);
		configASSERT(
   80260:	6833      	ldr	r3, [r6, #0]
   80262:	2b00      	cmp	r3, #0
   80264:	d036      	beq.n	802d4 <create_peripheral_control_semaphores+0xb0>
				rx_dma_control->transaction_complete_notification_semaphore);

		/* Ensure the semaphore starts in the expected state.  A block time
		of zero can be used here as the semaphore is guaranteed to be
		available (it has only just been created. */
		xSemaphoreTake(
   80266:	2100      	movs	r1, #0
   80268:	6830      	ldr	r0, [r6, #0]
   8026a:	4b20      	ldr	r3, [pc, #128]	; (802ec <create_peripheral_control_semaphores+0xc8>)
   8026c:	4798      	blx	r3
   8026e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		vSemaphoreCreateBinary(
   80270:	2203      	movs	r2, #3
   80272:	2100      	movs	r1, #0
   80274:	2001      	movs	r0, #1
   80276:	4b1b      	ldr	r3, [pc, #108]	; (802e4 <create_peripheral_control_semaphores+0xc0>)
   80278:	4798      	blx	r3
   8027a:	6068      	str	r0, [r5, #4]
   8027c:	b168      	cbz	r0, 8029a <create_peripheral_control_semaphores+0x76>
   8027e:	2300      	movs	r3, #0
   80280:	461a      	mov	r2, r3
   80282:	4619      	mov	r1, r3
   80284:	4f18      	ldr	r7, [pc, #96]	; (802e8 <create_peripheral_control_semaphores+0xc4>)
   80286:	47b8      	blx	r7
		configASSERT(tx_dma_control->peripheral_access_sem);
   80288:	686b      	ldr	r3, [r5, #4]
   8028a:	b133      	cbz	r3, 8029a <create_peripheral_control_semaphores+0x76>
		xSemaphoreGive(tx_dma_control->peripheral_access_sem);
   8028c:	2300      	movs	r3, #0
   8028e:	461a      	mov	r2, r3
   80290:	4619      	mov	r1, r3
   80292:	6868      	ldr	r0, [r5, #4]
   80294:	4f14      	ldr	r7, [pc, #80]	; (802e8 <create_peripheral_control_semaphores+0xc4>)
   80296:	47b8      	blx	r7
   80298:	e7cb      	b.n	80232 <create_peripheral_control_semaphores+0xe>
		configASSERT(tx_dma_control->peripheral_access_sem);
   8029a:	2171      	movs	r1, #113	; 0x71
   8029c:	4814      	ldr	r0, [pc, #80]	; (802f0 <create_peripheral_control_semaphores+0xcc>)
   8029e:	4b15      	ldr	r3, [pc, #84]	; (802f4 <create_peripheral_control_semaphores+0xd0>)
   802a0:	4798      	blx	r3
   802a2:	e7f3      	b.n	8028c <create_peripheral_control_semaphores+0x68>
		vSemaphoreCreateBinary(
   802a4:	2203      	movs	r2, #3
   802a6:	2100      	movs	r1, #0
   802a8:	2001      	movs	r0, #1
   802aa:	4b0e      	ldr	r3, [pc, #56]	; (802e4 <create_peripheral_control_semaphores+0xc0>)
   802ac:	4798      	blx	r3
   802ae:	6028      	str	r0, [r5, #0]
   802b0:	b158      	cbz	r0, 802ca <create_peripheral_control_semaphores+0xa6>
   802b2:	2300      	movs	r3, #0
   802b4:	461a      	mov	r2, r3
   802b6:	4619      	mov	r1, r3
   802b8:	4f0b      	ldr	r7, [pc, #44]	; (802e8 <create_peripheral_control_semaphores+0xc4>)
   802ba:	47b8      	blx	r7
		configASSERT(
   802bc:	682b      	ldr	r3, [r5, #0]
   802be:	b123      	cbz	r3, 802ca <create_peripheral_control_semaphores+0xa6>
		xSemaphoreTake(
   802c0:	2100      	movs	r1, #0
   802c2:	6828      	ldr	r0, [r5, #0]
   802c4:	4b09      	ldr	r3, [pc, #36]	; (802ec <create_peripheral_control_semaphores+0xc8>)
   802c6:	4798      	blx	r3
   802c8:	e7b8      	b.n	8023c <create_peripheral_control_semaphores+0x18>
		configASSERT(
   802ca:	217d      	movs	r1, #125	; 0x7d
   802cc:	4808      	ldr	r0, [pc, #32]	; (802f0 <create_peripheral_control_semaphores+0xcc>)
   802ce:	4b09      	ldr	r3, [pc, #36]	; (802f4 <create_peripheral_control_semaphores+0xd0>)
   802d0:	4798      	blx	r3
   802d2:	e7f5      	b.n	802c0 <create_peripheral_control_semaphores+0x9c>
		configASSERT(
   802d4:	2190      	movs	r1, #144	; 0x90
   802d6:	4806      	ldr	r0, [pc, #24]	; (802f0 <create_peripheral_control_semaphores+0xcc>)
   802d8:	4b06      	ldr	r3, [pc, #24]	; (802f4 <create_peripheral_control_semaphores+0xd0>)
   802da:	4798      	blx	r3
   802dc:	e7c3      	b.n	80266 <create_peripheral_control_semaphores+0x42>
				rx_dma_control->transaction_complete_notification_semaphore,
				0);
	} else {
		rx_dma_control->transaction_complete_notification_semaphore = NULL;
   802de:	2300      	movs	r3, #0
   802e0:	6033      	str	r3, [r6, #0]
   802e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   802e4:	00083e99 	.word	0x00083e99
   802e8:	00083f31 	.word	0x00083f31
   802ec:	00084411 	.word	0x00084411
   802f0:	00085e70 	.word	0x00085e70
   802f4:	00085861 	.word	0x00085861

000802f8 <configure_interrupt_controller>:
 * Configure the NVIC to enable, and set the priority of, the interrupt
 * specified by peripheral_irq.
 */
void configure_interrupt_controller(const enum IRQn peripheral_irq,
		uint32_t interrupt_priority)
{
   802f8:	b538      	push	{r3, r4, r5, lr}
   802fa:	4605      	mov	r5, r0
   802fc:	460c      	mov	r4, r1
	configASSERT(interrupt_priority <=
   802fe:	290f      	cmp	r1, #15
   80300:	d815      	bhi.n	8032e <configure_interrupt_controller+0x36>
            configLIBRARY_LOWEST_INTERRUPT_PRIORITY);
	configASSERT(interrupt_priority >=
   80302:	2c09      	cmp	r4, #9
   80304:	d918      	bls.n	80338 <configure_interrupt_controller+0x40>
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
   80306:	2d00      	cmp	r5, #0
   80308:	db1b      	blt.n	80342 <configure_interrupt_controller+0x4a>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   8030a:	0969      	lsrs	r1, r5, #5
   8030c:	f005 021f 	and.w	r2, r5, #31
   80310:	2301      	movs	r3, #1
   80312:	4093      	lsls	r3, r2
   80314:	4a0e      	ldr	r2, [pc, #56]	; (80350 <configure_interrupt_controller+0x58>)
   80316:	f101 0060 	add.w	r0, r1, #96	; 0x60
   8031a:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   8031e:	0124      	lsls	r4, r4, #4
   80320:	b2e4      	uxtb	r4, r4
   80322:	1950      	adds	r0, r2, r5
   80324:	f880 4300 	strb.w	r4, [r0, #768]	; 0x300
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
   80328:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
			configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY);

	NVIC_ClearPendingIRQ(peripheral_irq);
	NVIC_SetPriority(peripheral_irq, interrupt_priority);
	NVIC_EnableIRQ(peripheral_irq);
}
   8032c:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT(interrupt_priority <=
   8032e:	21a6      	movs	r1, #166	; 0xa6
   80330:	4808      	ldr	r0, [pc, #32]	; (80354 <configure_interrupt_controller+0x5c>)
   80332:	4b09      	ldr	r3, [pc, #36]	; (80358 <configure_interrupt_controller+0x60>)
   80334:	4798      	blx	r3
   80336:	e7e4      	b.n	80302 <configure_interrupt_controller+0xa>
	configASSERT(interrupt_priority >=
   80338:	21a8      	movs	r1, #168	; 0xa8
   8033a:	4806      	ldr	r0, [pc, #24]	; (80354 <configure_interrupt_controller+0x5c>)
   8033c:	4b06      	ldr	r3, [pc, #24]	; (80358 <configure_interrupt_controller+0x60>)
   8033e:	4798      	blx	r3
   80340:	e7e1      	b.n	80306 <configure_interrupt_controller+0xe>
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
   80342:	f005 000f 	and.w	r0, r5, #15
   80346:	0124      	lsls	r4, r4, #4
   80348:	b2e4      	uxtb	r4, r4
   8034a:	4b04      	ldr	r3, [pc, #16]	; (8035c <configure_interrupt_controller+0x64>)
   8034c:	541c      	strb	r4, [r3, r0]
   8034e:	bd38      	pop	{r3, r4, r5, pc}
   80350:	e000e100 	.word	0xe000e100
   80354:	00085e70 	.word	0x00085e70
   80358:	00085861 	.word	0x00085861
   8035c:	e000ed14 	.word	0xe000ed14

00080360 <freertos_copy_bytes_from_pdc_circular_buffer>:
 */
uint32_t freertos_copy_bytes_from_pdc_circular_buffer(
		freertos_pdc_rx_control_t *p_rx_buffer_details,
		uint32_t next_byte_to_be_written, uint8_t *buf,
		uint32_t bytes_to_read)
{
   80360:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80364:	4606      	mov	r6, r0
   80366:	4690      	mov	r8, r2
   80368:	461f      	mov	r7, r3
	uint32_t number_of_bytes_available, next_byte_to_read;

	/* Locate the position that data will be read from next. */
	next_byte_to_read = (uint32_t) p_rx_buffer_details->next_byte_to_read;
   8036a:	6985      	ldr	r5, [r0, #24]

	if (next_byte_to_be_written == next_byte_to_read) {
   8036c:	428d      	cmp	r5, r1
   8036e:	d01f      	beq.n	803b0 <freertos_copy_bytes_from_pdc_circular_buffer+0x50>
		} else {
			/* The read and write pointers are equal, but the Rx DMA is still
			in operation, so the buffer must be empty. */
			number_of_bytes_available = 0;
		}
	} else if (next_byte_to_be_written > next_byte_to_read) {
   80370:	428d      	cmp	r5, r1
		/* The write pointer has not wrapped around from the read pointer, or
		the write and read pointer are the same indicating a buffer overflow.
		Calculate the bytes available between the write and read pointers. */
		number_of_bytes_available = next_byte_to_be_written -
   80372:	bf32      	itee	cc
   80374:	1b4c      	subcc	r4, r1, r5
				next_byte_to_read;
	} else {
		/* The write pointer has wrapped around from the read pointer.
		Calculate the bytes available between the end of the buffer and the
		read pointer. */
		number_of_bytes_available =
   80376:	6844      	ldrcs	r4, [r0, #4]
   80378:	1b64      	subcs	r4, r4, r5
				p_rx_buffer_details->past_rx_buffer_end_address
				- next_byte_to_read;
	}

	/* Cap the number of requested bytes to those available. */
	if (bytes_to_read > number_of_bytes_available) {
   8037a:	42bc      	cmp	r4, r7
   8037c:	d307      	bcc.n	8038e <freertos_copy_bytes_from_pdc_circular_buffer+0x2e>
		bytes_to_read = number_of_bytes_available;
	} else if (bytes_to_read != number_of_bytes_available) {
   8037e:	d01e      	beq.n	803be <freertos_copy_bytes_from_pdc_circular_buffer+0x5e>
		/* There are more bytes available than being read now, so there is no
		need to wait for the interrupt to give the semaphore to indicate that
		new data is available. */
		xSemaphoreGive(p_rx_buffer_details->rx_event_semaphore);
   80380:	2300      	movs	r3, #0
   80382:	461a      	mov	r2, r3
   80384:	4619      	mov	r1, r3
   80386:	6930      	ldr	r0, [r6, #16]
   80388:	4c11      	ldr	r4, [pc, #68]	; (803d0 <freertos_copy_bytes_from_pdc_circular_buffer+0x70>)
   8038a:	47a0      	blx	r4
   8038c:	463c      	mov	r4, r7
	}

	/* Copy the bytes into the user buffer. */
	memcpy(buf, (void *) p_rx_buffer_details->next_byte_to_read,
   8038e:	4622      	mov	r2, r4
   80390:	69b1      	ldr	r1, [r6, #24]
   80392:	4640      	mov	r0, r8
   80394:	4b0f      	ldr	r3, [pc, #60]	; (803d4 <freertos_copy_bytes_from_pdc_circular_buffer+0x74>)
   80396:	4798      	blx	r3
			bytes_to_read);

	/* Move up the read buffer accordingly, wrapping around if it reaches the
	end of the buffer. */
	next_byte_to_read += bytes_to_read;
   80398:	4425      	add	r5, r4

	if (next_byte_to_read >=
   8039a:	6873      	ldr	r3, [r6, #4]
   8039c:	429d      	cmp	r5, r3
   8039e:	d210      	bcs.n	803c2 <freertos_copy_bytes_from_pdc_circular_buffer+0x62>
		}
		taskEXIT_CRITICAL();
	} else {
		/* The next_byte_to_read pointer is only read by the ISR, so the
		critical section is probably not needed on 32-bit machines. */
		taskENTER_CRITICAL();
   803a0:	4b0d      	ldr	r3, [pc, #52]	; (803d8 <freertos_copy_bytes_from_pdc_circular_buffer+0x78>)
   803a2:	4798      	blx	r3
		{
			p_rx_buffer_details->next_byte_to_read =
   803a4:	61b5      	str	r5, [r6, #24]
					(uint8_t *) next_byte_to_read;
		}
		taskEXIT_CRITICAL();
   803a6:	4b0d      	ldr	r3, [pc, #52]	; (803dc <freertos_copy_bytes_from_pdc_circular_buffer+0x7c>)
   803a8:	4798      	blx	r3
	}

	/* Return the number of bytes actually read. */
	return bytes_to_read;
}
   803aa:	4620      	mov	r0, r4
   803ac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (p_rx_buffer_details->rx_pdc_parameters.ul_size == 0) {
   803b0:	68c3      	ldr	r3, [r0, #12]
   803b2:	b913      	cbnz	r3, 803ba <freertos_copy_bytes_from_pdc_circular_buffer+0x5a>
			number_of_bytes_available =
   803b4:	6844      	ldr	r4, [r0, #4]
   803b6:	1b64      	subs	r4, r4, r5
   803b8:	e7df      	b.n	8037a <freertos_copy_bytes_from_pdc_circular_buffer+0x1a>
			number_of_bytes_available = 0;
   803ba:	2400      	movs	r4, #0
   803bc:	e7dd      	b.n	8037a <freertos_copy_bytes_from_pdc_circular_buffer+0x1a>
   803be:	463c      	mov	r4, r7
   803c0:	e7e5      	b.n	8038e <freertos_copy_bytes_from_pdc_circular_buffer+0x2e>
		taskENTER_CRITICAL();
   803c2:	4b05      	ldr	r3, [pc, #20]	; (803d8 <freertos_copy_bytes_from_pdc_circular_buffer+0x78>)
   803c4:	4798      	blx	r3
			p_rx_buffer_details->next_byte_to_read =
   803c6:	6833      	ldr	r3, [r6, #0]
   803c8:	61b3      	str	r3, [r6, #24]
		taskEXIT_CRITICAL();
   803ca:	4b04      	ldr	r3, [pc, #16]	; (803dc <freertos_copy_bytes_from_pdc_circular_buffer+0x7c>)
   803cc:	4798      	blx	r3
   803ce:	e7ec      	b.n	803aa <freertos_copy_bytes_from_pdc_circular_buffer+0x4a>
   803d0:	00083f31 	.word	0x00083f31
   803d4:	00085ab1 	.word	0x00085ab1
   803d8:	000839c5 	.word	0x000839c5
   803dc:	00083a0d 	.word	0x00083a0d

000803e0 <freertos_obtain_peripheral_access_semphore>:
		portTickType *max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;
	xTimeOutType time_out_definition;

	if (dma_event_control->peripheral_access_sem != NULL) {
   803e0:	6843      	ldr	r3, [r0, #4]
   803e2:	b1bb      	cbz	r3, 80414 <freertos_obtain_peripheral_access_semphore+0x34>
{
   803e4:	b530      	push	{r4, r5, lr}
   803e6:	b083      	sub	sp, #12
   803e8:	460d      	mov	r5, r1
   803ea:	4604      	mov	r4, r0
		/* Remember the time on entry. */
		vTaskSetTimeOutState(&time_out_definition);
   803ec:	4668      	mov	r0, sp
   803ee:	4b0c      	ldr	r3, [pc, #48]	; (80420 <freertos_obtain_peripheral_access_semphore+0x40>)
   803f0:	4798      	blx	r3

		/* Wait to get exclusive access to the peripheral. */
		if (xSemaphoreTake(dma_event_control->peripheral_access_sem,
   803f2:	6829      	ldr	r1, [r5, #0]
   803f4:	6860      	ldr	r0, [r4, #4]
   803f6:	4b0b      	ldr	r3, [pc, #44]	; (80424 <freertos_obtain_peripheral_access_semphore+0x44>)
   803f8:	4798      	blx	r3
   803fa:	b168      	cbz	r0, 80418 <freertos_obtain_peripheral_access_semphore+0x38>
				*max_block_time_ticks) == pdFAIL) {
			return_value = ERR_TIMEOUT;
		} else {
			/* Adjust the time out value in case the task had to block to
			wait for the semaphore. */
			if (xTaskCheckForTimeOut(&time_out_definition,
   803fc:	4629      	mov	r1, r5
   803fe:	4668      	mov	r0, sp
   80400:	4b09      	ldr	r3, [pc, #36]	; (80428 <freertos_obtain_peripheral_access_semphore+0x48>)
   80402:	4798      	blx	r3
   80404:	2801      	cmp	r0, #1
   80406:	d002      	beq.n	8040e <freertos_obtain_peripheral_access_semphore+0x2e>
	status_code_t return_value = STATUS_OK;
   80408:	2000      	movs	r0, #0
			}
		}
	}

	return return_value;
}
   8040a:	b003      	add	sp, #12
   8040c:	bd30      	pop	{r4, r5, pc}
				*max_block_time_ticks = 0;
   8040e:	2000      	movs	r0, #0
   80410:	6028      	str	r0, [r5, #0]
   80412:	e7fa      	b.n	8040a <freertos_obtain_peripheral_access_semphore+0x2a>
	status_code_t return_value = STATUS_OK;
   80414:	2000      	movs	r0, #0
   80416:	4770      	bx	lr
			return_value = ERR_TIMEOUT;
   80418:	f06f 0002 	mvn.w	r0, #2
   8041c:	e7f5      	b.n	8040a <freertos_obtain_peripheral_access_semphore+0x2a>
   8041e:	bf00      	nop
   80420:	00084f45 	.word	0x00084f45
   80424:	00084411 	.word	0x00084411
   80428:	00084f9d 	.word	0x00084f9d

0008042c <freertos_start_pdc_transfer>:
 */
void freertos_start_pdc_transfer(
		freertos_dma_event_control_t *dma_event_control,
		const uint8_t *data, size_t len, void *pdc_base_address,
		xSemaphoreHandle notification_semaphore, bool is_transmitting)
{
   8042c:	b5f0      	push	{r4, r5, r6, r7, lr}
   8042e:	b083      	sub	sp, #12
   80430:	460f      	mov	r7, r1
   80432:	4616      	mov	r6, r2
   80434:	461c      	mov	r4, r3
   80436:	9b08      	ldr	r3, [sp, #32]
   80438:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
	/* Remember which semaphore is to be used to indicate the end of
	transmission.  If notification_semaphore is NULL then either no
	semaphore is being used, or the driver is using an internal notification
	semaphore because it is configured to wait until the transmit has
	completed before returning. */
	if (notification_semaphore != NULL) {
   8043c:	b1b3      	cbz	r3, 8046c <freertos_start_pdc_transfer+0x40>
		dma_event_control->transaction_complete_notification_semaphore =
   8043e:	6003      	str	r3, [r0, #0]

	/* Ensure the notification semaphore starts in the expected state in case
	the previous PDC transfer didn't complete for any reason. */
	if (dma_event_control->transaction_complete_notification_semaphore !=
			NULL) {
		xSemaphoreTake(
   80440:	2100      	movs	r1, #0
   80442:	4618      	mov	r0, r3
   80444:	4b13      	ldr	r3, [pc, #76]	; (80494 <freertos_start_pdc_transfer+0x68>)
   80446:	4798      	blx	r3
				dma_event_control->transaction_complete_notification_semaphore,
				0);
	}

	/* Configure the PDC to transmit or receive parameters. */
	pdc_packet.ul_addr = (uint32_t) data;
   80448:	9700      	str	r7, [sp, #0]
	pdc_packet.ul_size = (uint32_t) len;
   8044a:	9601      	str	r6, [sp, #4]

	if (is_transmitting == true) {
   8044c:	b995      	cbnz	r5, 80474 <freertos_start_pdc_transfer+0x48>
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_TXTDIS);
		pdc_tx_init(pdc_base_address, &pdc_packet, NULL);
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_TXTEN);
	} else {
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_RXTDIS);
   8044e:	2102      	movs	r1, #2
   80450:	4620      	mov	r0, r4
   80452:	4b11      	ldr	r3, [pc, #68]	; (80498 <freertos_start_pdc_transfer+0x6c>)
   80454:	4798      	blx	r3
		pdc_rx_init(pdc_base_address, &pdc_packet, NULL);
   80456:	2200      	movs	r2, #0
   80458:	4669      	mov	r1, sp
   8045a:	4620      	mov	r0, r4
   8045c:	4b0f      	ldr	r3, [pc, #60]	; (8049c <freertos_start_pdc_transfer+0x70>)
   8045e:	4798      	blx	r3
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_RXTEN);
   80460:	2101      	movs	r1, #1
   80462:	4620      	mov	r0, r4
   80464:	4b0e      	ldr	r3, [pc, #56]	; (804a0 <freertos_start_pdc_transfer+0x74>)
   80466:	4798      	blx	r3
	}
}
   80468:	b003      	add	sp, #12
   8046a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (dma_event_control->transaction_complete_notification_semaphore !=
   8046c:	6803      	ldr	r3, [r0, #0]
   8046e:	2b00      	cmp	r3, #0
   80470:	d0ea      	beq.n	80448 <freertos_start_pdc_transfer+0x1c>
   80472:	e7e5      	b.n	80440 <freertos_start_pdc_transfer+0x14>
		pdc_disable_transfer(pdc_base_address, PERIPH_PTCR_TXTDIS);
   80474:	f44f 7100 	mov.w	r1, #512	; 0x200
   80478:	4620      	mov	r0, r4
   8047a:	4b07      	ldr	r3, [pc, #28]	; (80498 <freertos_start_pdc_transfer+0x6c>)
   8047c:	4798      	blx	r3
		pdc_tx_init(pdc_base_address, &pdc_packet, NULL);
   8047e:	2200      	movs	r2, #0
   80480:	4669      	mov	r1, sp
   80482:	4620      	mov	r0, r4
   80484:	4b07      	ldr	r3, [pc, #28]	; (804a4 <freertos_start_pdc_transfer+0x78>)
   80486:	4798      	blx	r3
		pdc_enable_transfer(pdc_base_address, PERIPH_PTCR_TXTEN);
   80488:	f44f 7180 	mov.w	r1, #256	; 0x100
   8048c:	4620      	mov	r0, r4
   8048e:	4b04      	ldr	r3, [pc, #16]	; (804a0 <freertos_start_pdc_transfer+0x74>)
   80490:	4798      	blx	r3
   80492:	e7e9      	b.n	80468 <freertos_start_pdc_transfer+0x3c>
   80494:	00084411 	.word	0x00084411
   80498:	00081d19 	.word	0x00081d19
   8049c:	00081cf5 	.word	0x00081cf5
   804a0:	00081d0d 	.word	0x00081d0d
   804a4:	00081cdd 	.word	0x00081cdd

000804a8 <freertos_optionally_wait_transfer_completion>:
		xSemaphoreHandle notification_semaphore,
		portTickType max_block_time_ticks)
{
	status_code_t return_value = STATUS_OK;

	if (notification_semaphore == NULL) {
   804a8:	b109      	cbz	r1, 804ae <freertos_optionally_wait_transfer_completion+0x6>
	status_code_t return_value = STATUS_OK;
   804aa:	2000      	movs	r0, #0
   804ac:	4770      	bx	lr
		if (dma_event_control->transaction_complete_notification_semaphore !=
   804ae:	6800      	ldr	r0, [r0, #0]
   804b0:	b148      	cbz	r0, 804c6 <freertos_optionally_wait_transfer_completion+0x1e>
{
   804b2:	b508      	push	{r3, lr}
   804b4:	4611      	mov	r1, r2
				NULL) {
			/* Wait until notified by the ISR that transmission is
			complete. */
			if (xSemaphoreTake(dma_event_control->
   804b6:	4b05      	ldr	r3, [pc, #20]	; (804cc <freertos_optionally_wait_transfer_completion+0x24>)
   804b8:	4798      	blx	r3
					transaction_complete_notification_semaphore,
					max_block_time_ticks) != pdPASS) {
				return_value = ERR_TIMEOUT;
   804ba:	2801      	cmp	r0, #1
   804bc:	bf0c      	ite	eq
   804be:	2000      	moveq	r0, #0
   804c0:	f06f 0002 	mvnne.w	r0, #2
   804c4:	bd08      	pop	{r3, pc}
	status_code_t return_value = STATUS_OK;
   804c6:	2000      	movs	r0, #0
   804c8:	4770      	bx	lr
   804ca:	bf00      	nop
   804cc:	00084411 	.word	0x00084411

000804d0 <local_twi_handler>:
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
   804d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   804d4:	b082      	sub	sp, #8
   804d6:	4607      	mov	r7, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
   804d8:	2300      	movs	r3, #0
   804da:	9301      	str	r3, [sp, #4]
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
   804dc:	0103      	lsls	r3, r0, #4
   804de:	4a7b      	ldr	r2, [pc, #492]	; (806cc <local_twi_handler+0x1fc>)
   804e0:	58d5      	ldr	r5, [r2, r3]

	twi_status = twi_get_interrupt_status(twi_port);
   804e2:	4628      	mov	r0, r5
   804e4:	4b7a      	ldr	r3, [pc, #488]	; (806d0 <local_twi_handler+0x200>)
   804e6:	4798      	blx	r3
   804e8:	4606      	mov	r6, r0
	twi_status &= twi_get_interrupt_mask(twi_port);
   804ea:	4628      	mov	r0, r5
   804ec:	4b79      	ldr	r3, [pc, #484]	; (806d4 <local_twi_handler+0x204>)
   804ee:	4798      	blx	r3
   804f0:	4006      	ands	r6, r0

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
   804f2:	f416 5f00 	tst.w	r6, #8192	; 0x2000
   804f6:	d135      	bne.n	80564 <local_twi_handler+0x94>
	bool transfer_timeout = false;
   804f8:	f04f 0800 	mov.w	r8, #0
			}
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
   804fc:	f416 5f80 	tst.w	r6, #4096	; 0x1000
   80500:	d17c      	bne.n	805fc <local_twi_handler+0x12c>
						&higher_priority_task_woken);
			}
		}
	}

	if (((twi_status & SR_ERROR_INTERRUPTS) != 0) || (transfer_timeout == true)) {
   80502:	f416 7f50 	tst.w	r6, #832	; 0x340
   80506:	d102      	bne.n	8050e <local_twi_handler+0x3e>
   80508:	f1b8 0f00 	cmp.w	r8, #0
   8050c:	d01d      	beq.n	8054a <local_twi_handler+0x7a>
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
   8050e:	4b6f      	ldr	r3, [pc, #444]	; (806cc <local_twi_handler+0x1fc>)
   80510:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   80514:	f240 2102 	movw	r1, #514	; 0x202
   80518:	6858      	ldr	r0, [r3, #4]
   8051a:	4b6f      	ldr	r3, [pc, #444]	; (806d8 <local_twi_handler+0x208>)
   8051c:	4798      	blx	r3

		if (!(twi_status & TWI_SR_NACK)) {
   8051e:	f416 7f80 	tst.w	r6, #256	; 0x100
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
   80522:	bf04      	itt	eq
   80524:	2302      	moveq	r3, #2
   80526:	602b      	streq	r3, [r5, #0]
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
   80528:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   8052c:	4628      	mov	r0, r5
   8052e:	4c6b      	ldr	r4, [pc, #428]	; (806dc <local_twi_handler+0x20c>)
   80530:	47a0      	blx	r4
		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
   80532:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   80536:	4628      	mov	r0, r5
   80538:	47a0      	blx	r4

		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
   8053a:	4b69      	ldr	r3, [pc, #420]	; (806e0 <local_twi_handler+0x210>)
   8053c:	eb03 07c7 	add.w	r7, r3, r7, lsl #3
   80540:	6878      	ldr	r0, [r7, #4]
   80542:	b110      	cbz	r0, 8054a <local_twi_handler+0x7a>
			xSemaphoreGiveFromISR(
   80544:	a901      	add	r1, sp, #4
   80546:	4b67      	ldr	r3, [pc, #412]	; (806e4 <local_twi_handler+0x214>)
   80548:	4798      	blx	r3
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
   8054a:	9b01      	ldr	r3, [sp, #4]
   8054c:	b13b      	cbz	r3, 8055e <local_twi_handler+0x8e>
   8054e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80552:	4b65      	ldr	r3, [pc, #404]	; (806e8 <local_twi_handler+0x218>)
   80554:	601a      	str	r2, [r3, #0]
   80556:	f3bf 8f4f 	dsb	sy
   8055a:	f3bf 8f6f 	isb	sy
}
   8055e:	b002      	add	sp, #8
   80560:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS);
   80564:	4b59      	ldr	r3, [pc, #356]	; (806cc <local_twi_handler+0x1fc>)
   80566:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   8056a:	f44f 7100 	mov.w	r1, #512	; 0x200
   8056e:	6858      	ldr	r0, [r3, #4]
   80570:	4b59      	ldr	r3, [pc, #356]	; (806d8 <local_twi_handler+0x208>)
   80572:	4798      	blx	r3
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
   80574:	f44f 5100 	mov.w	r1, #8192	; 0x2000
   80578:	4628      	mov	r0, r5
   8057a:	4b58      	ldr	r3, [pc, #352]	; (806dc <local_twi_handler+0x20c>)
   8057c:	4798      	blx	r3
		uint32_t timeout_counter = 0;
   8057e:	2400      	movs	r4, #0
			status = twi_port->TWI_SR;
   80580:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXRDY) {
   80582:	f013 0f04 	tst.w	r3, #4
   80586:	d106      	bne.n	80596 <local_twi_handler+0xc6>
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   80588:	3401      	adds	r4, #1
   8058a:	f1b4 3fff 	cmp.w	r4, #4294967295
   8058e:	d1f7      	bne.n	80580 <local_twi_handler+0xb0>
				transfer_timeout = true;
   80590:	f04f 0801 	mov.w	r8, #1
   80594:	e001      	b.n	8059a <local_twi_handler+0xca>
	bool transfer_timeout = false;
   80596:	f04f 0800 	mov.w	r8, #0
		twi_port->TWI_CR = TWI_CR_STOP;
   8059a:	2302      	movs	r3, #2
   8059c:	602b      	str	r3, [r5, #0]
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
   8059e:	4b53      	ldr	r3, [pc, #332]	; (806ec <local_twi_handler+0x21c>)
   805a0:	eb03 02c7 	add.w	r2, r3, r7, lsl #3
   805a4:	f853 3037 	ldr.w	r3, [r3, r7, lsl #3]
   805a8:	6852      	ldr	r2, [r2, #4]
   805aa:	4413      	add	r3, r2
   805ac:	f813 3c01 	ldrb.w	r3, [r3, #-1]
   805b0:	636b      	str	r3, [r5, #52]	; 0x34
			status = twi_port->TWI_SR;
   805b2:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXCOMP) {
   805b4:	f013 0f01 	tst.w	r3, #1
   805b8:	d10c      	bne.n	805d4 <local_twi_handler+0x104>
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   805ba:	3401      	adds	r4, #1
   805bc:	f1b4 3fff 	cmp.w	r4, #4294967295
   805c0:	d1f7      	bne.n	805b2 <local_twi_handler+0xe2>
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
   805c2:	4b47      	ldr	r3, [pc, #284]	; (806e0 <local_twi_handler+0x210>)
   805c4:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   805c8:	6858      	ldr	r0, [r3, #4]
   805ca:	2800      	cmp	r0, #0
   805cc:	d07a      	beq.n	806c4 <local_twi_handler+0x1f4>
				transfer_timeout = true;
   805ce:	f04f 0801 	mov.w	r8, #1
   805d2:	e004      	b.n	805de <local_twi_handler+0x10e>
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
   805d4:	4b42      	ldr	r3, [pc, #264]	; (806e0 <local_twi_handler+0x210>)
   805d6:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   805da:	6858      	ldr	r0, [r3, #4]
   805dc:	b110      	cbz	r0, 805e4 <local_twi_handler+0x114>
			xSemaphoreGiveFromISR(
   805de:	a901      	add	r1, sp, #4
   805e0:	4b40      	ldr	r3, [pc, #256]	; (806e4 <local_twi_handler+0x214>)
   805e2:	4798      	blx	r3
		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
   805e4:	f1b4 3fff 	cmp.w	r4, #4294967295
   805e8:	d088      	beq.n	804fc <local_twi_handler+0x2c>
			if (tx_dma_control[twi_index]. transaction_complete_notification_semaphore != NULL) {
   805ea:	4b3d      	ldr	r3, [pc, #244]	; (806e0 <local_twi_handler+0x210>)
   805ec:	f853 0037 	ldr.w	r0, [r3, r7, lsl #3]
   805f0:	2800      	cmp	r0, #0
   805f2:	d083      	beq.n	804fc <local_twi_handler+0x2c>
				xSemaphoreGiveFromISR(
   805f4:	a901      	add	r1, sp, #4
   805f6:	4b3b      	ldr	r3, [pc, #236]	; (806e4 <local_twi_handler+0x214>)
   805f8:	4798      	blx	r3
   805fa:	e77f      	b.n	804fc <local_twi_handler+0x2c>
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_RXTDIS);
   805fc:	4b33      	ldr	r3, [pc, #204]	; (806cc <local_twi_handler+0x1fc>)
   805fe:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   80602:	2102      	movs	r1, #2
   80604:	6858      	ldr	r0, [r3, #4]
   80606:	4b34      	ldr	r3, [pc, #208]	; (806d8 <local_twi_handler+0x208>)
   80608:	4798      	blx	r3
		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
   8060a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   8060e:	4628      	mov	r0, r5
   80610:	4b32      	ldr	r3, [pc, #200]	; (806dc <local_twi_handler+0x20c>)
   80612:	4798      	blx	r3
		uint32_t timeout_counter = 0;
   80614:	2400      	movs	r4, #0
			status = twi_port->TWI_SR;
   80616:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
   80618:	f013 0f02 	tst.w	r3, #2
   8061c:	d103      	bne.n	80626 <local_twi_handler+0x156>
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   8061e:	3401      	adds	r4, #1
   80620:	f1b4 3fff 	cmp.w	r4, #4294967295
   80624:	d1f7      	bne.n	80616 <local_twi_handler+0x146>
		twi_port->TWI_CR = TWI_CR_STOP;
   80626:	2302      	movs	r3, #2
   80628:	602b      	str	r3, [r5, #0]
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
   8062a:	4b30      	ldr	r3, [pc, #192]	; (806ec <local_twi_handler+0x21c>)
   8062c:	f853 2037 	ldr.w	r2, [r3, r7, lsl #3]
   80630:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   80634:	6859      	ldr	r1, [r3, #4]
   80636:	6b28      	ldr	r0, [r5, #48]	; 0x30
   80638:	1853      	adds	r3, r2, r1
   8063a:	f803 0c02 	strb.w	r0, [r3, #-2]
			status = twi_port->TWI_SR;
   8063e:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
   80640:	f013 0f02 	tst.w	r3, #2
   80644:	d11b      	bne.n	8067e <local_twi_handler+0x1ae>
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   80646:	3401      	adds	r4, #1
   80648:	f1b4 3fff 	cmp.w	r4, #4294967295
   8064c:	d1f7      	bne.n	8063e <local_twi_handler+0x16e>
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
   8064e:	4b24      	ldr	r3, [pc, #144]	; (806e0 <local_twi_handler+0x210>)
   80650:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   80654:	6858      	ldr	r0, [r3, #4]
   80656:	2800      	cmp	r0, #0
   80658:	f43f af53 	beq.w	80502 <local_twi_handler+0x32>
			xSemaphoreGiveFromISR(
   8065c:	a901      	add	r1, sp, #4
   8065e:	4b21      	ldr	r3, [pc, #132]	; (806e4 <local_twi_handler+0x214>)
   80660:	4798      	blx	r3
		if  (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
   80662:	f1b4 3fff 	cmp.w	r4, #4294967295
   80666:	f43f af4c 	beq.w	80502 <local_twi_handler+0x32>
			if (rx_dma_control[twi_index].transaction_complete_notification_semaphore != NULL) {
   8066a:	4b21      	ldr	r3, [pc, #132]	; (806f0 <local_twi_handler+0x220>)
   8066c:	f853 0037 	ldr.w	r0, [r3, r7, lsl #3]
   80670:	2800      	cmp	r0, #0
   80672:	f43f af46 	beq.w	80502 <local_twi_handler+0x32>
				xSemaphoreGiveFromISR(
   80676:	a901      	add	r1, sp, #4
   80678:	4b1a      	ldr	r3, [pc, #104]	; (806e4 <local_twi_handler+0x214>)
   8067a:	4798      	blx	r3
   8067c:	e741      	b.n	80502 <local_twi_handler+0x32>
		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
   8067e:	f1b4 3fff 	cmp.w	r4, #4294967295
   80682:	d00e      	beq.n	806a2 <local_twi_handler+0x1d2>
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
   80684:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   80686:	440a      	add	r2, r1
   80688:	f802 3c01 	strb.w	r3, [r2, #-1]
			timeout_counter = 0;
   8068c:	2400      	movs	r4, #0
				status = twi_port->TWI_SR;
   8068e:	6a2b      	ldr	r3, [r5, #32]
				if (status & TWI_SR_TXCOMP) {
   80690:	f013 0f01 	tst.w	r3, #1
   80694:	d10f      	bne.n	806b6 <local_twi_handler+0x1e6>
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
   80696:	3401      	adds	r4, #1
   80698:	f1b4 3fff 	cmp.w	r4, #4294967295
   8069c:	d1f7      	bne.n	8068e <local_twi_handler+0x1be>
					transfer_timeout = true;
   8069e:	f04f 0801 	mov.w	r8, #1
		if (tx_dma_control[twi_index].peripheral_access_sem != NULL) {
   806a2:	4b0f      	ldr	r3, [pc, #60]	; (806e0 <local_twi_handler+0x210>)
   806a4:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   806a8:	6858      	ldr	r0, [r3, #4]
   806aa:	2800      	cmp	r0, #0
   806ac:	f43f af29 	beq.w	80502 <local_twi_handler+0x32>
   806b0:	f04f 34ff 	mov.w	r4, #4294967295
   806b4:	e7d2      	b.n	8065c <local_twi_handler+0x18c>
   806b6:	4b0a      	ldr	r3, [pc, #40]	; (806e0 <local_twi_handler+0x210>)
   806b8:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
   806bc:	6858      	ldr	r0, [r3, #4]
   806be:	2800      	cmp	r0, #0
   806c0:	d1cc      	bne.n	8065c <local_twi_handler+0x18c>
   806c2:	e7ce      	b.n	80662 <local_twi_handler+0x192>
				transfer_timeout = true;
   806c4:	f04f 0801 	mov.w	r8, #1
   806c8:	e718      	b.n	804fc <local_twi_handler+0x2c>
   806ca:	bf00      	nop
   806cc:	00085eb8 	.word	0x00085eb8
   806d0:	00082057 	.word	0x00082057
   806d4:	0008205b 	.word	0x0008205b
   806d8:	00081d19 	.word	0x00081d19
   806dc:	00082051 	.word	0x00082051
   806e0:	20070728 	.word	0x20070728
   806e4:	000841d9 	.word	0x000841d9
   806e8:	e000ed04 	.word	0xe000ed04
   806ec:	20070718 	.word	0x20070718
   806f0:	20070708 	.word	0x20070708

000806f4 <TWI0_Handler>:
#endif /* TWI */

#ifdef TWI0

void TWI0_Handler(void)
{
   806f4:	b508      	push	{r3, lr}
	local_twi_handler(0);
   806f6:	2000      	movs	r0, #0
   806f8:	4b01      	ldr	r3, [pc, #4]	; (80700 <TWI0_Handler+0xc>)
   806fa:	4798      	blx	r3
   806fc:	bd08      	pop	{r3, pc}
   806fe:	bf00      	nop
   80700:	000804d1 	.word	0x000804d1

00080704 <TWI1_Handler>:
#endif

#ifdef TWI1

void TWI1_Handler(void)
{
   80704:	b508      	push	{r3, lr}
	local_twi_handler(1);
   80706:	2001      	movs	r0, #1
   80708:	4b01      	ldr	r3, [pc, #4]	; (80710 <TWI1_Handler+0xc>)
   8070a:	4798      	blx	r3
   8070c:	bd08      	pop	{r3, pc}
   8070e:	bf00      	nop
   80710:	000804d1 	.word	0x000804d1

00080714 <configure_rx_dma>:
 * For internal use only.
 * Configures the Rx DMA to receive data into free space within the Rx buffer.
 */
static void configure_rx_dma(uint32_t uart_index,
		enum buffer_operations operation_performed)
{
   80714:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   80716:	4604      	mov	r4, r0
	rx_buffer_definition = &(rx_buffer_definitions[uart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
   80718:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   8071c:	4b30      	ldr	r3, [pc, #192]	; (807e0 <configure_rx_dma+0xcc>)
   8071e:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   80722:	699a      	ldr	r2, [r3, #24]
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
   80724:	689b      	ldr	r3, [r3, #8]
	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
   80726:	429a      	cmp	r2, r3
   80728:	d020      	beq.n	8076c <configure_rx_dma+0x58>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
   8072a:	429a      	cmp	r2, r3
   8072c:	d938      	bls.n	807a0 <configure_rx_dma+0x8c>
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
		/* The read pointer is ahead of the write pointer.  The space available
		is up to the write pointer to ensure unread data is not overwritten. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   8072e:	ebc0 01c0 	rsb	r1, r0, r0, lsl #3
   80732:	482b      	ldr	r0, [pc, #172]	; (807e0 <configure_rx_dma+0xcc>)
   80734:	eb00 0181 	add.w	r1, r0, r1, lsl #2
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   80738:	1ad2      	subs	r2, r2, r3
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   8073a:	60ca      	str	r2, [r1, #12]
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr+
   8073c:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
   80740:	4927      	ldr	r1, [pc, #156]	; (807e0 <configure_rx_dma+0xcc>)
   80742:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   80746:	68d1      	ldr	r1, [r2, #12]
   80748:	440b      	add	r3, r1
   8074a:	6852      	ldr	r2, [r2, #4]
   8074c:	4293      	cmp	r3, r2
   8074e:	d818      	bhi.n	80782 <configure_rx_dma+0x6e>
			rx_buffer_definition->rx_pdc_parameters.ul_size) <=
			rx_buffer_definition->past_rx_buffer_end_address);

	if (rx_buffer_definition->rx_pdc_parameters.ul_size > 0) {
   80750:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80754:	4a22      	ldr	r2, [pc, #136]	; (807e0 <configure_rx_dma+0xcc>)
   80756:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   8075a:	68db      	ldr	r3, [r3, #12]
   8075c:	bb4b      	cbnz	r3, 807b2 <configure_rx_dma+0x9e>
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		uart_disable_interrupt(
				all_uart_definitions[uart_index].peripheral_base_address,
   8075e:	0124      	lsls	r4, r4, #4
		uart_disable_interrupt(
   80760:	2109      	movs	r1, #9
   80762:	4b20      	ldr	r3, [pc, #128]	; (807e4 <configure_rx_dma+0xd0>)
   80764:	5918      	ldr	r0, [r3, r4]
   80766:	4b20      	ldr	r3, [pc, #128]	; (807e8 <configure_rx_dma+0xd4>)
   80768:	4798      	blx	r3
   8076a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (operation_performed == data_added) {
   8076c:	b979      	cbnz	r1, 8078e <configure_rx_dma+0x7a>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
   8076e:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   80772:	491b      	ldr	r1, [pc, #108]	; (807e0 <configure_rx_dma+0xcc>)
   80774:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   80778:	2100      	movs	r1, #0
   8077a:	60d1      	str	r1, [r2, #12]
	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr+
   8077c:	6852      	ldr	r2, [r2, #4]
   8077e:	4293      	cmp	r3, r2
   80780:	d9ed      	bls.n	8075e <configure_rx_dma+0x4a>
   80782:	f44f 7113 	mov.w	r1, #588	; 0x24c
   80786:	4819      	ldr	r0, [pc, #100]	; (807ec <configure_rx_dma+0xd8>)
   80788:	4b19      	ldr	r3, [pc, #100]	; (807f0 <configure_rx_dma+0xdc>)
   8078a:	4798      	blx	r3
   8078c:	e7e0      	b.n	80750 <configure_rx_dma+0x3c>
			rx_buffer_definition->rx_pdc_parameters.ul_size =
   8078e:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   80792:	4913      	ldr	r1, [pc, #76]	; (807e0 <configure_rx_dma+0xcc>)
   80794:	eb01 0282 	add.w	r2, r1, r2, lsl #2
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   80798:	6851      	ldr	r1, [r2, #4]
   8079a:	1ac9      	subs	r1, r1, r3
			rx_buffer_definition->rx_pdc_parameters.ul_size =
   8079c:	60d1      	str	r1, [r2, #12]
   8079e:	e7cd      	b.n	8073c <configure_rx_dma+0x28>
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   807a0:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   807a4:	490e      	ldr	r1, [pc, #56]	; (807e0 <configure_rx_dma+0xcc>)
   807a6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   807aa:	6851      	ldr	r1, [r2, #4]
   807ac:	1ac9      	subs	r1, r1, r3
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   807ae:	60d1      	str	r1, [r2, #12]
   807b0:	e7c4      	b.n	8073c <configure_rx_dma+0x28>
		pdc_rx_init(
   807b2:	4e0c      	ldr	r6, [pc, #48]	; (807e4 <configure_rx_dma+0xd0>)
   807b4:	0125      	lsls	r5, r4, #4
   807b6:	1973      	adds	r3, r6, r5
   807b8:	685f      	ldr	r7, [r3, #4]
   807ba:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   807be:	eb02 0184 	add.w	r1, r2, r4, lsl #2
   807c2:	2200      	movs	r2, #0
   807c4:	3108      	adds	r1, #8
   807c6:	4638      	mov	r0, r7
   807c8:	4b0a      	ldr	r3, [pc, #40]	; (807f4 <configure_rx_dma+0xe0>)
   807ca:	4798      	blx	r3
		pdc_enable_transfer(
   807cc:	2101      	movs	r1, #1
   807ce:	4638      	mov	r0, r7
   807d0:	4b09      	ldr	r3, [pc, #36]	; (807f8 <configure_rx_dma+0xe4>)
   807d2:	4798      	blx	r3
		uart_enable_interrupt(
   807d4:	2109      	movs	r1, #9
   807d6:	5970      	ldr	r0, [r6, r5]
   807d8:	4b08      	ldr	r3, [pc, #32]	; (807fc <configure_rx_dma+0xe8>)
   807da:	4798      	blx	r3
   807dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   807de:	bf00      	nop
   807e0:	20070738 	.word	0x20070738
   807e4:	00085ed8 	.word	0x00085ed8
   807e8:	00082063 	.word	0x00082063
   807ec:	00085ee8 	.word	0x00085ee8
   807f0:	00085861 	.word	0x00085861
   807f4:	00081cf5 	.word	0x00081cf5
   807f8:	00081d0d 	.word	0x00081d0d
   807fc:	0008205f 	.word	0x0008205f

00080800 <UART_Handler>:
 */

#ifdef UART

void UART_Handler(void)
{
   80800:	b530      	push	{r4, r5, lr}
   80802:	b083      	sub	sp, #12
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
   80804:	2300      	movs	r3, #0
   80806:	9301      	str	r3, [sp, #4]
	uart_status = uart_get_status(
   80808:	4d37      	ldr	r5, [pc, #220]	; (808e8 <UART_Handler+0xe8>)
   8080a:	4628      	mov	r0, r5
   8080c:	4b37      	ldr	r3, [pc, #220]	; (808ec <UART_Handler+0xec>)
   8080e:	4798      	blx	r3
   80810:	4604      	mov	r4, r0
	uart_status &= uart_get_interrupt_mask(
   80812:	4628      	mov	r0, r5
   80814:	4b36      	ldr	r3, [pc, #216]	; (808f0 <UART_Handler+0xf0>)
   80816:	4798      	blx	r3
   80818:	4004      	ands	r4, r0
	if ((uart_status & UART_SR_ENDTX) != 0UL) {
   8081a:	f014 0f10 	tst.w	r4, #16
   8081e:	d134      	bne.n	8088a <UART_Handler+0x8a>
	if ((uart_status & UART_SR_ENDRX) != 0UL) {
   80820:	f014 0f08 	tst.w	r4, #8
   80824:	d01d      	beq.n	80862 <UART_Handler+0x62>
		configASSERT(rx_buffer_definition->next_byte_to_read);
   80826:	4b33      	ldr	r3, [pc, #204]	; (808f4 <UART_Handler+0xf4>)
   80828:	699b      	ldr	r3, [r3, #24]
   8082a:	2b00      	cmp	r3, #0
   8082c:	d03f      	beq.n	808ae <UART_Handler+0xae>
		configASSERT(rx_buffer_definition->next_byte_to_read !=
   8082e:	4b31      	ldr	r3, [pc, #196]	; (808f4 <UART_Handler+0xf4>)
   80830:	699b      	ldr	r3, [r3, #24]
   80832:	2b01      	cmp	r3, #1
   80834:	d041      	beq.n	808ba <UART_Handler+0xba>
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
   80836:	4a2f      	ldr	r2, [pc, #188]	; (808f4 <UART_Handler+0xf4>)
   80838:	6893      	ldr	r3, [r2, #8]
   8083a:	68d1      	ldr	r1, [r2, #12]
   8083c:	440b      	add	r3, r1
   8083e:	6093      	str	r3, [r2, #8]
		if (rx_buffer_definition->rx_pdc_parameters.ul_addr >=
   80840:	6852      	ldr	r2, [r2, #4]
   80842:	4293      	cmp	r3, r2
   80844:	d302      	bcc.n	8084c <UART_Handler+0x4c>
			rx_buffer_definition->rx_pdc_parameters.ul_addr =
   80846:	4b2b      	ldr	r3, [pc, #172]	; (808f4 <UART_Handler+0xf4>)
   80848:	681a      	ldr	r2, [r3, #0]
   8084a:	609a      	str	r2, [r3, #8]
		configure_rx_dma(uart_index, data_added);
   8084c:	2100      	movs	r1, #0
   8084e:	4608      	mov	r0, r1
   80850:	4b29      	ldr	r3, [pc, #164]	; (808f8 <UART_Handler+0xf8>)
   80852:	4798      	blx	r3
		if (rx_buffer_definition->rx_event_semaphore != NULL) {
   80854:	4b27      	ldr	r3, [pc, #156]	; (808f4 <UART_Handler+0xf4>)
   80856:	6918      	ldr	r0, [r3, #16]
   80858:	2800      	cmp	r0, #0
   8085a:	d034      	beq.n	808c6 <UART_Handler+0xc6>
			xSemaphoreGiveFromISR(
   8085c:	a901      	add	r1, sp, #4
   8085e:	4b27      	ldr	r3, [pc, #156]	; (808fc <UART_Handler+0xfc>)
   80860:	4798      	blx	r3
	if (uart_status == 0UL) {
   80862:	2c00      	cmp	r4, #0
   80864:	d131      	bne.n	808ca <UART_Handler+0xca>
		if (rx_buffer_definition->rx_event_semaphore != NULL) {
   80866:	4b23      	ldr	r3, [pc, #140]	; (808f4 <UART_Handler+0xf4>)
   80868:	6918      	ldr	r0, [r3, #16]
   8086a:	b110      	cbz	r0, 80872 <UART_Handler+0x72>
			xSemaphoreGiveFromISR(
   8086c:	a901      	add	r1, sp, #4
   8086e:	4b23      	ldr	r3, [pc, #140]	; (808fc <UART_Handler+0xfc>)
   80870:	4798      	blx	r3
	portEND_SWITCHING_ISR(higher_priority_task_woken);
   80872:	9b01      	ldr	r3, [sp, #4]
   80874:	b13b      	cbz	r3, 80886 <UART_Handler+0x86>
   80876:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   8087a:	4b21      	ldr	r3, [pc, #132]	; (80900 <UART_Handler+0x100>)
   8087c:	601a      	str	r2, [r3, #0]
   8087e:	f3bf 8f4f 	dsb	sy
   80882:	f3bf 8f6f 	isb	sy
	local_uart_handler(0);
}
   80886:	b003      	add	sp, #12
   80888:	bd30      	pop	{r4, r5, pc}
		uart_disable_interrupt(
   8088a:	2110      	movs	r1, #16
   8088c:	4628      	mov	r0, r5
   8088e:	4b1d      	ldr	r3, [pc, #116]	; (80904 <UART_Handler+0x104>)
   80890:	4798      	blx	r3
		if (tx_dma_control[uart_index].peripheral_access_sem != NULL) {
   80892:	4b1d      	ldr	r3, [pc, #116]	; (80908 <UART_Handler+0x108>)
   80894:	6858      	ldr	r0, [r3, #4]
   80896:	b110      	cbz	r0, 8089e <UART_Handler+0x9e>
			xSemaphoreGiveFromISR(
   80898:	a901      	add	r1, sp, #4
   8089a:	4b18      	ldr	r3, [pc, #96]	; (808fc <UART_Handler+0xfc>)
   8089c:	4798      	blx	r3
		if (tx_dma_control[uart_index].transaction_complete_notification_semaphore != NULL) {
   8089e:	4b1a      	ldr	r3, [pc, #104]	; (80908 <UART_Handler+0x108>)
   808a0:	6818      	ldr	r0, [r3, #0]
   808a2:	2800      	cmp	r0, #0
   808a4:	d0bc      	beq.n	80820 <UART_Handler+0x20>
			xSemaphoreGiveFromISR(
   808a6:	a901      	add	r1, sp, #4
   808a8:	4b14      	ldr	r3, [pc, #80]	; (808fc <UART_Handler+0xfc>)
   808aa:	4798      	blx	r3
   808ac:	e7b8      	b.n	80820 <UART_Handler+0x20>
		configASSERT(rx_buffer_definition->next_byte_to_read);
   808ae:	f44f 7124 	mov.w	r1, #656	; 0x290
   808b2:	4816      	ldr	r0, [pc, #88]	; (8090c <UART_Handler+0x10c>)
   808b4:	4b16      	ldr	r3, [pc, #88]	; (80910 <UART_Handler+0x110>)
   808b6:	4798      	blx	r3
   808b8:	e7b9      	b.n	8082e <UART_Handler+0x2e>
		configASSERT(rx_buffer_definition->next_byte_to_read !=
   808ba:	f240 2192 	movw	r1, #658	; 0x292
   808be:	4813      	ldr	r0, [pc, #76]	; (8090c <UART_Handler+0x10c>)
   808c0:	4b13      	ldr	r3, [pc, #76]	; (80910 <UART_Handler+0x110>)
   808c2:	4798      	blx	r3
   808c4:	e7b7      	b.n	80836 <UART_Handler+0x36>
	if (uart_status == 0UL) {
   808c6:	2c00      	cmp	r4, #0
   808c8:	d0d3      	beq.n	80872 <UART_Handler+0x72>
	if ((uart_status & SR_ERROR_INTERRUPTS) != 0) {
   808ca:	f014 0fe0 	tst.w	r4, #224	; 0xe0
   808ce:	d0d0      	beq.n	80872 <UART_Handler+0x72>
		uart_reset_status(
   808d0:	4805      	ldr	r0, [pc, #20]	; (808e8 <UART_Handler+0xe8>)
   808d2:	4b10      	ldr	r3, [pc, #64]	; (80914 <UART_Handler+0x114>)
   808d4:	4798      	blx	r3
		if (tx_dma_control[uart_index].peripheral_access_sem != NULL) {
   808d6:	4b0c      	ldr	r3, [pc, #48]	; (80908 <UART_Handler+0x108>)
   808d8:	6858      	ldr	r0, [r3, #4]
   808da:	2800      	cmp	r0, #0
   808dc:	d0c9      	beq.n	80872 <UART_Handler+0x72>
			xSemaphoreGiveFromISR(
   808de:	a901      	add	r1, sp, #4
   808e0:	4b06      	ldr	r3, [pc, #24]	; (808fc <UART_Handler+0xfc>)
   808e2:	4798      	blx	r3
   808e4:	e7c5      	b.n	80872 <UART_Handler+0x72>
   808e6:	bf00      	nop
   808e8:	400e0800 	.word	0x400e0800
   808ec:	0008206b 	.word	0x0008206b
   808f0:	00082067 	.word	0x00082067
   808f4:	20070738 	.word	0x20070738
   808f8:	00080715 	.word	0x00080715
   808fc:	000841d9 	.word	0x000841d9
   80900:	e000ed04 	.word	0xe000ed04
   80904:	00082063 	.word	0x00082063
   80908:	20070754 	.word	0x20070754
   8090c:	00085ee8 	.word	0x00085ee8
   80910:	00085861 	.word	0x00085861
   80914:	0008206f 	.word	0x0008206f

00080918 <configure_rx_dma>:
 * For internal use only.
 * Configures the Rx DMA to receive data into free space within the Rx buffer.
 */
static void configure_rx_dma(uint32_t usart_index,
		enum buffer_operations operation_performed)
{
   80918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8091a:	4604      	mov	r4, r0
	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* How much space is there between the start of the DMA buffer and the
	current read pointer?  */

	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
   8091c:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   80920:	4b31      	ldr	r3, [pc, #196]	; (809e8 <configure_rx_dma+0xd0>)
   80922:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   80926:	699a      	ldr	r2, [r3, #24]
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
   80928:	689b      	ldr	r3, [r3, #8]
	if (((uint32_t)rx_buffer_definition->next_byte_to_read) ==
   8092a:	429a      	cmp	r2, r3
   8092c:	d021      	beq.n	80972 <configure_rx_dma+0x5a>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
		} else {
			rx_buffer_definition->rx_pdc_parameters.ul_size =
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
		}
	} else if (((uint32_t)rx_buffer_definition->next_byte_to_read) >
   8092e:	429a      	cmp	r2, r3
   80930:	d939      	bls.n	809a6 <configure_rx_dma+0x8e>
			rx_buffer_definition->rx_pdc_parameters.ul_addr) {
		/* The read pointer is ahead of the write pointer.  The space available
		is up to the write pointer to ensure unread data is not overwritten. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   80932:	ebc0 01c0 	rsb	r1, r0, r0, lsl #3
   80936:	482c      	ldr	r0, [pc, #176]	; (809e8 <configure_rx_dma+0xd0>)
   80938:	eb00 0181 	add.w	r1, r0, r1, lsl #2
			((uint32_t) rx_buffer_definition->next_byte_to_read) - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   8093c:	1ad2      	subs	r2, r2, r3
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   8093e:	60ca      	str	r2, [r1, #12]
		available is up to the end of the buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_size =
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
	}

	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr +
   80940:	ebc4 02c4 	rsb	r2, r4, r4, lsl #3
   80944:	4928      	ldr	r1, [pc, #160]	; (809e8 <configure_rx_dma+0xd0>)
   80946:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   8094a:	68d1      	ldr	r1, [r2, #12]
   8094c:	440b      	add	r3, r1
   8094e:	6852      	ldr	r2, [r2, #4]
   80950:	4293      	cmp	r3, r2
   80952:	d819      	bhi.n	80988 <configure_rx_dma+0x70>
			rx_buffer_definition->rx_pdc_parameters.ul_size) <=
			rx_buffer_definition->past_rx_buffer_end_address);

	if (rx_buffer_definition->rx_pdc_parameters.ul_size > 0) {
   80954:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80958:	4a23      	ldr	r2, [pc, #140]	; (809e8 <configure_rx_dma+0xd0>)
   8095a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   8095e:	68db      	ldr	r3, [r3, #12]
   80960:	bb53      	cbnz	r3, 809b8 <configure_rx_dma+0xa0>
	} else {
		/* The write pointer has reached the read pointer.  There is no
		more room so the DMA is not re-enabled until a read has created
		space. */
		usart_disable_interrupt(
				all_usart_definitions[usart_index].peripheral_base_address, US_IER_ENDRX |
   80962:	0124      	lsls	r4, r4, #4
		usart_disable_interrupt(
   80964:	f44f 7184 	mov.w	r1, #264	; 0x108
   80968:	4b20      	ldr	r3, [pc, #128]	; (809ec <configure_rx_dma+0xd4>)
   8096a:	5918      	ldr	r0, [r3, r4]
   8096c:	4b20      	ldr	r3, [pc, #128]	; (809f0 <configure_rx_dma+0xd8>)
   8096e:	4798      	blx	r3
   80970:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (operation_performed == data_added) {
   80972:	b979      	cbnz	r1, 80994 <configure_rx_dma+0x7c>
			rx_buffer_definition->rx_pdc_parameters.ul_size = 0UL;
   80974:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   80978:	491b      	ldr	r1, [pc, #108]	; (809e8 <configure_rx_dma+0xd0>)
   8097a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   8097e:	2100      	movs	r1, #0
   80980:	60d1      	str	r1, [r2, #12]
	configASSERT((rx_buffer_definition->rx_pdc_parameters.ul_addr +
   80982:	6852      	ldr	r2, [r2, #4]
   80984:	4293      	cmp	r3, r2
   80986:	d9ec      	bls.n	80962 <configure_rx_dma+0x4a>
   80988:	f240 2191 	movw	r1, #657	; 0x291
   8098c:	4819      	ldr	r0, [pc, #100]	; (809f4 <configure_rx_dma+0xdc>)
   8098e:	4b1a      	ldr	r3, [pc, #104]	; (809f8 <configure_rx_dma+0xe0>)
   80990:	4798      	blx	r3
   80992:	e7df      	b.n	80954 <configure_rx_dma+0x3c>
			rx_buffer_definition->rx_pdc_parameters.ul_size =
   80994:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   80998:	4913      	ldr	r1, [pc, #76]	; (809e8 <configure_rx_dma+0xd0>)
   8099a:	eb01 0282 	add.w	r2, r1, r2, lsl #2
				rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   8099e:	6851      	ldr	r1, [r2, #4]
   809a0:	1ac9      	subs	r1, r1, r3
			rx_buffer_definition->rx_pdc_parameters.ul_size =
   809a2:	60d1      	str	r1, [r2, #12]
   809a4:	e7cc      	b.n	80940 <configure_rx_dma+0x28>
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   809a6:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   809aa:	490f      	ldr	r1, [pc, #60]	; (809e8 <configure_rx_dma+0xd0>)
   809ac:	eb01 0282 	add.w	r2, r1, r2, lsl #2
			rx_buffer_definition->past_rx_buffer_end_address - rx_buffer_definition->rx_pdc_parameters.ul_addr;
   809b0:	6851      	ldr	r1, [r2, #4]
   809b2:	1ac9      	subs	r1, r1, r3
		rx_buffer_definition->rx_pdc_parameters.ul_size =
   809b4:	60d1      	str	r1, [r2, #12]
   809b6:	e7c3      	b.n	80940 <configure_rx_dma+0x28>
		pdc_rx_init(
   809b8:	4e0c      	ldr	r6, [pc, #48]	; (809ec <configure_rx_dma+0xd4>)
   809ba:	0125      	lsls	r5, r4, #4
   809bc:	1973      	adds	r3, r6, r5
   809be:	685f      	ldr	r7, [r3, #4]
   809c0:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   809c4:	eb02 0184 	add.w	r1, r2, r4, lsl #2
   809c8:	2200      	movs	r2, #0
   809ca:	3108      	adds	r1, #8
   809cc:	4638      	mov	r0, r7
   809ce:	4b0b      	ldr	r3, [pc, #44]	; (809fc <configure_rx_dma+0xe4>)
   809d0:	4798      	blx	r3
		pdc_enable_transfer(
   809d2:	2101      	movs	r1, #1
   809d4:	4638      	mov	r0, r7
   809d6:	4b0a      	ldr	r3, [pc, #40]	; (80a00 <configure_rx_dma+0xe8>)
   809d8:	4798      	blx	r3
		usart_enable_interrupt(
   809da:	f44f 7184 	mov.w	r1, #264	; 0x108
   809de:	5970      	ldr	r0, [r6, r5]
   809e0:	4b08      	ldr	r3, [pc, #32]	; (80a04 <configure_rx_dma+0xec>)
   809e2:	4798      	blx	r3
   809e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   809e6:	bf00      	nop
   809e8:	2007075c 	.word	0x2007075c
   809ec:	00085f28 	.word	0x00085f28
   809f0:	0008344d 	.word	0x0008344d
   809f4:	00085f68 	.word	0x00085f68
   809f8:	00085861 	.word	0x00085861
   809fc:	00081cf5 	.word	0x00081cf5
   80a00:	00081d0d 	.word	0x00081d0d
   80a04:	00083449 	.word	0x00083449

00080a08 <local_usart_handler>:
/*
 * For internal use only.
 * A common USART interrupt handler that is called for all USART peripherals.
 */
static void local_usart_handler(const portBASE_TYPE usart_index)
{
   80a08:	b570      	push	{r4, r5, r6, lr}
   80a0a:	b082      	sub	sp, #8
   80a0c:	4604      	mov	r4, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
   80a0e:	2300      	movs	r3, #0
   80a10:	9301      	str	r3, [sp, #4]
	uint32_t usart_status;
	freertos_pdc_rx_control_t *rx_buffer_definition;

	usart_status = usart_get_status(
			all_usart_definitions[usart_index].peripheral_base_address);
   80a12:	0103      	lsls	r3, r0, #4
   80a14:	4a47      	ldr	r2, [pc, #284]	; (80b34 <local_usart_handler+0x12c>)
   80a16:	58d6      	ldr	r6, [r2, r3]
	usart_status = usart_get_status(
   80a18:	4630      	mov	r0, r6
   80a1a:	4b47      	ldr	r3, [pc, #284]	; (80b38 <local_usart_handler+0x130>)
   80a1c:	4798      	blx	r3
   80a1e:	4605      	mov	r5, r0
	usart_status &= usart_get_interrupt_mask(
   80a20:	4630      	mov	r0, r6
   80a22:	4b46      	ldr	r3, [pc, #280]	; (80b3c <local_usart_handler+0x134>)
   80a24:	4798      	blx	r3
   80a26:	4005      	ands	r5, r0
			all_usart_definitions[usart_index].peripheral_base_address);

	rx_buffer_definition = &(rx_buffer_definitions[usart_index]);

	/* Has the PDC completed a transmission? */
	if ((usart_status & US_CSR_ENDTX) != 0UL) {
   80a28:	f015 0f10 	tst.w	r5, #16
   80a2c:	d145      	bne.n	80aba <local_usart_handler+0xb2>
					tx_dma_control[usart_index].transaction_complete_notification_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & US_CSR_ENDRX) != 0UL) {
   80a2e:	f015 0f08 	tst.w	r5, #8
   80a32:	d030      	beq.n	80a96 <local_usart_handler+0x8e>
		/* It is possible to initialise the peripheral to only use Tx and not Rx.
		Check that Rx has been initialised. */
		configASSERT(rx_buffer_definition->next_byte_to_read);
   80a34:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80a38:	4a41      	ldr	r2, [pc, #260]	; (80b40 <local_usart_handler+0x138>)
   80a3a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80a3e:	699b      	ldr	r3, [r3, #24]
   80a40:	2b00      	cmp	r3, #0
   80a42:	d04f      	beq.n	80ae4 <local_usart_handler+0xdc>
		configASSERT(rx_buffer_definition->next_byte_to_read !=
   80a44:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80a48:	4a3d      	ldr	r2, [pc, #244]	; (80b40 <local_usart_handler+0x138>)
   80a4a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80a4e:	699b      	ldr	r3, [r3, #24]
   80a50:	2b01      	cmp	r3, #1
   80a52:	d04d      	beq.n	80af0 <local_usart_handler+0xe8>
				RX_NOT_USED);

		/* Out of DMA buffer, configure the next buffer.  Start by moving
		the DMA buffer start address up to the end of the previously defined
		buffer. */
		rx_buffer_definition->rx_pdc_parameters.ul_addr +=
   80a54:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80a58:	4a39      	ldr	r2, [pc, #228]	; (80b40 <local_usart_handler+0x138>)
   80a5a:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80a5e:	689a      	ldr	r2, [r3, #8]
   80a60:	68d9      	ldr	r1, [r3, #12]
   80a62:	440a      	add	r2, r1
   80a64:	609a      	str	r2, [r3, #8]
				rx_buffer_definition->rx_pdc_parameters.ul_size;

		/* If the end of the buffer has been reached, wrap back to the start. */
		if (rx_buffer_definition->rx_pdc_parameters.ul_addr >=
   80a66:	685b      	ldr	r3, [r3, #4]
   80a68:	429a      	cmp	r2, r3
   80a6a:	d306      	bcc.n	80a7a <local_usart_handler+0x72>
				rx_buffer_definition->past_rx_buffer_end_address)
		{
			rx_buffer_definition->rx_pdc_parameters.ul_addr =
   80a6c:	4a34      	ldr	r2, [pc, #208]	; (80b40 <local_usart_handler+0x138>)
   80a6e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80a72:	009b      	lsls	r3, r3, #2
   80a74:	18d1      	adds	r1, r2, r3
   80a76:	58d3      	ldr	r3, [r2, r3]
   80a78:	608b      	str	r3, [r1, #8]
					rx_buffer_definition->rx_buffer_start_address;
		}

		/* Reset the Rx DMA to receive data into whatever free space remains in
		the Rx buffer. */
		configure_rx_dma(usart_index, data_added);
   80a7a:	2100      	movs	r1, #0
   80a7c:	4620      	mov	r0, r4
   80a7e:	4b31      	ldr	r3, [pc, #196]	; (80b44 <local_usart_handler+0x13c>)
   80a80:	4798      	blx	r3

		if (rx_buffer_definition->rx_event_semaphore != NULL) {
   80a82:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80a86:	4a2e      	ldr	r2, [pc, #184]	; (80b40 <local_usart_handler+0x138>)
   80a88:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80a8c:	6918      	ldr	r0, [r3, #16]
   80a8e:	b110      	cbz	r0, 80a96 <local_usart_handler+0x8e>
			/* Notify that new data is available. */
			xSemaphoreGiveFromISR(
   80a90:	a901      	add	r1, sp, #4
   80a92:	4b2d      	ldr	r3, [pc, #180]	; (80b48 <local_usart_handler+0x140>)
   80a94:	4798      	blx	r3
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & US_IER_TIMEOUT) != 0UL) {
   80a96:	f415 7f80 	tst.w	r5, #256	; 0x100
   80a9a:	d12f      	bne.n	80afc <local_usart_handler+0xf4>
					rx_buffer_definition->rx_event_semaphore,
					&higher_priority_task_woken);
		}
	}

	if ((usart_status & SR_ERROR_INTERRUPTS) != 0) {
   80a9c:	f015 0fe0 	tst.w	r5, #224	; 0xe0
   80aa0:	d13b      	bne.n	80b1a <local_usart_handler+0x112>
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
   80aa2:	9b01      	ldr	r3, [sp, #4]
   80aa4:	b13b      	cbz	r3, 80ab6 <local_usart_handler+0xae>
   80aa6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   80aaa:	4b28      	ldr	r3, [pc, #160]	; (80b4c <local_usart_handler+0x144>)
   80aac:	601a      	str	r2, [r3, #0]
   80aae:	f3bf 8f4f 	dsb	sy
   80ab2:	f3bf 8f6f 	isb	sy
}
   80ab6:	b002      	add	sp, #8
   80ab8:	bd70      	pop	{r4, r5, r6, pc}
		usart_disable_interrupt(
   80aba:	2110      	movs	r1, #16
   80abc:	4630      	mov	r0, r6
   80abe:	4b24      	ldr	r3, [pc, #144]	; (80b50 <local_usart_handler+0x148>)
   80ac0:	4798      	blx	r3
		if (tx_dma_control[usart_index].peripheral_access_sem != NULL) {
   80ac2:	4b24      	ldr	r3, [pc, #144]	; (80b54 <local_usart_handler+0x14c>)
   80ac4:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
   80ac8:	6858      	ldr	r0, [r3, #4]
   80aca:	b110      	cbz	r0, 80ad2 <local_usart_handler+0xca>
			xSemaphoreGiveFromISR(
   80acc:	a901      	add	r1, sp, #4
   80ace:	4b1e      	ldr	r3, [pc, #120]	; (80b48 <local_usart_handler+0x140>)
   80ad0:	4798      	blx	r3
		if (tx_dma_control[usart_index].transaction_complete_notification_semaphore != NULL) {
   80ad2:	4b20      	ldr	r3, [pc, #128]	; (80b54 <local_usart_handler+0x14c>)
   80ad4:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
   80ad8:	2800      	cmp	r0, #0
   80ada:	d0a8      	beq.n	80a2e <local_usart_handler+0x26>
			xSemaphoreGiveFromISR(
   80adc:	a901      	add	r1, sp, #4
   80ade:	4b1a      	ldr	r3, [pc, #104]	; (80b48 <local_usart_handler+0x140>)
   80ae0:	4798      	blx	r3
   80ae2:	e7a4      	b.n	80a2e <local_usart_handler+0x26>
		configASSERT(rx_buffer_definition->next_byte_to_read);
   80ae4:	f240 21d5 	movw	r1, #725	; 0x2d5
   80ae8:	481b      	ldr	r0, [pc, #108]	; (80b58 <local_usart_handler+0x150>)
   80aea:	4b1c      	ldr	r3, [pc, #112]	; (80b5c <local_usart_handler+0x154>)
   80aec:	4798      	blx	r3
   80aee:	e7a9      	b.n	80a44 <local_usart_handler+0x3c>
		configASSERT(rx_buffer_definition->next_byte_to_read !=
   80af0:	f240 21d7 	movw	r1, #727	; 0x2d7
   80af4:	4818      	ldr	r0, [pc, #96]	; (80b58 <local_usart_handler+0x150>)
   80af6:	4b19      	ldr	r3, [pc, #100]	; (80b5c <local_usart_handler+0x154>)
   80af8:	4798      	blx	r3
   80afa:	e7ab      	b.n	80a54 <local_usart_handler+0x4c>
		usart_start_rx_timeout(all_usart_definitions[usart_index].peripheral_base_address);
   80afc:	4630      	mov	r0, r6
   80afe:	4b18      	ldr	r3, [pc, #96]	; (80b60 <local_usart_handler+0x158>)
   80b00:	4798      	blx	r3
		if (rx_buffer_definition->rx_event_semaphore != NULL) {
   80b02:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80b06:	4a0e      	ldr	r2, [pc, #56]	; (80b40 <local_usart_handler+0x138>)
   80b08:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80b0c:	6918      	ldr	r0, [r3, #16]
   80b0e:	2800      	cmp	r0, #0
   80b10:	d0c4      	beq.n	80a9c <local_usart_handler+0x94>
			xSemaphoreGiveFromISR(
   80b12:	a901      	add	r1, sp, #4
   80b14:	4b0c      	ldr	r3, [pc, #48]	; (80b48 <local_usart_handler+0x140>)
   80b16:	4798      	blx	r3
   80b18:	e7c0      	b.n	80a9c <local_usart_handler+0x94>
		usart_reset_status(
   80b1a:	4630      	mov	r0, r6
   80b1c:	4b11      	ldr	r3, [pc, #68]	; (80b64 <local_usart_handler+0x15c>)
   80b1e:	4798      	blx	r3
		if (tx_dma_control[usart_index].peripheral_access_sem != NULL) {
   80b20:	4b0c      	ldr	r3, [pc, #48]	; (80b54 <local_usart_handler+0x14c>)
   80b22:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   80b26:	6860      	ldr	r0, [r4, #4]
   80b28:	2800      	cmp	r0, #0
   80b2a:	d0ba      	beq.n	80aa2 <local_usart_handler+0x9a>
			xSemaphoreGiveFromISR(
   80b2c:	a901      	add	r1, sp, #4
   80b2e:	4b06      	ldr	r3, [pc, #24]	; (80b48 <local_usart_handler+0x140>)
   80b30:	4798      	blx	r3
   80b32:	e7b6      	b.n	80aa2 <local_usart_handler+0x9a>
   80b34:	00085f28 	.word	0x00085f28
   80b38:	00083455 	.word	0x00083455
   80b3c:	00083451 	.word	0x00083451
   80b40:	2007075c 	.word	0x2007075c
   80b44:	00080919 	.word	0x00080919
   80b48:	000841d9 	.word	0x000841d9
   80b4c:	e000ed04 	.word	0xe000ed04
   80b50:	0008344d 	.word	0x0008344d
   80b54:	200707cc 	.word	0x200707cc
   80b58:	00085f68 	.word	0x00085f68
   80b5c:	00085861 	.word	0x00085861
   80b60:	00083461 	.word	0x00083461
   80b64:	00083459 	.word	0x00083459

00080b68 <freertos_usart_serial_init>:
{
   80b68:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   80b6c:	b082      	sub	sp, #8
   80b6e:	4605      	mov	r5, r0
   80b70:	4688      	mov	r8, r1
   80b72:	4616      	mov	r6, r2
	const enum peripheral_operation_mode valid_operating_modes[] = {USART_RS232};
   80b74:	af02      	add	r7, sp, #8
   80b76:	2300      	movs	r3, #0
   80b78:	f807 3d04 	strb.w	r3, [r7, #-4]!
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
   80b7c:	4602      	mov	r2, r0
   80b7e:	2104      	movs	r1, #4
   80b80:	485c      	ldr	r0, [pc, #368]	; (80cf4 <freertos_usart_serial_init+0x18c>)
   80b82:	4b5d      	ldr	r3, [pc, #372]	; (80cf8 <freertos_usart_serial_init+0x190>)
   80b84:	4798      	blx	r3
   80b86:	4604      	mov	r4, r0
	is_valid_operating_mode = check_requested_operating_mode(
   80b88:	2201      	movs	r2, #1
   80b8a:	4639      	mov	r1, r7
   80b8c:	7b30      	ldrb	r0, [r6, #12]
   80b8e:	4b5b      	ldr	r3, [pc, #364]	; (80cfc <freertos_usart_serial_init+0x194>)
   80b90:	4798      	blx	r3
	if ((usart_index < MAX_USARTS) && (is_valid_operating_mode == true)) {
   80b92:	2c03      	cmp	r4, #3
   80b94:	f300 80a9 	bgt.w	80cea <freertos_usart_serial_init+0x182>
   80b98:	2800      	cmp	r0, #0
   80b9a:	f000 80a8 	beq.w	80cee <freertos_usart_serial_init+0x186>
		configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read == NULL);
   80b9e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80ba2:	4a57      	ldr	r2, [pc, #348]	; (80d00 <freertos_usart_serial_init+0x198>)
   80ba4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80ba8:	699b      	ldr	r3, [r3, #24]
   80baa:	b11b      	cbz	r3, 80bb4 <freertos_usart_serial_init+0x4c>
   80bac:	21dd      	movs	r1, #221	; 0xdd
   80bae:	4855      	ldr	r0, [pc, #340]	; (80d04 <freertos_usart_serial_init+0x19c>)
   80bb0:	4b55      	ldr	r3, [pc, #340]	; (80d08 <freertos_usart_serial_init+0x1a0>)
   80bb2:	4798      	blx	r3
		usart_disable_tx(p_usart);
   80bb4:	4628      	mov	r0, r5
   80bb6:	4b55      	ldr	r3, [pc, #340]	; (80d0c <freertos_usart_serial_init+0x1a4>)
   80bb8:	4798      	blx	r3
		usart_disable_rx(p_usart);
   80bba:	4628      	mov	r0, r5
   80bbc:	4b54      	ldr	r3, [pc, #336]	; (80d10 <freertos_usart_serial_init+0x1a8>)
   80bbe:	4798      	blx	r3
		pdc_disable_transfer(all_usart_definitions[usart_index].pdc_base_address,
   80bc0:	4f4c      	ldr	r7, [pc, #304]	; (80cf4 <freertos_usart_serial_init+0x18c>)
   80bc2:	eb07 1704 	add.w	r7, r7, r4, lsl #4
   80bc6:	f8d7 9004 	ldr.w	r9, [r7, #4]
   80bca:	f240 2102 	movw	r1, #514	; 0x202
   80bce:	4648      	mov	r0, r9
   80bd0:	4b50      	ldr	r3, [pc, #320]	; (80d14 <freertos_usart_serial_init+0x1ac>)
   80bd2:	4798      	blx	r3
		pmc_enable_periph_clk(
   80bd4:	68b8      	ldr	r0, [r7, #8]
   80bd6:	4b50      	ldr	r3, [pc, #320]	; (80d18 <freertos_usart_serial_init+0x1b0>)
   80bd8:	4798      	blx	r3
		switch (freertos_driver_parameters->operation_mode) {
   80bda:	7b33      	ldrb	r3, [r6, #12]
   80bdc:	2b00      	cmp	r3, #0
   80bde:	d064      	beq.n	80caa <freertos_usart_serial_init+0x142>
		usart_disable_interrupt(p_usart, MASK_ALL_INTERRUPTS);
   80be0:	f04f 31ff 	mov.w	r1, #4294967295
   80be4:	4628      	mov	r0, r5
   80be6:	4b4d      	ldr	r3, [pc, #308]	; (80d1c <freertos_usart_serial_init+0x1b4>)
   80be8:	4798      	blx	r3
		create_peripheral_control_semaphores(
   80bea:	2200      	movs	r2, #0
   80bec:	494c      	ldr	r1, [pc, #304]	; (80d20 <freertos_usart_serial_init+0x1b8>)
   80bee:	eb01 01c4 	add.w	r1, r1, r4, lsl #3
   80bf2:	7b70      	ldrb	r0, [r6, #13]
   80bf4:	4b4b      	ldr	r3, [pc, #300]	; (80d24 <freertos_usart_serial_init+0x1bc>)
   80bf6:	4798      	blx	r3
		if (freertos_driver_parameters->receive_buffer != NULL) {
   80bf8:	6833      	ldr	r3, [r6, #0]
   80bfa:	2b00      	cmp	r3, #0
   80bfc:	d06d      	beq.n	80cda <freertos_usart_serial_init+0x172>
					xSemaphoreCreateCounting(portMAX_DELAY, 0);
   80bfe:	2100      	movs	r1, #0
   80c00:	f04f 30ff 	mov.w	r0, #4294967295
   80c04:	4b48      	ldr	r3, [pc, #288]	; (80d28 <freertos_usart_serial_init+0x1c0>)
   80c06:	4798      	blx	r3
			rx_buffer_definitions[usart_index].rx_event_semaphore =
   80c08:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80c0c:	4a3c      	ldr	r2, [pc, #240]	; (80d00 <freertos_usart_serial_init+0x198>)
   80c0e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80c12:	6118      	str	r0, [r3, #16]
			configASSERT(rx_buffer_definitions[usart_index].rx_event_semaphore);
   80c14:	2800      	cmp	r0, #0
   80c16:	d04e      	beq.n	80cb6 <freertos_usart_serial_init+0x14e>
			usart_set_rx_timeout(p_usart,
   80c18:	f8d8 1000 	ldr.w	r1, [r8]
   80c1c:	4b43      	ldr	r3, [pc, #268]	; (80d2c <freertos_usart_serial_init+0x1c4>)
   80c1e:	fba3 3101 	umull	r3, r1, r3, r1
   80c22:	0989      	lsrs	r1, r1, #6
   80c24:	4628      	mov	r0, r5
   80c26:	4b42      	ldr	r3, [pc, #264]	; (80d30 <freertos_usart_serial_init+0x1c8>)
   80c28:	4798      	blx	r3
			usart_start_rx_timeout(p_usart);
   80c2a:	4628      	mov	r0, r5
   80c2c:	4b41      	ldr	r3, [pc, #260]	; (80d34 <freertos_usart_serial_init+0x1cc>)
   80c2e:	4798      	blx	r3
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr =
   80c30:	f8df a0cc 	ldr.w	sl, [pc, #204]	; 80d00 <freertos_usart_serial_init+0x198>
   80c34:	ebc4 08c4 	rsb	r8, r4, r4, lsl #3
   80c38:	ea4f 0888 	mov.w	r8, r8, lsl #2
   80c3c:	eb0a 0708 	add.w	r7, sl, r8
   80c40:	6833      	ldr	r3, [r6, #0]
   80c42:	60bb      	str	r3, [r7, #8]
					freertos_driver_parameters->receive_buffer_size;
   80c44:	6873      	ldr	r3, [r6, #4]
			rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size =
   80c46:	60fb      	str	r3, [r7, #12]
			pdc_rx_init(
   80c48:	4639      	mov	r1, r7
   80c4a:	2200      	movs	r2, #0
   80c4c:	3108      	adds	r1, #8
   80c4e:	4648      	mov	r0, r9
   80c50:	4b39      	ldr	r3, [pc, #228]	; (80d38 <freertos_usart_serial_init+0x1d0>)
   80c52:	4798      	blx	r3
					freertos_driver_parameters->receive_buffer;
   80c54:	6833      	ldr	r3, [r6, #0]
			rx_buffer_definitions[usart_index].next_byte_to_read =
   80c56:	61bb      	str	r3, [r7, #24]
					rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_addr;
   80c58:	68ba      	ldr	r2, [r7, #8]
			rx_buffer_definitions[usart_index].rx_buffer_start_address =
   80c5a:	f84a 2008 	str.w	r2, [sl, r8]
					rx_buffer_definitions[usart_index].rx_buffer_start_address +
   80c5e:	6873      	ldr	r3, [r6, #4]
   80c60:	4413      	add	r3, r2
			rx_buffer_definitions[usart_index].past_rx_buffer_end_address =
   80c62:	607b      	str	r3, [r7, #4]
			if ((freertos_driver_parameters->options_flags &
   80c64:	7b73      	ldrb	r3, [r6, #13]
   80c66:	f013 0f02 	tst.w	r3, #2
   80c6a:	d12a      	bne.n	80cc2 <freertos_usart_serial_init+0x15a>
			usart_enable_interrupt(p_usart, US_IER_ENDRX | US_IER_TIMEOUT);
   80c6c:	f44f 7184 	mov.w	r1, #264	; 0x108
   80c70:	4628      	mov	r0, r5
   80c72:	4b32      	ldr	r3, [pc, #200]	; (80d3c <freertos_usart_serial_init+0x1d4>)
   80c74:	4798      	blx	r3
			pdc_enable_transfer(
   80c76:	2101      	movs	r1, #1
   80c78:	4648      	mov	r0, r9
   80c7a:	4b31      	ldr	r3, [pc, #196]	; (80d40 <freertos_usart_serial_init+0x1d8>)
   80c7c:	4798      	blx	r3
		configure_interrupt_controller(all_usart_definitions[usart_index].peripheral_irq,
   80c7e:	4f1d      	ldr	r7, [pc, #116]	; (80cf4 <freertos_usart_serial_init+0x18c>)
   80c80:	0124      	lsls	r4, r4, #4
   80c82:	193b      	adds	r3, r7, r4
   80c84:	68b1      	ldr	r1, [r6, #8]
   80c86:	f993 000c 	ldrsb.w	r0, [r3, #12]
   80c8a:	4b2e      	ldr	r3, [pc, #184]	; (80d44 <freertos_usart_serial_init+0x1dc>)
   80c8c:	4798      	blx	r3
		usart_enable_interrupt(
   80c8e:	21e0      	movs	r1, #224	; 0xe0
   80c90:	5938      	ldr	r0, [r7, r4]
   80c92:	4b2a      	ldr	r3, [pc, #168]	; (80d3c <freertos_usart_serial_init+0x1d4>)
   80c94:	4798      	blx	r3
		usart_enable_tx(p_usart);
   80c96:	4628      	mov	r0, r5
   80c98:	4b2b      	ldr	r3, [pc, #172]	; (80d48 <freertos_usart_serial_init+0x1e0>)
   80c9a:	4798      	blx	r3
		usart_enable_rx(p_usart);
   80c9c:	4628      	mov	r0, r5
   80c9e:	4b2b      	ldr	r3, [pc, #172]	; (80d4c <freertos_usart_serial_init+0x1e4>)
   80ca0:	4798      	blx	r3
		return_value = (freertos_usart_if) p_usart;
   80ca2:	4628      	mov	r0, r5
}
   80ca4:	b002      	add	sp, #8
   80ca6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			usart_init_rs232(p_usart, uart_parameters,
   80caa:	4a29      	ldr	r2, [pc, #164]	; (80d50 <freertos_usart_serial_init+0x1e8>)
   80cac:	4641      	mov	r1, r8
   80cae:	4628      	mov	r0, r5
   80cb0:	4b28      	ldr	r3, [pc, #160]	; (80d54 <freertos_usart_serial_init+0x1ec>)
   80cb2:	4798      	blx	r3
			break;
   80cb4:	e794      	b.n	80be0 <freertos_usart_serial_init+0x78>
			configASSERT(rx_buffer_definitions[usart_index].rx_event_semaphore);
   80cb6:	f44f 718d 	mov.w	r1, #282	; 0x11a
   80cba:	4812      	ldr	r0, [pc, #72]	; (80d04 <freertos_usart_serial_init+0x19c>)
   80cbc:	4b12      	ldr	r3, [pc, #72]	; (80d08 <freertos_usart_serial_init+0x1a0>)
   80cbe:	4798      	blx	r3
   80cc0:	e7aa      	b.n	80c18 <freertos_usart_serial_init+0xb0>
					xSemaphoreCreateMutex();
   80cc2:	2001      	movs	r0, #1
   80cc4:	4b24      	ldr	r3, [pc, #144]	; (80d58 <freertos_usart_serial_init+0x1f0>)
   80cc6:	4798      	blx	r3
				rx_buffer_definitions[usart_index].rx_access_mutex =
   80cc8:	6178      	str	r0, [r7, #20]
				configASSERT(rx_buffer_definitions[usart_index].rx_access_mutex);
   80cca:	2800      	cmp	r0, #0
   80ccc:	d1ce      	bne.n	80c6c <freertos_usart_serial_init+0x104>
   80cce:	f44f 71a0 	mov.w	r1, #320	; 0x140
   80cd2:	480c      	ldr	r0, [pc, #48]	; (80d04 <freertos_usart_serial_init+0x19c>)
   80cd4:	4b0c      	ldr	r3, [pc, #48]	; (80d08 <freertos_usart_serial_init+0x1a0>)
   80cd6:	4798      	blx	r3
   80cd8:	e7c8      	b.n	80c6c <freertos_usart_serial_init+0x104>
			rx_buffer_definitions[usart_index].next_byte_to_read = RX_NOT_USED;
   80cda:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80cde:	4a08      	ldr	r2, [pc, #32]	; (80d00 <freertos_usart_serial_init+0x198>)
   80ce0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80ce4:	2201      	movs	r2, #1
   80ce6:	619a      	str	r2, [r3, #24]
   80ce8:	e7c9      	b.n	80c7e <freertos_usart_serial_init+0x116>
		return_value = NULL;
   80cea:	2000      	movs	r0, #0
   80cec:	e7da      	b.n	80ca4 <freertos_usart_serial_init+0x13c>
   80cee:	2000      	movs	r0, #0
	return return_value;
   80cf0:	e7d8      	b.n	80ca4 <freertos_usart_serial_init+0x13c>
   80cf2:	bf00      	nop
   80cf4:	00085f28 	.word	0x00085f28
   80cf8:	000801c5 	.word	0x000801c5
   80cfc:	000801ef 	.word	0x000801ef
   80d00:	2007075c 	.word	0x2007075c
   80d04:	00085f68 	.word	0x00085f68
   80d08:	00085861 	.word	0x00085861
   80d0c:	00083433 	.word	0x00083433
   80d10:	0008343f 	.word	0x0008343f
   80d14:	00081d19 	.word	0x00081d19
   80d18:	00082021 	.word	0x00082021
   80d1c:	0008344d 	.word	0x0008344d
   80d20:	200707cc 	.word	0x200707cc
   80d24:	00080225 	.word	0x00080225
   80d28:	00083eed 	.word	0x00083eed
   80d2c:	51eb851f 	.word	0x51eb851f
   80d30:	00083445 	.word	0x00083445
   80d34:	00083461 	.word	0x00083461
   80d38:	00081cf5 	.word	0x00081cf5
   80d3c:	00083449 	.word	0x00083449
   80d40:	00081d0d 	.word	0x00081d0d
   80d44:	000802f9 	.word	0x000802f9
   80d48:	0008342d 	.word	0x0008342d
   80d4c:	00083439 	.word	0x00083439
   80d50:	0501bd00 	.word	0x0501bd00
   80d54:	000833d9 	.word	0x000833d9
   80d58:	000840dd 	.word	0x000840dd

00080d5c <freertos_usart_write_packet_async>:
{
   80d5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   80d60:	b084      	sub	sp, #16
   80d62:	4605      	mov	r5, r0
   80d64:	460e      	mov	r6, r1
   80d66:	4617      	mov	r7, r2
   80d68:	9303      	str	r3, [sp, #12]
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
   80d6a:	4602      	mov	r2, r0
   80d6c:	2104      	movs	r1, #4
   80d6e:	4817      	ldr	r0, [pc, #92]	; (80dcc <freertos_usart_write_packet_async+0x70>)
   80d70:	4b17      	ldr	r3, [pc, #92]	; (80dd0 <freertos_usart_write_packet_async+0x74>)
   80d72:	4798      	blx	r3
	if (usart_index < MAX_USARTS) {
   80d74:	2803      	cmp	r0, #3
   80d76:	dc26      	bgt.n	80dc6 <freertos_usart_write_packet_async+0x6a>
   80d78:	4680      	mov	r8, r0
		return_value = freertos_obtain_peripheral_access_semphore(
   80d7a:	4c16      	ldr	r4, [pc, #88]	; (80dd4 <freertos_usart_write_packet_async+0x78>)
   80d7c:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
   80d80:	a903      	add	r1, sp, #12
   80d82:	4620      	mov	r0, r4
   80d84:	4b14      	ldr	r3, [pc, #80]	; (80dd8 <freertos_usart_write_packet_async+0x7c>)
   80d86:	4798      	blx	r3
		if (return_value == STATUS_OK) {
   80d88:	4603      	mov	r3, r0
   80d8a:	b118      	cbz	r0, 80d94 <freertos_usart_write_packet_async+0x38>
}
   80d8c:	4618      	mov	r0, r3
   80d8e:	b004      	add	sp, #16
   80d90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			freertos_start_pdc_tx(&(tx_dma_control[usart_index]),
   80d94:	4b0d      	ldr	r3, [pc, #52]	; (80dcc <freertos_usart_write_packet_async+0x70>)
   80d96:	eb03 1808 	add.w	r8, r3, r8, lsl #4
   80d9a:	f8d8 3004 	ldr.w	r3, [r8, #4]
   80d9e:	2201      	movs	r2, #1
   80da0:	9201      	str	r2, [sp, #4]
   80da2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
   80da4:	9200      	str	r2, [sp, #0]
   80da6:	463a      	mov	r2, r7
   80da8:	4631      	mov	r1, r6
   80daa:	4620      	mov	r0, r4
   80dac:	4e0b      	ldr	r6, [pc, #44]	; (80ddc <freertos_usart_write_packet_async+0x80>)
   80dae:	47b0      	blx	r6
			usart_enable_interrupt(usart_base, US_IER_ENDTX);
   80db0:	2110      	movs	r1, #16
   80db2:	4628      	mov	r0, r5
   80db4:	4b0a      	ldr	r3, [pc, #40]	; (80de0 <freertos_usart_write_packet_async+0x84>)
   80db6:	4798      	blx	r3
			return_value = freertos_optionally_wait_transfer_completion(
   80db8:	9a03      	ldr	r2, [sp, #12]
   80dba:	990a      	ldr	r1, [sp, #40]	; 0x28
   80dbc:	4620      	mov	r0, r4
   80dbe:	4b09      	ldr	r3, [pc, #36]	; (80de4 <freertos_usart_write_packet_async+0x88>)
   80dc0:	4798      	blx	r3
   80dc2:	4603      	mov	r3, r0
   80dc4:	e7e2      	b.n	80d8c <freertos_usart_write_packet_async+0x30>
		return_value = ERR_INVALID_ARG;
   80dc6:	f06f 0307 	mvn.w	r3, #7
   80dca:	e7df      	b.n	80d8c <freertos_usart_write_packet_async+0x30>
   80dcc:	00085f28 	.word	0x00085f28
   80dd0:	000801c5 	.word	0x000801c5
   80dd4:	200707cc 	.word	0x200707cc
   80dd8:	000803e1 	.word	0x000803e1
   80ddc:	0008042d 	.word	0x0008042d
   80de0:	00083449 	.word	0x00083449
   80de4:	000804a9 	.word	0x000804a9

00080de8 <freertos_usart_serial_read_packet>:
{
   80de8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   80dec:	b087      	sub	sp, #28
   80dee:	460f      	mov	r7, r1
   80df0:	4616      	mov	r6, r2
   80df2:	9303      	str	r3, [sp, #12]
	usart_index = get_pdc_peripheral_details(all_usart_definitions,
   80df4:	4602      	mov	r2, r0
   80df6:	2104      	movs	r1, #4
   80df8:	484b      	ldr	r0, [pc, #300]	; (80f28 <freertos_usart_serial_read_packet+0x140>)
   80dfa:	4b4c      	ldr	r3, [pc, #304]	; (80f2c <freertos_usart_serial_read_packet+0x144>)
   80dfc:	4798      	blx	r3
   80dfe:	4604      	mov	r4, r0
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read);
   80e00:	ebc0 02c0 	rsb	r2, r0, r0, lsl #3
   80e04:	4b4a      	ldr	r3, [pc, #296]	; (80f30 <freertos_usart_serial_read_packet+0x148>)
   80e06:	eb03 0382 	add.w	r3, r3, r2, lsl #2
   80e0a:	699b      	ldr	r3, [r3, #24]
   80e0c:	b1ab      	cbz	r3, 80e3a <freertos_usart_serial_read_packet+0x52>
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read !=
   80e0e:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80e12:	4a47      	ldr	r2, [pc, #284]	; (80f30 <freertos_usart_serial_read_packet+0x148>)
   80e14:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80e18:	699b      	ldr	r3, [r3, #24]
   80e1a:	2b01      	cmp	r3, #1
   80e1c:	d013      	beq.n	80e46 <freertos_usart_serial_read_packet+0x5e>
	if (usart_index < MAX_USARTS) {
   80e1e:	2c03      	cmp	r4, #3
   80e20:	dc7c      	bgt.n	80f1c <freertos_usart_serial_read_packet+0x134>
				(rx_buffer_definitions[usart_index].past_rx_buffer_end_address
   80e22:	4943      	ldr	r1, [pc, #268]	; (80f30 <freertos_usart_serial_read_packet+0x148>)
   80e24:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80e28:	009b      	lsls	r3, r3, #2
   80e2a:	18ca      	adds	r2, r1, r3
				- rx_buffer_definitions[usart_index].rx_buffer_start_address)) {
   80e2c:	6852      	ldr	r2, [r2, #4]
   80e2e:	58cb      	ldr	r3, [r1, r3]
   80e30:	1ad3      	subs	r3, r2, r3
		if (len <=
   80e32:	42b3      	cmp	r3, r6
   80e34:	d20d      	bcs.n	80e52 <freertos_usart_serial_read_packet+0x6a>
	uint32_t bytes_read = 0;
   80e36:	2500      	movs	r5, #0
	return bytes_read;
   80e38:	e071      	b.n	80f1e <freertos_usart_serial_read_packet+0x136>
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read);
   80e3a:	f240 2116 	movw	r1, #534	; 0x216
   80e3e:	483d      	ldr	r0, [pc, #244]	; (80f34 <freertos_usart_serial_read_packet+0x14c>)
   80e40:	4b3d      	ldr	r3, [pc, #244]	; (80f38 <freertos_usart_serial_read_packet+0x150>)
   80e42:	4798      	blx	r3
   80e44:	e7e3      	b.n	80e0e <freertos_usart_serial_read_packet+0x26>
	configASSERT(rx_buffer_definitions[usart_index].next_byte_to_read !=
   80e46:	f44f 7106 	mov.w	r1, #536	; 0x218
   80e4a:	483a      	ldr	r0, [pc, #232]	; (80f34 <freertos_usart_serial_read_packet+0x14c>)
   80e4c:	4b3a      	ldr	r3, [pc, #232]	; (80f38 <freertos_usart_serial_read_packet+0x150>)
   80e4e:	4798      	blx	r3
   80e50:	e7e5      	b.n	80e1e <freertos_usart_serial_read_packet+0x36>
			vTaskSetTimeOutState(&time_out_definition);
   80e52:	a804      	add	r0, sp, #16
   80e54:	4b39      	ldr	r3, [pc, #228]	; (80f3c <freertos_usart_serial_read_packet+0x154>)
   80e56:	4798      	blx	r3
			if (rx_buffer_definitions[usart_index].rx_access_mutex != NULL) {
   80e58:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80e5c:	4a34      	ldr	r2, [pc, #208]	; (80f30 <freertos_usart_serial_read_packet+0x148>)
   80e5e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80e62:	6958      	ldr	r0, [r3, #20]
   80e64:	b160      	cbz	r0, 80e80 <freertos_usart_serial_read_packet+0x98>
				attempt_read = xSemaphoreTake(
   80e66:	9903      	ldr	r1, [sp, #12]
   80e68:	4b35      	ldr	r3, [pc, #212]	; (80f40 <freertos_usart_serial_read_packet+0x158>)
   80e6a:	4798      	blx	r3
				if (attempt_read == pdTRUE) {
   80e6c:	2801      	cmp	r0, #1
   80e6e:	d001      	beq.n	80e74 <freertos_usart_serial_read_packet+0x8c>
	uint32_t bytes_read = 0;
   80e70:	2500      	movs	r5, #0
   80e72:	e054      	b.n	80f1e <freertos_usart_serial_read_packet+0x136>
					if (xTaskCheckForTimeOut(&time_out_definition,
   80e74:	a903      	add	r1, sp, #12
   80e76:	a804      	add	r0, sp, #16
   80e78:	4b32      	ldr	r3, [pc, #200]	; (80f44 <freertos_usart_serial_read_packet+0x15c>)
   80e7a:	4798      	blx	r3
   80e7c:	2801      	cmp	r0, #1
   80e7e:	d013      	beq.n	80ea8 <freertos_usart_serial_read_packet+0xc0>
   80e80:	9402      	str	r4, [sp, #8]
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
   80e82:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
   80e86:	4a2a      	ldr	r2, [pc, #168]	; (80f30 <freertos_usart_serial_read_packet+0x148>)
   80e88:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   80e8c:	9301      	str	r3, [sp, #4]
   80e8e:	2500      	movs	r5, #0
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
   80e90:	ebc4 08c4 	rsb	r8, r4, r4, lsl #3
   80e94:	eb02 0888 	add.w	r8, r2, r8, lsl #2
   80e98:	f8df b0a4 	ldr.w	fp, [pc, #164]	; 80f40 <freertos_usart_serial_read_packet+0x158>
							all_usart_definitions[usart_index].pdc_base_address->PERIPH_RPR,
   80e9c:	4b22      	ldr	r3, [pc, #136]	; (80f28 <freertos_usart_serial_read_packet+0x140>)
   80e9e:	eb03 1904 	add.w	r9, r3, r4, lsl #4
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
   80ea2:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 80f58 <freertos_usart_serial_read_packet+0x170>
   80ea6:	e014      	b.n	80ed2 <freertos_usart_serial_read_packet+0xea>
						xSemaphoreGive(rx_buffer_definitions[usart_index].rx_access_mutex);
   80ea8:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   80eac:	4820      	ldr	r0, [pc, #128]	; (80f30 <freertos_usart_serial_read_packet+0x148>)
   80eae:	eb00 0084 	add.w	r0, r0, r4, lsl #2
   80eb2:	2300      	movs	r3, #0
   80eb4:	461a      	mov	r2, r3
   80eb6:	4619      	mov	r1, r3
   80eb8:	6940      	ldr	r0, [r0, #20]
   80eba:	4c23      	ldr	r4, [pc, #140]	; (80f48 <freertos_usart_serial_read_packet+0x160>)
   80ebc:	47a0      	blx	r4
   80ebe:	e7d7      	b.n	80e70 <freertos_usart_serial_read_packet+0x88>
						taskEXIT_CRITICAL();
   80ec0:	4b22      	ldr	r3, [pc, #136]	; (80f4c <freertos_usart_serial_read_packet+0x164>)
   80ec2:	4798      	blx	r3
						&block_time_ticks) == pdFALSE));
   80ec4:	42ae      	cmp	r6, r5
   80ec6:	d91c      	bls.n	80f02 <freertos_usart_serial_read_packet+0x11a>
				} while ((bytes_read < len) && (xTaskCheckForTimeOut(
   80ec8:	a903      	add	r1, sp, #12
   80eca:	a804      	add	r0, sp, #16
   80ecc:	4b1d      	ldr	r3, [pc, #116]	; (80f44 <freertos_usart_serial_read_packet+0x15c>)
   80ece:	4798      	blx	r3
   80ed0:	b9b8      	cbnz	r0, 80f02 <freertos_usart_serial_read_packet+0x11a>
					xSemaphoreTake(rx_buffer_definitions[usart_index].rx_event_semaphore,
   80ed2:	9903      	ldr	r1, [sp, #12]
   80ed4:	f8d8 0010 	ldr.w	r0, [r8, #16]
   80ed8:	47d8      	blx	fp
							all_usart_definitions[usart_index].pdc_base_address->PERIPH_RPR,
   80eda:	f8d9 3004 	ldr.w	r3, [r9, #4]
					bytes_read += freertos_copy_bytes_from_pdc_circular_buffer(
   80ede:	6819      	ldr	r1, [r3, #0]
   80ee0:	1b73      	subs	r3, r6, r5
   80ee2:	197a      	adds	r2, r7, r5
   80ee4:	9801      	ldr	r0, [sp, #4]
   80ee6:	47d0      	blx	sl
					if (bytes_read > 0) {
   80ee8:	182d      	adds	r5, r5, r0
   80eea:	d0eb      	beq.n	80ec4 <freertos_usart_serial_read_packet+0xdc>
						taskENTER_CRITICAL();
   80eec:	4b18      	ldr	r3, [pc, #96]	; (80f50 <freertos_usart_serial_read_packet+0x168>)
   80eee:	4798      	blx	r3
							if(rx_buffer_definitions[usart_index].rx_pdc_parameters.ul_size == 0UL) {
   80ef0:	f8d8 300c 	ldr.w	r3, [r8, #12]
   80ef4:	2b00      	cmp	r3, #0
   80ef6:	d1e3      	bne.n	80ec0 <freertos_usart_serial_read_packet+0xd8>
								configure_rx_dma(usart_index, data_removed);
   80ef8:	2101      	movs	r1, #1
   80efa:	9802      	ldr	r0, [sp, #8]
   80efc:	4b15      	ldr	r3, [pc, #84]	; (80f54 <freertos_usart_serial_read_packet+0x16c>)
   80efe:	4798      	blx	r3
   80f00:	e7de      	b.n	80ec0 <freertos_usart_serial_read_packet+0xd8>
				if (rx_buffer_definitions[usart_index].rx_access_mutex != NULL) {
   80f02:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
   80f06:	4b0a      	ldr	r3, [pc, #40]	; (80f30 <freertos_usart_serial_read_packet+0x148>)
   80f08:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   80f0c:	6960      	ldr	r0, [r4, #20]
   80f0e:	b130      	cbz	r0, 80f1e <freertos_usart_serial_read_packet+0x136>
					xSemaphoreGive(rx_buffer_definitions[usart_index].rx_access_mutex);
   80f10:	2300      	movs	r3, #0
   80f12:	461a      	mov	r2, r3
   80f14:	4619      	mov	r1, r3
   80f16:	4c0c      	ldr	r4, [pc, #48]	; (80f48 <freertos_usart_serial_read_packet+0x160>)
   80f18:	47a0      	blx	r4
   80f1a:	e000      	b.n	80f1e <freertos_usart_serial_read_packet+0x136>
	uint32_t bytes_read = 0;
   80f1c:	2500      	movs	r5, #0
}
   80f1e:	4628      	mov	r0, r5
   80f20:	b007      	add	sp, #28
   80f22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   80f26:	bf00      	nop
   80f28:	00085f28 	.word	0x00085f28
   80f2c:	000801c5 	.word	0x000801c5
   80f30:	2007075c 	.word	0x2007075c
   80f34:	00085f68 	.word	0x00085f68
   80f38:	00085861 	.word	0x00085861
   80f3c:	00084f45 	.word	0x00084f45
   80f40:	00084411 	.word	0x00084411
   80f44:	00084f9d 	.word	0x00084f9d
   80f48:	00083f31 	.word	0x00083f31
   80f4c:	00083a0d 	.word	0x00083a0d
   80f50:	000839c5 	.word	0x000839c5
   80f54:	00080919 	.word	0x00080919
   80f58:	00080361 	.word	0x00080361

00080f5c <USART0_Handler>:
#endif /* USART */

#ifdef USART0

void USART0_Handler(void)
{
   80f5c:	b508      	push	{r3, lr}
	local_usart_handler(0);
   80f5e:	2000      	movs	r0, #0
   80f60:	4b01      	ldr	r3, [pc, #4]	; (80f68 <USART0_Handler+0xc>)
   80f62:	4798      	blx	r3
   80f64:	bd08      	pop	{r3, pc}
   80f66:	bf00      	nop
   80f68:	00080a09 	.word	0x00080a09

00080f6c <USART1_Handler>:
#endif /* USART0 */

#ifdef USART1

void USART1_Handler(void)
{
   80f6c:	b508      	push	{r3, lr}
	local_usart_handler(1);
   80f6e:	2001      	movs	r0, #1
   80f70:	4b01      	ldr	r3, [pc, #4]	; (80f78 <USART1_Handler+0xc>)
   80f72:	4798      	blx	r3
   80f74:	bd08      	pop	{r3, pc}
   80f76:	bf00      	nop
   80f78:	00080a09 	.word	0x00080a09

00080f7c <USART2_Handler>:
#endif /* USART1 */

#ifdef USART2

void USART2_Handler(void)
{
   80f7c:	b508      	push	{r3, lr}
	local_usart_handler(2);
   80f7e:	2002      	movs	r0, #2
   80f80:	4b01      	ldr	r3, [pc, #4]	; (80f88 <USART2_Handler+0xc>)
   80f82:	4798      	blx	r3
   80f84:	bd08      	pop	{r3, pc}
   80f86:	bf00      	nop
   80f88:	00080a09 	.word	0x00080a09

00080f8c <USART3_Handler>:
#endif /* USART2 */

#ifdef USART3

void USART3_Handler(void)
{
   80f8c:	b508      	push	{r3, lr}
	local_usart_handler(3);
   80f8e:	2003      	movs	r0, #3
   80f90:	4b01      	ldr	r3, [pc, #4]	; (80f98 <USART3_Handler+0xc>)
   80f92:	4798      	blx	r3
   80f94:	bd08      	pop	{r3, pc}
   80f96:	bf00      	nop
   80f98:	00080a09 	.word	0x00080a09

00080f9c <udi_cdc_comm_disable>:
}

void udi_cdc_comm_disable(void)
{
	Assert(udi_cdc_nb_comm_enabled != 0);
	udi_cdc_nb_comm_enabled--;
   80f9c:	4a02      	ldr	r2, [pc, #8]	; (80fa8 <udi_cdc_comm_disable+0xc>)
   80f9e:	7813      	ldrb	r3, [r2, #0]
   80fa0:	3b01      	subs	r3, #1
   80fa2:	b2db      	uxtb	r3, r3
   80fa4:	7013      	strb	r3, [r2, #0]
   80fa6:	4770      	bx	lr
   80fa8:	200707f7 	.word	0x200707f7

00080fac <udi_cdc_data_setup>:
}

bool udi_cdc_data_setup(void)
{
	return false;  // request Not supported
}
   80fac:	2000      	movs	r0, #0
   80fae:	4770      	bx	lr

00080fb0 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
	return 0;      // CDC don't have multiple alternate setting
}
   80fb0:	2000      	movs	r0, #0
   80fb2:	4770      	bx	lr

00080fb4 <udi_cdc_comm_setup>:
	if (Udd_setup_is_in()) {
   80fb4:	4b1d      	ldr	r3, [pc, #116]	; (8102c <udi_cdc_comm_setup+0x78>)
   80fb6:	781b      	ldrb	r3, [r3, #0]
   80fb8:	f013 0f80 	tst.w	r3, #128	; 0x80
   80fbc:	d105      	bne.n	80fca <udi_cdc_comm_setup+0x16>
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
   80fbe:	f003 0360 	and.w	r3, r3, #96	; 0x60
   80fc2:	2b20      	cmp	r3, #32
   80fc4:	d018      	beq.n	80ff8 <udi_cdc_comm_setup+0x44>
	return false;  // request Not supported
   80fc6:	2000      	movs	r0, #0
   80fc8:	4770      	bx	lr
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
   80fca:	f003 0360 	and.w	r3, r3, #96	; 0x60
   80fce:	2b20      	cmp	r3, #32
   80fd0:	d001      	beq.n	80fd6 <udi_cdc_comm_setup+0x22>
	return false;  // request Not supported
   80fd2:	2000      	movs	r0, #0
   80fd4:	4770      	bx	lr
			switch (udd_g_ctrlreq.req.bRequest) {
   80fd6:	4b15      	ldr	r3, [pc, #84]	; (8102c <udi_cdc_comm_setup+0x78>)
   80fd8:	785b      	ldrb	r3, [r3, #1]
   80fda:	2b21      	cmp	r3, #33	; 0x21
   80fdc:	d124      	bne.n	81028 <udi_cdc_comm_setup+0x74>
						udd_g_ctrlreq.req.wLength)
   80fde:	4b13      	ldr	r3, [pc, #76]	; (8102c <udi_cdc_comm_setup+0x78>)
				if (sizeof(usb_cdc_line_coding_t) !=
   80fe0:	88db      	ldrh	r3, [r3, #6]
   80fe2:	2b07      	cmp	r3, #7
   80fe4:	d001      	beq.n	80fea <udi_cdc_comm_setup+0x36>
					return false; // Error for USB host
   80fe6:	2000      	movs	r0, #0
   80fe8:	4770      	bx	lr
				udd_g_ctrlreq.payload =
   80fea:	4b10      	ldr	r3, [pc, #64]	; (8102c <udi_cdc_comm_setup+0x78>)
   80fec:	4a10      	ldr	r2, [pc, #64]	; (81030 <udi_cdc_comm_setup+0x7c>)
   80fee:	609a      	str	r2, [r3, #8]
				udd_g_ctrlreq.payload_size =
   80ff0:	2207      	movs	r2, #7
   80ff2:	819a      	strh	r2, [r3, #12]
				return true;
   80ff4:	2001      	movs	r0, #1
   80ff6:	4770      	bx	lr
			switch (udd_g_ctrlreq.req.bRequest) {
   80ff8:	4b0c      	ldr	r3, [pc, #48]	; (8102c <udi_cdc_comm_setup+0x78>)
   80ffa:	7858      	ldrb	r0, [r3, #1]
   80ffc:	2820      	cmp	r0, #32
   80ffe:	d004      	beq.n	8100a <udi_cdc_comm_setup+0x56>
	return false;  // request Not supported
   81000:	2822      	cmp	r0, #34	; 0x22
   81002:	bf14      	ite	ne
   81004:	2000      	movne	r0, #0
   81006:	2001      	moveq	r0, #1
   81008:	4770      	bx	lr
						udd_g_ctrlreq.req.wLength)
   8100a:	4b08      	ldr	r3, [pc, #32]	; (8102c <udi_cdc_comm_setup+0x78>)
				if (sizeof(usb_cdc_line_coding_t) !=
   8100c:	88db      	ldrh	r3, [r3, #6]
   8100e:	2b07      	cmp	r3, #7
   81010:	d001      	beq.n	81016 <udi_cdc_comm_setup+0x62>
					return false; // Error for USB host
   81012:	2000      	movs	r0, #0
}
   81014:	4770      	bx	lr
				udd_g_ctrlreq.callback =
   81016:	4b05      	ldr	r3, [pc, #20]	; (8102c <udi_cdc_comm_setup+0x78>)
   81018:	4a06      	ldr	r2, [pc, #24]	; (81034 <udi_cdc_comm_setup+0x80>)
   8101a:	611a      	str	r2, [r3, #16]
				udd_g_ctrlreq.payload =
   8101c:	4a04      	ldr	r2, [pc, #16]	; (81030 <udi_cdc_comm_setup+0x7c>)
   8101e:	609a      	str	r2, [r3, #8]
				udd_g_ctrlreq.payload_size =
   81020:	2207      	movs	r2, #7
   81022:	819a      	strh	r2, [r3, #12]
				return true;
   81024:	2001      	movs	r0, #1
   81026:	4770      	bx	lr
	return false;  // request Not supported
   81028:	2000      	movs	r0, #0
   8102a:	4770      	bx	lr
   8102c:	20075364 	.word	0x20075364
   81030:	200707f0 	.word	0x200707f0
   81034:	00081039 	.word	0x00081039

00081038 <udi_cdc_line_coding_received>:
	}
	return port;
}

static void udi_cdc_line_coding_received(void)
{
   81038:	4770      	bx	lr
	...

0008103c <udi_cdc_comm_enable>:
{
   8103c:	b508      	push	{r3, lr}
	udi_cdc_nb_comm_enabled = 0;
   8103e:	2000      	movs	r0, #0
   81040:	4b10      	ldr	r3, [pc, #64]	; (81084 <udi_cdc_comm_enable+0x48>)
   81042:	7018      	strb	r0, [r3, #0]
	udi_cdc_state[port] = CPU_TO_LE16(0);
   81044:	4b10      	ldr	r3, [pc, #64]	; (81088 <udi_cdc_comm_enable+0x4c>)
   81046:	8018      	strh	r0, [r3, #0]
	uid_cdc_state_msg[port].header.bmRequestType =
   81048:	4b10      	ldr	r3, [pc, #64]	; (8108c <udi_cdc_comm_enable+0x50>)
   8104a:	22a1      	movs	r2, #161	; 0xa1
   8104c:	701a      	strb	r2, [r3, #0]
	uid_cdc_state_msg[port].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE;
   8104e:	2220      	movs	r2, #32
   81050:	705a      	strb	r2, [r3, #1]
	uid_cdc_state_msg[port].header.wValue = LE16(0);
   81052:	8058      	strh	r0, [r3, #2]
	uid_cdc_state_msg[port].header.wIndex = LE16(iface_comm_num);
   81054:	8098      	strh	r0, [r3, #4]
	uid_cdc_state_msg[port].header.wLength = LE16(2);
   81056:	2202      	movs	r2, #2
   81058:	80da      	strh	r2, [r3, #6]
	uid_cdc_state_msg[port].value = CPU_TO_LE16(0);
   8105a:	8118      	strh	r0, [r3, #8]
	udi_cdc_line_coding[port].dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
   8105c:	4b0c      	ldr	r3, [pc, #48]	; (81090 <udi_cdc_comm_enable+0x54>)
   8105e:	f44f 32e1 	mov.w	r2, #115200	; 0x1c200
   81062:	601a      	str	r2, [r3, #0]
	udi_cdc_line_coding[port].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
   81064:	7118      	strb	r0, [r3, #4]
	udi_cdc_line_coding[port].bParityType = UDI_CDC_DEFAULT_PARITY;
   81066:	7158      	strb	r0, [r3, #5]
	udi_cdc_line_coding[port].bDataBits = UDI_CDC_DEFAULT_DATABITS;
   81068:	2208      	movs	r2, #8
   8106a:	719a      	strb	r2, [r3, #6]
	if (!UDI_CDC_ENABLE_EXT(port)) {
   8106c:	4b09      	ldr	r3, [pc, #36]	; (81094 <udi_cdc_comm_enable+0x58>)
   8106e:	4798      	blx	r3
   81070:	4602      	mov	r2, r0
   81072:	b120      	cbz	r0, 8107e <udi_cdc_comm_enable+0x42>
	udi_cdc_nb_comm_enabled++;
   81074:	4903      	ldr	r1, [pc, #12]	; (81084 <udi_cdc_comm_enable+0x48>)
   81076:	780b      	ldrb	r3, [r1, #0]
   81078:	3301      	adds	r3, #1
   8107a:	b2db      	uxtb	r3, r3
   8107c:	700b      	strb	r3, [r1, #0]
}
   8107e:	4610      	mov	r0, r2
   81080:	bd08      	pop	{r3, pc}
   81082:	bf00      	nop
   81084:	200707f7 	.word	0x200707f7
   81088:	20070c0c 	.word	0x20070c0c
   8108c:	20071024 	.word	0x20071024
   81090:	200707f0 	.word	0x200707f0
   81094:	00083819 	.word	0x00083819

00081098 <udi_cdc_tx_send>:

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
   81098:	4b44      	ldr	r3, [pc, #272]	; (811ac <udi_cdc_tx_send+0x114>)
   8109a:	781b      	ldrb	r3, [r3, #0]
   8109c:	b103      	cbz	r3, 810a0 <udi_cdc_tx_send+0x8>
   8109e:	4770      	bx	lr
{
   810a0:	b570      	push	{r4, r5, r6, lr}
   810a2:	b084      	sub	sp, #16
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
   810a4:	4b42      	ldr	r3, [pc, #264]	; (811b0 <udi_cdc_tx_send+0x118>)
   810a6:	4798      	blx	r3
   810a8:	2800      	cmp	r0, #0
   810aa:	d042      	beq.n	81132 <udi_cdc_tx_send+0x9a>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
   810ac:	4b41      	ldr	r3, [pc, #260]	; (811b4 <udi_cdc_tx_send+0x11c>)
   810ae:	881c      	ldrh	r4, [r3, #0]
   810b0:	4b41      	ldr	r3, [pc, #260]	; (811b8 <udi_cdc_tx_send+0x120>)
   810b2:	4798      	blx	r3
   810b4:	4284      	cmp	r4, r0
   810b6:	d077      	beq.n	811a8 <udi_cdc_tx_send+0x110>
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   810b8:	f3ef 8310 	mrs	r3, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = cpu_irq_is_enabled();
   810bc:	fab3 f383 	clz	r3, r3
   810c0:	095b      	lsrs	r3, r3, #5
   810c2:	9303      	str	r3, [sp, #12]
  __ASM volatile ("cpsid i" : : : "memory");
   810c4:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
   810c6:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   810ca:	2200      	movs	r2, #0
   810cc:	4b3b      	ldr	r3, [pc, #236]	; (811bc <udi_cdc_tx_send+0x124>)
   810ce:	701a      	strb	r2, [r3, #0]
	return flags;
   810d0:	9d03      	ldr	r5, [sp, #12]
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel[port];
   810d2:	4b3b      	ldr	r3, [pc, #236]	; (811c0 <udi_cdc_tx_send+0x128>)
   810d4:	781c      	ldrb	r4, [r3, #0]
   810d6:	b2e4      	uxtb	r4, r4
	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
   810d8:	4b3a      	ldr	r3, [pc, #232]	; (811c4 <udi_cdc_tx_send+0x12c>)
   810da:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
   810de:	2b00      	cmp	r3, #0
   810e0:	d02e      	beq.n	81140 <udi_cdc_tx_send+0xa8>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
			cpu_irq_restore(flags);
			return;
		}
	}
	sof_zlp_counter = 0;
   810e2:	2200      	movs	r2, #0
   810e4:	4b38      	ldr	r3, [pc, #224]	; (811c8 <udi_cdc_tx_send+0x130>)
   810e6:	801a      	strh	r2, [r3, #0]

	if (!udi_cdc_tx_both_buf_to_send[port]) {
   810e8:	4b38      	ldr	r3, [pc, #224]	; (811cc <udi_cdc_tx_send+0x134>)
   810ea:	781b      	ldrb	r3, [r3, #0]
   810ec:	2b00      	cmp	r3, #0
   810ee:	d143      	bne.n	81178 <udi_cdc_tx_send+0xe0>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel[port] = (buf_sel_trans==0)?1:0;
   810f0:	fab4 f384 	clz	r3, r4
   810f4:	095b      	lsrs	r3, r3, #5
   810f6:	4a32      	ldr	r2, [pc, #200]	; (811c0 <udi_cdc_tx_send+0x128>)
   810f8:	7013      	strb	r3, [r2, #0]
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
	}
	udi_cdc_tx_trans_ongoing[port] = true;
   810fa:	2201      	movs	r2, #1
   810fc:	4b2b      	ldr	r3, [pc, #172]	; (811ac <udi_cdc_tx_send+0x114>)
   810fe:	701a      	strb	r2, [r3, #0]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
   81100:	b125      	cbz	r5, 8110c <udi_cdc_tx_send+0x74>
		cpu_irq_enable();
   81102:	4b2e      	ldr	r3, [pc, #184]	; (811bc <udi_cdc_tx_send+0x124>)
   81104:	701a      	strb	r2, [r3, #0]
   81106:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   8110a:	b662      	cpsie	i
	cpu_irq_restore(flags);

	b_short_packet = (udi_cdc_tx_buf_nb[port][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
   8110c:	4626      	mov	r6, r4
   8110e:	4b2d      	ldr	r3, [pc, #180]	; (811c4 <udi_cdc_tx_send+0x12c>)
   81110:	f833 3014 	ldrh.w	r3, [r3, r4, lsl #1]
   81114:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
   81118:	bf14      	ite	ne
   8111a:	2501      	movne	r5, #1
   8111c:	2500      	moveq	r5, #0
	if (b_short_packet) {
   8111e:	d034      	beq.n	8118a <udi_cdc_tx_send+0xf2>
		if (udd_is_high_speed()) {
   81120:	4b23      	ldr	r3, [pc, #140]	; (811b0 <udi_cdc_tx_send+0x118>)
   81122:	4798      	blx	r3
   81124:	2800      	cmp	r0, #0
   81126:	d02b      	beq.n	81180 <udi_cdc_tx_send+0xe8>
			udi_cdc_tx_sof_num[port] = udd_get_micro_frame_number();
   81128:	4b23      	ldr	r3, [pc, #140]	; (811b8 <udi_cdc_tx_send+0x120>)
   8112a:	4798      	blx	r3
   8112c:	4b21      	ldr	r3, [pc, #132]	; (811b4 <udi_cdc_tx_send+0x11c>)
   8112e:	8018      	strh	r0, [r3, #0]
   81130:	e02e      	b.n	81190 <udi_cdc_tx_send+0xf8>
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
   81132:	4b20      	ldr	r3, [pc, #128]	; (811b4 <udi_cdc_tx_send+0x11c>)
   81134:	881c      	ldrh	r4, [r3, #0]
   81136:	4b26      	ldr	r3, [pc, #152]	; (811d0 <udi_cdc_tx_send+0x138>)
   81138:	4798      	blx	r3
   8113a:	4284      	cmp	r4, r0
   8113c:	d1bc      	bne.n	810b8 <udi_cdc_tx_send+0x20>
   8113e:	e033      	b.n	811a8 <udi_cdc_tx_send+0x110>
		sof_zlp_counter++;
   81140:	4a21      	ldr	r2, [pc, #132]	; (811c8 <udi_cdc_tx_send+0x130>)
   81142:	8813      	ldrh	r3, [r2, #0]
   81144:	3301      	adds	r3, #1
   81146:	8013      	strh	r3, [r2, #0]
		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
   81148:	4b19      	ldr	r3, [pc, #100]	; (811b0 <udi_cdc_tx_send+0x118>)
   8114a:	4798      	blx	r3
   8114c:	b918      	cbnz	r0, 81156 <udi_cdc_tx_send+0xbe>
   8114e:	4b1e      	ldr	r3, [pc, #120]	; (811c8 <udi_cdc_tx_send+0x130>)
   81150:	881b      	ldrh	r3, [r3, #0]
   81152:	2b63      	cmp	r3, #99	; 0x63
   81154:	d908      	bls.n	81168 <udi_cdc_tx_send+0xd0>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
   81156:	4b16      	ldr	r3, [pc, #88]	; (811b0 <udi_cdc_tx_send+0x118>)
   81158:	4798      	blx	r3
   8115a:	2800      	cmp	r0, #0
   8115c:	d0c1      	beq.n	810e2 <udi_cdc_tx_send+0x4a>
   8115e:	4b1a      	ldr	r3, [pc, #104]	; (811c8 <udi_cdc_tx_send+0x130>)
   81160:	881b      	ldrh	r3, [r3, #0]
   81162:	f5b3 7f48 	cmp.w	r3, #800	; 0x320
   81166:	d2bc      	bcs.n	810e2 <udi_cdc_tx_send+0x4a>
	if (cpu_irq_is_enabled_flags(flags))
   81168:	b1f5      	cbz	r5, 811a8 <udi_cdc_tx_send+0x110>
		cpu_irq_enable();
   8116a:	2201      	movs	r2, #1
   8116c:	4b13      	ldr	r3, [pc, #76]	; (811bc <udi_cdc_tx_send+0x124>)
   8116e:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   81170:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   81174:	b662      	cpsie	i
   81176:	e017      	b.n	811a8 <udi_cdc_tx_send+0x110>
		buf_sel_trans = (buf_sel_trans==0)?1:0;
   81178:	fab4 f484 	clz	r4, r4
   8117c:	0964      	lsrs	r4, r4, #5
   8117e:	e7bc      	b.n	810fa <udi_cdc_tx_send+0x62>
		}else{
			udi_cdc_tx_sof_num[port] = udd_get_frame_number();
   81180:	4b13      	ldr	r3, [pc, #76]	; (811d0 <udi_cdc_tx_send+0x138>)
   81182:	4798      	blx	r3
   81184:	4b0b      	ldr	r3, [pc, #44]	; (811b4 <udi_cdc_tx_send+0x11c>)
   81186:	8018      	strh	r0, [r3, #0]
   81188:	e002      	b.n	81190 <udi_cdc_tx_send+0xf8>
		}
	}else{
		udi_cdc_tx_sof_num[port] = 0; // Force next transfer without wait SOF
   8118a:	2200      	movs	r2, #0
   8118c:	4b09      	ldr	r3, [pc, #36]	; (811b4 <udi_cdc_tx_send+0x11c>)
   8118e:	801a      	strh	r2, [r3, #0]
		break;
	}
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
   81190:	4b0c      	ldr	r3, [pc, #48]	; (811c4 <udi_cdc_tx_send+0x12c>)
	udd_ep_run( ep,
   81192:	f833 3016 	ldrh.w	r3, [r3, r6, lsl #1]
   81196:	4a0f      	ldr	r2, [pc, #60]	; (811d4 <udi_cdc_tx_send+0x13c>)
   81198:	9200      	str	r2, [sp, #0]
   8119a:	4a0f      	ldr	r2, [pc, #60]	; (811d8 <udi_cdc_tx_send+0x140>)
   8119c:	eb02 2244 	add.w	r2, r2, r4, lsl #9
   811a0:	4629      	mov	r1, r5
   811a2:	2081      	movs	r0, #129	; 0x81
   811a4:	4c0d      	ldr	r4, [pc, #52]	; (811dc <udi_cdc_tx_send+0x144>)
   811a6:	47a0      	blx	r4
			udi_cdc_data_sent);
}
   811a8:	b004      	add	sp, #16
   811aa:	bd70      	pop	{r4, r5, r6, pc}
   811ac:	20071020 	.word	0x20071020
   811b0:	00082c3d 	.word	0x00082c3d
   811b4:	2007101c 	.word	0x2007101c
   811b8:	00082c99 	.word	0x00082c99
   811bc:	2007026e 	.word	0x2007026e
   811c0:	20071018 	.word	0x20071018
   811c4:	20071014 	.word	0x20071014
   811c8:	200707ec 	.word	0x200707ec
   811cc:	20070c10 	.word	0x20070c10
   811d0:	00082c89 	.word	0x00082c89
   811d4:	000811e1 	.word	0x000811e1
   811d8:	20070c14 	.word	0x20070c14
   811dc:	00082f01 	.word	0x00082f01

000811e0 <udi_cdc_data_sent>:
	if (UDD_EP_TRANSFER_OK != status) {
   811e0:	b100      	cbz	r0, 811e4 <udi_cdc_data_sent+0x4>
   811e2:	4770      	bx	lr
{
   811e4:	b508      	push	{r3, lr}
	udi_cdc_tx_buf_nb[port][(udi_cdc_tx_buf_sel[port]==0)?1:0] = 0;
   811e6:	4b07      	ldr	r3, [pc, #28]	; (81204 <udi_cdc_data_sent+0x24>)
   811e8:	781b      	ldrb	r3, [r3, #0]
   811ea:	fab3 f383 	clz	r3, r3
   811ee:	095b      	lsrs	r3, r3, #5
   811f0:	4a05      	ldr	r2, [pc, #20]	; (81208 <udi_cdc_data_sent+0x28>)
   811f2:	f822 0013 	strh.w	r0, [r2, r3, lsl #1]
	udi_cdc_tx_both_buf_to_send[port] = false;
   811f6:	4b05      	ldr	r3, [pc, #20]	; (8120c <udi_cdc_data_sent+0x2c>)
   811f8:	7018      	strb	r0, [r3, #0]
	udi_cdc_tx_trans_ongoing[port] = false;
   811fa:	4b05      	ldr	r3, [pc, #20]	; (81210 <udi_cdc_data_sent+0x30>)
   811fc:	7018      	strb	r0, [r3, #0]
	udi_cdc_tx_send(port);
   811fe:	4b05      	ldr	r3, [pc, #20]	; (81214 <udi_cdc_data_sent+0x34>)
   81200:	4798      	blx	r3
   81202:	bd08      	pop	{r3, pc}
   81204:	20071018 	.word	0x20071018
   81208:	20071014 	.word	0x20071014
   8120c:	20070c10 	.word	0x20070c10
   81210:	20071020 	.word	0x20071020
   81214:	00081099 	.word	0x00081099

00081218 <udi_cdc_data_sof_notify>:
{
   81218:	b508      	push	{r3, lr}
	udi_cdc_tx_send(port_notify);
   8121a:	2000      	movs	r0, #0
   8121c:	4b01      	ldr	r3, [pc, #4]	; (81224 <udi_cdc_data_sof_notify+0xc>)
   8121e:	4798      	blx	r3
   81220:	bd08      	pop	{r3, pc}
   81222:	bf00      	nop
   81224:	00081099 	.word	0x00081099

00081228 <udi_cdc_data_disable>:
{
   81228:	b508      	push	{r3, lr}
	udi_cdc_nb_data_enabled--;
   8122a:	4a06      	ldr	r2, [pc, #24]	; (81244 <udi_cdc_data_disable+0x1c>)
   8122c:	7813      	ldrb	r3, [r2, #0]
   8122e:	3b01      	subs	r3, #1
   81230:	b2db      	uxtb	r3, r3
   81232:	7013      	strb	r3, [r2, #0]
	port = udi_cdc_nb_data_enabled;
   81234:	7810      	ldrb	r0, [r2, #0]
	UDI_CDC_DISABLE_EXT(port);
   81236:	4b04      	ldr	r3, [pc, #16]	; (81248 <udi_cdc_data_disable+0x20>)
   81238:	4798      	blx	r3
	udi_cdc_data_running = false;
   8123a:	2200      	movs	r2, #0
   8123c:	4b03      	ldr	r3, [pc, #12]	; (8124c <udi_cdc_data_disable+0x24>)
   8123e:	701a      	strb	r2, [r3, #0]
   81240:	bd08      	pop	{r3, pc}
   81242:	bf00      	nop
   81244:	200707f8 	.word	0x200707f8
   81248:	00083879 	.word	0x00083879
   8124c:	200707ee 	.word	0x200707ee

00081250 <udi_cdc_multi_get_nb_received_data>:
{
	udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_STATE_OVERRUN);
}

iram_size_t udi_cdc_multi_get_nb_received_data(uint8_t port)
{
   81250:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   81252:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   81256:	fab3 f383 	clz	r3, r3
   8125a:	095b      	lsrs	r3, r3, #5
   8125c:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   8125e:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   81260:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   81264:	2200      	movs	r2, #0
   81266:	4b0b      	ldr	r3, [pc, #44]	; (81294 <udi_cdc_multi_get_nb_received_data+0x44>)
   81268:	701a      	strb	r2, [r3, #0]
	return flags;
   8126a:	9901      	ldr	r1, [sp, #4]

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif
	flags = cpu_irq_save();
	pos = udi_cdc_rx_pos[port];
   8126c:	4b0a      	ldr	r3, [pc, #40]	; (81298 <udi_cdc_multi_get_nb_received_data+0x48>)
   8126e:	8818      	ldrh	r0, [r3, #0]
   81270:	b283      	uxth	r3, r0
	nb_received = udi_cdc_rx_buf_nb[port][udi_cdc_rx_buf_sel[port]] - pos;
   81272:	4a0a      	ldr	r2, [pc, #40]	; (8129c <udi_cdc_multi_get_nb_received_data+0x4c>)
   81274:	7812      	ldrb	r2, [r2, #0]
   81276:	b2d2      	uxtb	r2, r2
   81278:	4809      	ldr	r0, [pc, #36]	; (812a0 <udi_cdc_multi_get_nb_received_data+0x50>)
   8127a:	f830 0012 	ldrh.w	r0, [r0, r2, lsl #1]
   8127e:	b280      	uxth	r0, r0
   81280:	1ac0      	subs	r0, r0, r3
	if (cpu_irq_is_enabled_flags(flags))
   81282:	b129      	cbz	r1, 81290 <udi_cdc_multi_get_nb_received_data+0x40>
		cpu_irq_enable();
   81284:	2201      	movs	r2, #1
   81286:	4b03      	ldr	r3, [pc, #12]	; (81294 <udi_cdc_multi_get_nb_received_data+0x44>)
   81288:	701a      	strb	r2, [r3, #0]
   8128a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   8128e:	b662      	cpsie	i
	cpu_irq_restore(flags);
	return nb_received;
}
   81290:	b002      	add	sp, #8
   81292:	4770      	bx	lr
   81294:	2007026e 	.word	0x2007026e
   81298:	20070c04 	.word	0x20070c04
   8129c:	20070c00 	.word	0x20070c00
   812a0:	20070bfc 	.word	0x20070bfc

000812a4 <udi_cdc_multi_is_rx_ready>:
{
	return udi_cdc_multi_get_nb_received_data(0);
}

bool udi_cdc_multi_is_rx_ready(uint8_t port)
{
   812a4:	b508      	push	{r3, lr}
	return (udi_cdc_multi_get_nb_received_data(port) > 0);
   812a6:	4b03      	ldr	r3, [pc, #12]	; (812b4 <udi_cdc_multi_is_rx_ready+0x10>)
   812a8:	4798      	blx	r3
}
   812aa:	3000      	adds	r0, #0
   812ac:	bf18      	it	ne
   812ae:	2001      	movne	r0, #1
   812b0:	bd08      	pop	{r3, pc}
   812b2:	bf00      	nop
   812b4:	00081251 	.word	0x00081251

000812b8 <udi_cdc_rx_start>:
{
   812b8:	b510      	push	{r4, lr}
   812ba:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   812bc:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   812c0:	fab3 f383 	clz	r3, r3
   812c4:	095b      	lsrs	r3, r3, #5
   812c6:	9303      	str	r3, [sp, #12]
  __ASM volatile ("cpsid i" : : : "memory");
   812c8:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   812ca:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   812ce:	2200      	movs	r2, #0
   812d0:	4b21      	ldr	r3, [pc, #132]	; (81358 <udi_cdc_rx_start+0xa0>)
   812d2:	701a      	strb	r2, [r3, #0]
	return flags;
   812d4:	9b03      	ldr	r3, [sp, #12]
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
   812d6:	4a21      	ldr	r2, [pc, #132]	; (8135c <udi_cdc_rx_start+0xa4>)
   812d8:	7814      	ldrb	r4, [r2, #0]
	if (udi_cdc_rx_trans_ongoing[port] ||
   812da:	4a21      	ldr	r2, [pc, #132]	; (81360 <udi_cdc_rx_start+0xa8>)
   812dc:	7812      	ldrb	r2, [r2, #0]
   812de:	b94a      	cbnz	r2, 812f4 <udi_cdc_rx_start+0x3c>
   812e0:	b2e4      	uxtb	r4, r4
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
   812e2:	4a20      	ldr	r2, [pc, #128]	; (81364 <udi_cdc_rx_start+0xac>)
   812e4:	8811      	ldrh	r1, [r2, #0]
   812e6:	b289      	uxth	r1, r1
   812e8:	4a1f      	ldr	r2, [pc, #124]	; (81368 <udi_cdc_rx_start+0xb0>)
   812ea:	f832 2014 	ldrh.w	r2, [r2, r4, lsl #1]
   812ee:	b292      	uxth	r2, r2
	if (udi_cdc_rx_trans_ongoing[port] ||
   812f0:	4291      	cmp	r1, r2
   812f2:	d20a      	bcs.n	8130a <udi_cdc_rx_start+0x52>
	if (cpu_irq_is_enabled_flags(flags))
   812f4:	2b00      	cmp	r3, #0
   812f6:	d02d      	beq.n	81354 <udi_cdc_rx_start+0x9c>
		cpu_irq_enable();
   812f8:	2201      	movs	r2, #1
   812fa:	4b17      	ldr	r3, [pc, #92]	; (81358 <udi_cdc_rx_start+0xa0>)
   812fc:	701a      	strb	r2, [r3, #0]
   812fe:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   81302:	b662      	cpsie	i
		return false;
   81304:	2000      	movs	r0, #0
}
   81306:	b004      	add	sp, #16
   81308:	bd10      	pop	{r4, pc}
	udi_cdc_rx_pos[port] = 0;
   8130a:	2100      	movs	r1, #0
   8130c:	4a15      	ldr	r2, [pc, #84]	; (81364 <udi_cdc_rx_start+0xac>)
   8130e:	8011      	strh	r1, [r2, #0]
	udi_cdc_rx_buf_sel[port] = (buf_sel_trans==0)?1:0;
   81310:	fab4 f284 	clz	r2, r4
   81314:	0952      	lsrs	r2, r2, #5
   81316:	4911      	ldr	r1, [pc, #68]	; (8135c <udi_cdc_rx_start+0xa4>)
   81318:	700a      	strb	r2, [r1, #0]
	udi_cdc_rx_trans_ongoing[port] = true;
   8131a:	2101      	movs	r1, #1
   8131c:	4a10      	ldr	r2, [pc, #64]	; (81360 <udi_cdc_rx_start+0xa8>)
   8131e:	7011      	strb	r1, [r2, #0]
	if (cpu_irq_is_enabled_flags(flags))
   81320:	b123      	cbz	r3, 8132c <udi_cdc_rx_start+0x74>
		cpu_irq_enable();
   81322:	4b0d      	ldr	r3, [pc, #52]	; (81358 <udi_cdc_rx_start+0xa0>)
   81324:	7019      	strb	r1, [r3, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   81326:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   8132a:	b662      	cpsie	i
	if (udi_cdc_multi_is_rx_ready(port)) {
   8132c:	2000      	movs	r0, #0
   8132e:	4b0f      	ldr	r3, [pc, #60]	; (8136c <udi_cdc_rx_start+0xb4>)
   81330:	4798      	blx	r3
   81332:	b958      	cbnz	r0, 8134c <udi_cdc_rx_start+0x94>
	return udd_ep_run(ep,
   81334:	4b0e      	ldr	r3, [pc, #56]	; (81370 <udi_cdc_rx_start+0xb8>)
   81336:	9300      	str	r3, [sp, #0]
   81338:	f44f 7300 	mov.w	r3, #512	; 0x200
   8133c:	4a0d      	ldr	r2, [pc, #52]	; (81374 <udi_cdc_rx_start+0xbc>)
   8133e:	eb02 2244 	add.w	r2, r2, r4, lsl #9
   81342:	2101      	movs	r1, #1
   81344:	2002      	movs	r0, #2
   81346:	4c0c      	ldr	r4, [pc, #48]	; (81378 <udi_cdc_rx_start+0xc0>)
   81348:	47a0      	blx	r4
   8134a:	e7dc      	b.n	81306 <udi_cdc_rx_start+0x4e>
		UDI_CDC_RX_NOTIFY(port);
   8134c:	2000      	movs	r0, #0
   8134e:	4b0b      	ldr	r3, [pc, #44]	; (8137c <udi_cdc_rx_start+0xc4>)
   81350:	4798      	blx	r3
   81352:	e7ef      	b.n	81334 <udi_cdc_rx_start+0x7c>
		return false;
   81354:	2000      	movs	r0, #0
   81356:	e7d6      	b.n	81306 <udi_cdc_rx_start+0x4e>
   81358:	2007026e 	.word	0x2007026e
   8135c:	20070c00 	.word	0x20070c00
   81360:	20070c08 	.word	0x20070c08
   81364:	20070c04 	.word	0x20070c04
   81368:	20070bfc 	.word	0x20070bfc
   8136c:	000812a5 	.word	0x000812a5
   81370:	00081415 	.word	0x00081415
   81374:	200707fc 	.word	0x200707fc
   81378:	00082f01 	.word	0x00082f01
   8137c:	00083825 	.word	0x00083825

00081380 <udi_cdc_data_enable>:
{
   81380:	b510      	push	{r4, lr}
	udi_cdc_nb_data_enabled = 0;
   81382:	2400      	movs	r4, #0
   81384:	4b16      	ldr	r3, [pc, #88]	; (813e0 <udi_cdc_data_enable+0x60>)
   81386:	701c      	strb	r4, [r3, #0]
	udi_cdc_tx_trans_ongoing[port] = false;
   81388:	4b16      	ldr	r3, [pc, #88]	; (813e4 <udi_cdc_data_enable+0x64>)
   8138a:	701c      	strb	r4, [r3, #0]
	udi_cdc_tx_both_buf_to_send[port] = false;
   8138c:	4b16      	ldr	r3, [pc, #88]	; (813e8 <udi_cdc_data_enable+0x68>)
   8138e:	701c      	strb	r4, [r3, #0]
	udi_cdc_tx_buf_sel[port] = 0;
   81390:	4b16      	ldr	r3, [pc, #88]	; (813ec <udi_cdc_data_enable+0x6c>)
   81392:	701c      	strb	r4, [r3, #0]
	udi_cdc_tx_buf_nb[port][0] = 0;
   81394:	4b16      	ldr	r3, [pc, #88]	; (813f0 <udi_cdc_data_enable+0x70>)
   81396:	801c      	strh	r4, [r3, #0]
	udi_cdc_tx_buf_nb[port][1] = 0;
   81398:	805c      	strh	r4, [r3, #2]
	udi_cdc_tx_sof_num[port] = 0;
   8139a:	4b16      	ldr	r3, [pc, #88]	; (813f4 <udi_cdc_data_enable+0x74>)
   8139c:	801c      	strh	r4, [r3, #0]
	udi_cdc_tx_send(port);
   8139e:	4620      	mov	r0, r4
   813a0:	4b15      	ldr	r3, [pc, #84]	; (813f8 <udi_cdc_data_enable+0x78>)
   813a2:	4798      	blx	r3
	udi_cdc_rx_trans_ongoing[port] = false;
   813a4:	4b15      	ldr	r3, [pc, #84]	; (813fc <udi_cdc_data_enable+0x7c>)
   813a6:	701c      	strb	r4, [r3, #0]
	udi_cdc_rx_buf_sel[port] = 0;
   813a8:	4b15      	ldr	r3, [pc, #84]	; (81400 <udi_cdc_data_enable+0x80>)
   813aa:	701c      	strb	r4, [r3, #0]
	udi_cdc_rx_buf_nb[port][0] = 0;
   813ac:	4b15      	ldr	r3, [pc, #84]	; (81404 <udi_cdc_data_enable+0x84>)
   813ae:	801c      	strh	r4, [r3, #0]
	udi_cdc_rx_buf_nb[port][1] = 0;
   813b0:	805c      	strh	r4, [r3, #2]
	udi_cdc_rx_pos[port] = 0;
   813b2:	4b15      	ldr	r3, [pc, #84]	; (81408 <udi_cdc_data_enable+0x88>)
   813b4:	801c      	strh	r4, [r3, #0]
	if (!udi_cdc_rx_start(port)) {
   813b6:	4620      	mov	r0, r4
   813b8:	4b14      	ldr	r3, [pc, #80]	; (8140c <udi_cdc_data_enable+0x8c>)
   813ba:	4798      	blx	r3
   813bc:	4601      	mov	r1, r0
   813be:	b140      	cbz	r0, 813d2 <udi_cdc_data_enable+0x52>
	udi_cdc_nb_data_enabled++;
   813c0:	4a07      	ldr	r2, [pc, #28]	; (813e0 <udi_cdc_data_enable+0x60>)
   813c2:	7813      	ldrb	r3, [r2, #0]
   813c4:	3301      	adds	r3, #1
   813c6:	b2db      	uxtb	r3, r3
   813c8:	7013      	strb	r3, [r2, #0]
	if (udi_cdc_nb_data_enabled == UDI_CDC_PORT_NB) {
   813ca:	7813      	ldrb	r3, [r2, #0]
   813cc:	b2db      	uxtb	r3, r3
   813ce:	2b01      	cmp	r3, #1
   813d0:	d001      	beq.n	813d6 <udi_cdc_data_enable+0x56>
}
   813d2:	4608      	mov	r0, r1
   813d4:	bd10      	pop	{r4, pc}
		udi_cdc_data_running = true;
   813d6:	2201      	movs	r2, #1
   813d8:	4b0d      	ldr	r3, [pc, #52]	; (81410 <udi_cdc_data_enable+0x90>)
   813da:	701a      	strb	r2, [r3, #0]
   813dc:	e7f9      	b.n	813d2 <udi_cdc_data_enable+0x52>
   813de:	bf00      	nop
   813e0:	200707f8 	.word	0x200707f8
   813e4:	20071020 	.word	0x20071020
   813e8:	20070c10 	.word	0x20070c10
   813ec:	20071018 	.word	0x20071018
   813f0:	20071014 	.word	0x20071014
   813f4:	2007101c 	.word	0x2007101c
   813f8:	00081099 	.word	0x00081099
   813fc:	20070c08 	.word	0x20070c08
   81400:	20070c00 	.word	0x20070c00
   81404:	20070bfc 	.word	0x20070bfc
   81408:	20070c04 	.word	0x20070c04
   8140c:	000812b9 	.word	0x000812b9
   81410:	200707ee 	.word	0x200707ee

00081414 <udi_cdc_data_received>:
	if (UDD_EP_TRANSFER_OK != status) {
   81414:	b9f0      	cbnz	r0, 81454 <udi_cdc_data_received+0x40>
{
   81416:	b510      	push	{r4, lr}
   81418:	b082      	sub	sp, #8
   8141a:	4610      	mov	r0, r2
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
   8141c:	4b0e      	ldr	r3, [pc, #56]	; (81458 <udi_cdc_data_received+0x44>)
   8141e:	781c      	ldrb	r4, [r3, #0]
   81420:	fab4 f484 	clz	r4, r4
   81424:	0964      	lsrs	r4, r4, #5
	if (!n) {
   81426:	b151      	cbz	r1, 8143e <udi_cdc_data_received+0x2a>
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
   81428:	b289      	uxth	r1, r1
   8142a:	4b0c      	ldr	r3, [pc, #48]	; (8145c <udi_cdc_data_received+0x48>)
   8142c:	f823 1014 	strh.w	r1, [r3, r4, lsl #1]
	udi_cdc_rx_trans_ongoing[port] = false;
   81430:	2000      	movs	r0, #0
   81432:	4b0b      	ldr	r3, [pc, #44]	; (81460 <udi_cdc_data_received+0x4c>)
   81434:	7018      	strb	r0, [r3, #0]
	udi_cdc_rx_start(port);
   81436:	4b0b      	ldr	r3, [pc, #44]	; (81464 <udi_cdc_data_received+0x50>)
   81438:	4798      	blx	r3
}
   8143a:	b002      	add	sp, #8
   8143c:	bd10      	pop	{r4, pc}
		udd_ep_run( ep,
   8143e:	4b0a      	ldr	r3, [pc, #40]	; (81468 <udi_cdc_data_received+0x54>)
   81440:	9300      	str	r3, [sp, #0]
   81442:	f44f 7300 	mov.w	r3, #512	; 0x200
   81446:	4a09      	ldr	r2, [pc, #36]	; (8146c <udi_cdc_data_received+0x58>)
   81448:	eb02 2244 	add.w	r2, r2, r4, lsl #9
   8144c:	2101      	movs	r1, #1
   8144e:	4c08      	ldr	r4, [pc, #32]	; (81470 <udi_cdc_data_received+0x5c>)
   81450:	47a0      	blx	r4
		return;
   81452:	e7f2      	b.n	8143a <udi_cdc_data_received+0x26>
   81454:	4770      	bx	lr
   81456:	bf00      	nop
   81458:	20070c00 	.word	0x20070c00
   8145c:	20070bfc 	.word	0x20070bfc
   81460:	20070c08 	.word	0x20070c08
   81464:	000812b9 	.word	0x000812b9
   81468:	00081415 	.word	0x00081415
   8146c:	200707fc 	.word	0x200707fc
   81470:	00082f01 	.word	0x00082f01

00081474 <udc_next_desc_in_iface>:
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
   81474:	4b10      	ldr	r3, [pc, #64]	; (814b8 <udc_next_desc_in_iface+0x44>)
   81476:	681b      	ldr	r3, [r3, #0]
   81478:	681a      	ldr	r2, [r3, #0]
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
   8147a:	8853      	ldrh	r3, [r2, #2]
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
   8147c:	441a      	add	r2, r3
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
   8147e:	7803      	ldrb	r3, [r0, #0]
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
   81480:	4418      	add	r0, r3
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
   81482:	4290      	cmp	r0, r2
   81484:	d211      	bcs.n	814aa <udc_next_desc_in_iface+0x36>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
   81486:	7843      	ldrb	r3, [r0, #1]
   81488:	2b04      	cmp	r3, #4
   8148a:	d010      	beq.n	814ae <udc_next_desc_in_iface+0x3a>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
   8148c:	428b      	cmp	r3, r1
   8148e:	d009      	beq.n	814a4 <udc_next_desc_in_iface+0x30>
			return desc; // Specific descriptor found
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
   81490:	7803      	ldrb	r3, [r0, #0]
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
   81492:	4418      	add	r0, r3
	while (ptr_eof_desc > desc) {
   81494:	4290      	cmp	r0, r2
   81496:	d206      	bcs.n	814a6 <udc_next_desc_in_iface+0x32>
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
   81498:	7843      	ldrb	r3, [r0, #1]
   8149a:	2b04      	cmp	r3, #4
   8149c:	d009      	beq.n	814b2 <udc_next_desc_in_iface+0x3e>
		if (desc_id == desc->bDescriptorType) {
   8149e:	428b      	cmp	r3, r1
   814a0:	d1f6      	bne.n	81490 <udc_next_desc_in_iface+0x1c>
   814a2:	e007      	b.n	814b4 <udc_next_desc_in_iface+0x40>
   814a4:	4770      	bx	lr
	}
	return NULL; // No specific descriptor found
   814a6:	2000      	movs	r0, #0
   814a8:	4770      	bx	lr
   814aa:	2000      	movs	r0, #0
   814ac:	4770      	bx	lr
   814ae:	2000      	movs	r0, #0
   814b0:	4770      	bx	lr
   814b2:	2000      	movs	r0, #0
}
   814b4:	4770      	bx	lr
   814b6:	bf00      	nop
   814b8:	2007103c 	.word	0x2007103c

000814bc <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
   814bc:	b508      	push	{r3, lr}
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
   814be:	4b03      	ldr	r3, [pc, #12]	; (814cc <udc_valid_address+0x10>)
   814c0:	7898      	ldrb	r0, [r3, #2]
   814c2:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   814c6:	4b02      	ldr	r3, [pc, #8]	; (814d0 <udc_valid_address+0x14>)
   814c8:	4798      	blx	r3
   814ca:	bd08      	pop	{r3, pc}
   814cc:	20075364 	.word	0x20075364
   814d0:	00082c51 	.word	0x00082c51

000814d4 <udc_update_iface_desc>:
	if (0 == udc_num_configuration) {
   814d4:	4b19      	ldr	r3, [pc, #100]	; (8153c <udc_update_iface_desc+0x68>)
   814d6:	781b      	ldrb	r3, [r3, #0]
   814d8:	b34b      	cbz	r3, 8152e <udc_update_iface_desc+0x5a>
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   814da:	4b19      	ldr	r3, [pc, #100]	; (81540 <udc_update_iface_desc+0x6c>)
   814dc:	681b      	ldr	r3, [r3, #0]
   814de:	681b      	ldr	r3, [r3, #0]
   814e0:	791a      	ldrb	r2, [r3, #4]
   814e2:	4282      	cmp	r2, r0
   814e4:	d925      	bls.n	81532 <udc_update_iface_desc+0x5e>
{
   814e6:	b470      	push	{r4, r5, r6}
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
   814e8:	4a16      	ldr	r2, [pc, #88]	; (81544 <udc_update_iface_desc+0x70>)
   814ea:	6013      	str	r3, [r2, #0]
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
   814ec:	885c      	ldrh	r4, [r3, #2]
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
   814ee:	441c      	add	r4, r3
	while (ptr_end_desc >
   814f0:	42a3      	cmp	r3, r4
   814f2:	d220      	bcs.n	81536 <udc_update_iface_desc+0x62>
   814f4:	2500      	movs	r5, #0
   814f6:	2601      	movs	r6, #1
   814f8:	e007      	b.n	8150a <udc_update_iface_desc+0x36>
   814fa:	4a12      	ldr	r2, [pc, #72]	; (81544 <udc_update_iface_desc+0x70>)
   814fc:	6013      	str	r3, [r2, #0]
   814fe:	e00f      	b.n	81520 <udc_update_iface_desc+0x4c>
				udc_ptr_iface->bLength);
   81500:	781a      	ldrb	r2, [r3, #0]
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
   81502:	4413      	add	r3, r2
   81504:	4635      	mov	r5, r6
	while (ptr_end_desc >
   81506:	42a3      	cmp	r3, r4
   81508:	d20c      	bcs.n	81524 <udc_update_iface_desc+0x50>
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
   8150a:	785a      	ldrb	r2, [r3, #1]
   8150c:	2a04      	cmp	r2, #4
   8150e:	d1f7      	bne.n	81500 <udc_update_iface_desc+0x2c>
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
   81510:	789a      	ldrb	r2, [r3, #2]
   81512:	4282      	cmp	r2, r0
   81514:	d1f4      	bne.n	81500 <udc_update_iface_desc+0x2c>
   81516:	78da      	ldrb	r2, [r3, #3]
   81518:	428a      	cmp	r2, r1
   8151a:	d1f1      	bne.n	81500 <udc_update_iface_desc+0x2c>
   8151c:	2d00      	cmp	r5, #0
   8151e:	d1ec      	bne.n	814fa <udc_update_iface_desc+0x26>
				return true; // Interface found
   81520:	2001      	movs	r0, #1
   81522:	e002      	b.n	8152a <udc_update_iface_desc+0x56>
   81524:	4a07      	ldr	r2, [pc, #28]	; (81544 <udc_update_iface_desc+0x70>)
   81526:	6013      	str	r3, [r2, #0]
	return false; // Interface not found
   81528:	2000      	movs	r0, #0
}
   8152a:	bc70      	pop	{r4, r5, r6}
   8152c:	4770      	bx	lr
		return false;
   8152e:	2000      	movs	r0, #0
   81530:	4770      	bx	lr
		return false;
   81532:	2000      	movs	r0, #0
   81534:	4770      	bx	lr
	return false; // Interface not found
   81536:	2000      	movs	r0, #0
   81538:	e7f7      	b.n	8152a <udc_update_iface_desc+0x56>
   8153a:	bf00      	nop
   8153c:	20071038 	.word	0x20071038
   81540:	2007103c 	.word	0x2007103c
   81544:	20071040 	.word	0x20071040

00081548 <udc_iface_disable>:
{
   81548:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   8154c:	4604      	mov	r4, r0
	if (!udc_update_iface_desc(iface_num, 0)) {
   8154e:	2100      	movs	r1, #0
   81550:	4b13      	ldr	r3, [pc, #76]	; (815a0 <udc_iface_disable+0x58>)
   81552:	4798      	blx	r3
   81554:	4680      	mov	r8, r0
   81556:	b910      	cbnz	r0, 8155e <udc_iface_disable+0x16>
}
   81558:	4640      	mov	r0, r8
   8155a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   8155e:	4b11      	ldr	r3, [pc, #68]	; (815a4 <udc_iface_disable+0x5c>)
   81560:	681b      	ldr	r3, [r3, #0]
   81562:	685b      	ldr	r3, [r3, #4]
   81564:	f853 9024 	ldr.w	r9, [r3, r4, lsl #2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   81568:	f8d9 300c 	ldr.w	r3, [r9, #12]
   8156c:	4798      	blx	r3
   8156e:	4601      	mov	r1, r0
   81570:	4620      	mov	r0, r4
   81572:	4b0b      	ldr	r3, [pc, #44]	; (815a0 <udc_iface_disable+0x58>)
   81574:	4798      	blx	r3
   81576:	4680      	mov	r8, r0
   81578:	2800      	cmp	r0, #0
   8157a:	d0ed      	beq.n	81558 <udc_iface_disable+0x10>
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
   8157c:	4b0a      	ldr	r3, [pc, #40]	; (815a8 <udc_iface_disable+0x60>)
   8157e:	681c      	ldr	r4, [r3, #0]
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   81580:	2605      	movs	r6, #5
   81582:	4d0a      	ldr	r5, [pc, #40]	; (815ac <udc_iface_disable+0x64>)
			udd_ep_free(ep_desc->bEndpointAddress);
   81584:	4f0a      	ldr	r7, [pc, #40]	; (815b0 <udc_iface_disable+0x68>)
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   81586:	4631      	mov	r1, r6
   81588:	4620      	mov	r0, r4
   8158a:	47a8      	blx	r5
			if (NULL == ep_desc) {
   8158c:	4604      	mov	r4, r0
   8158e:	b110      	cbz	r0, 81596 <udc_iface_disable+0x4e>
			udd_ep_free(ep_desc->bEndpointAddress);
   81590:	7880      	ldrb	r0, [r0, #2]
   81592:	47b8      	blx	r7
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   81594:	e7f7      	b.n	81586 <udc_iface_disable+0x3e>
	udi_api->disable();
   81596:	f8d9 3004 	ldr.w	r3, [r9, #4]
   8159a:	4798      	blx	r3
	return true;
   8159c:	e7dc      	b.n	81558 <udc_iface_disable+0x10>
   8159e:	bf00      	nop
   815a0:	000814d5 	.word	0x000814d5
   815a4:	2007103c 	.word	0x2007103c
   815a8:	20071040 	.word	0x20071040
   815ac:	00081475 	.word	0x00081475
   815b0:	00082cb5 	.word	0x00082cb5

000815b4 <udc_iface_enable>:
{
   815b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   815b8:	4680      	mov	r8, r0
	if (!udc_update_iface_desc(iface_num, setting_num)) {
   815ba:	4b10      	ldr	r3, [pc, #64]	; (815fc <udc_iface_enable+0x48>)
   815bc:	4798      	blx	r3
   815be:	4603      	mov	r3, r0
   815c0:	b1c8      	cbz	r0, 815f6 <udc_iface_enable+0x42>
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
   815c2:	4b0f      	ldr	r3, [pc, #60]	; (81600 <udc_iface_enable+0x4c>)
   815c4:	681c      	ldr	r4, [r3, #0]
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   815c6:	2605      	movs	r6, #5
   815c8:	4d0e      	ldr	r5, [pc, #56]	; (81604 <udc_iface_enable+0x50>)
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
   815ca:	4f0f      	ldr	r7, [pc, #60]	; (81608 <udc_iface_enable+0x54>)
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
   815cc:	4631      	mov	r1, r6
   815ce:	4620      	mov	r0, r4
   815d0:	47a8      	blx	r5
		if (NULL == ep_desc)
   815d2:	4604      	mov	r4, r0
   815d4:	b138      	cbz	r0, 815e6 <udc_iface_enable+0x32>
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
   815d6:	8882      	ldrh	r2, [r0, #4]
   815d8:	78c1      	ldrb	r1, [r0, #3]
   815da:	7880      	ldrb	r0, [r0, #2]
   815dc:	47b8      	blx	r7
   815de:	4603      	mov	r3, r0
   815e0:	2800      	cmp	r0, #0
   815e2:	d1f3      	bne.n	815cc <udc_iface_enable+0x18>
   815e4:	e007      	b.n	815f6 <udc_iface_enable+0x42>
	return udc_ptr_conf->udi_apis[iface_num]->enable();
   815e6:	4b09      	ldr	r3, [pc, #36]	; (8160c <udc_iface_enable+0x58>)
   815e8:	681b      	ldr	r3, [r3, #0]
   815ea:	685b      	ldr	r3, [r3, #4]
   815ec:	f853 3028 	ldr.w	r3, [r3, r8, lsl #2]
   815f0:	681b      	ldr	r3, [r3, #0]
   815f2:	4798      	blx	r3
   815f4:	4603      	mov	r3, r0
}
   815f6:	4618      	mov	r0, r3
   815f8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   815fc:	000814d5 	.word	0x000814d5
   81600:	20071040 	.word	0x20071040
   81604:	00081475 	.word	0x00081475
   81608:	00082ffd 	.word	0x00082ffd
   8160c:	2007103c 	.word	0x2007103c

00081610 <udc_reset>:
{
   81610:	b570      	push	{r4, r5, r6, lr}
	if (udc_num_configuration) {
   81612:	4b0d      	ldr	r3, [pc, #52]	; (81648 <udc_reset+0x38>)
   81614:	781b      	ldrb	r3, [r3, #0]
   81616:	b183      	cbz	r3, 8163a <udc_reset+0x2a>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81618:	4b0c      	ldr	r3, [pc, #48]	; (8164c <udc_reset+0x3c>)
   8161a:	681b      	ldr	r3, [r3, #0]
   8161c:	681b      	ldr	r3, [r3, #0]
		for (iface_num = 0;
   8161e:	791b      	ldrb	r3, [r3, #4]
   81620:	b15b      	cbz	r3, 8163a <udc_reset+0x2a>
   81622:	2400      	movs	r4, #0
			udc_iface_disable(iface_num);
   81624:	4e0a      	ldr	r6, [pc, #40]	; (81650 <udc_reset+0x40>)
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81626:	4d09      	ldr	r5, [pc, #36]	; (8164c <udc_reset+0x3c>)
			udc_iface_disable(iface_num);
   81628:	4620      	mov	r0, r4
   8162a:	47b0      	blx	r6
				iface_num++) {
   8162c:	3401      	adds	r4, #1
   8162e:	b2e4      	uxtb	r4, r4
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81630:	682b      	ldr	r3, [r5, #0]
   81632:	681b      	ldr	r3, [r3, #0]
		for (iface_num = 0;
   81634:	791b      	ldrb	r3, [r3, #4]
   81636:	42a3      	cmp	r3, r4
   81638:	d8f6      	bhi.n	81628 <udc_reset+0x18>
	udc_num_configuration = 0;
   8163a:	2200      	movs	r2, #0
   8163c:	4b02      	ldr	r3, [pc, #8]	; (81648 <udc_reset+0x38>)
   8163e:	701a      	strb	r2, [r3, #0]
	udc_device_status =
   81640:	2201      	movs	r2, #1
   81642:	4b04      	ldr	r3, [pc, #16]	; (81654 <udc_reset+0x44>)
   81644:	801a      	strh	r2, [r3, #0]
   81646:	bd70      	pop	{r4, r5, r6, pc}
   81648:	20071038 	.word	0x20071038
   8164c:	2007103c 	.word	0x2007103c
   81650:	00081549 	.word	0x00081549
   81654:	2007102e 	.word	0x2007102e

00081658 <udc_sof_notify>:
{
   81658:	b538      	push	{r3, r4, r5, lr}
	if (udc_num_configuration) {
   8165a:	4b0d      	ldr	r3, [pc, #52]	; (81690 <udc_sof_notify+0x38>)
   8165c:	781b      	ldrb	r3, [r3, #0]
   8165e:	b1b3      	cbz	r3, 8168e <udc_sof_notify+0x36>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81660:	4b0c      	ldr	r3, [pc, #48]	; (81694 <udc_sof_notify+0x3c>)
   81662:	681b      	ldr	r3, [r3, #0]
   81664:	681a      	ldr	r2, [r3, #0]
		for (iface_num = 0;
   81666:	7912      	ldrb	r2, [r2, #4]
   81668:	b18a      	cbz	r2, 8168e <udc_sof_notify+0x36>
   8166a:	2400      	movs	r4, #0
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   8166c:	4d09      	ldr	r5, [pc, #36]	; (81694 <udc_sof_notify+0x3c>)
   8166e:	e006      	b.n	8167e <udc_sof_notify+0x26>
				iface_num++) {
   81670:	3401      	adds	r4, #1
   81672:	b2e4      	uxtb	r4, r4
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81674:	682b      	ldr	r3, [r5, #0]
   81676:	681a      	ldr	r2, [r3, #0]
		for (iface_num = 0;
   81678:	7912      	ldrb	r2, [r2, #4]
   8167a:	42a2      	cmp	r2, r4
   8167c:	d907      	bls.n	8168e <udc_sof_notify+0x36>
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
   8167e:	685b      	ldr	r3, [r3, #4]
   81680:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   81684:	691b      	ldr	r3, [r3, #16]
   81686:	2b00      	cmp	r3, #0
   81688:	d0f2      	beq.n	81670 <udc_sof_notify+0x18>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
   8168a:	4798      	blx	r3
   8168c:	e7f0      	b.n	81670 <udc_sof_notify+0x18>
   8168e:	bd38      	pop	{r3, r4, r5, pc}
   81690:	20071038 	.word	0x20071038
   81694:	2007103c 	.word	0x2007103c

00081698 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
   81698:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
   8169a:	4b94      	ldr	r3, [pc, #592]	; (818ec <udc_process_setup+0x254>)
   8169c:	2200      	movs	r2, #0
   8169e:	819a      	strh	r2, [r3, #12]
	udd_g_ctrlreq.callback = NULL;
   816a0:	611a      	str	r2, [r3, #16]
	udd_g_ctrlreq.over_under_run = NULL;
   816a2:	615a      	str	r2, [r3, #20]

	if (Udd_setup_is_in()) {
   816a4:	781b      	ldrb	r3, [r3, #0]
   816a6:	f013 0f80 	tst.w	r3, #128	; 0x80
   816aa:	d114      	bne.n	816d6 <udc_process_setup+0x3e>
			return false; // Error from USB host
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
   816ac:	f013 0f60 	tst.w	r3, #96	; 0x60
   816b0:	f000 813c 	beq.w	8192c <udc_process_setup+0x294>
			return true;
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
   816b4:	4b8d      	ldr	r3, [pc, #564]	; (818ec <udc_process_setup+0x254>)
   816b6:	781b      	ldrb	r3, [r3, #0]
   816b8:	f003 031f 	and.w	r3, r3, #31
   816bc:	2b01      	cmp	r3, #1
   816be:	f000 8208 	beq.w	81ad2 <udc_process_setup+0x43a>
			return true;
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
   816c2:	4b8a      	ldr	r3, [pc, #552]	; (818ec <udc_process_setup+0x254>)
   816c4:	781b      	ldrb	r3, [r3, #0]
   816c6:	f003 031f 	and.w	r3, r3, #31
   816ca:	2b02      	cmp	r3, #2
   816cc:	f000 8286 	beq.w	81bdc <udc_process_setup+0x544>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
   816d0:	2300      	movs	r3, #0
#endif
}
   816d2:	4618      	mov	r0, r3
   816d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (udd_g_ctrlreq.req.wLength == 0) {
   816d6:	4a85      	ldr	r2, [pc, #532]	; (818ec <udc_process_setup+0x254>)
   816d8:	88d2      	ldrh	r2, [r2, #6]
   816da:	2a00      	cmp	r2, #0
   816dc:	f000 82a7 	beq.w	81c2e <udc_process_setup+0x596>
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
   816e0:	f013 0f60 	tst.w	r3, #96	; 0x60
   816e4:	d1e6      	bne.n	816b4 <udc_process_setup+0x1c>
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
   816e6:	f013 031f 	ands.w	r3, r3, #31
   816ea:	d107      	bne.n	816fc <udc_process_setup+0x64>
			switch (udd_g_ctrlreq.req.bRequest) {
   816ec:	497f      	ldr	r1, [pc, #508]	; (818ec <udc_process_setup+0x254>)
   816ee:	7849      	ldrb	r1, [r1, #1]
   816f0:	2906      	cmp	r1, #6
   816f2:	d016      	beq.n	81722 <udc_process_setup+0x8a>
   816f4:	2908      	cmp	r1, #8
   816f6:	f000 80ba 	beq.w	8186e <udc_process_setup+0x1d6>
   816fa:	b159      	cbz	r1, 81714 <udc_process_setup+0x7c>
		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
   816fc:	2b01      	cmp	r3, #1
   816fe:	f000 80be 	beq.w	8187e <udc_process_setup+0x1e6>
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
   81702:	2b02      	cmp	r3, #2
   81704:	d1d6      	bne.n	816b4 <udc_process_setup+0x1c>
			switch (udd_g_ctrlreq.req.bRequest) {
   81706:	4b79      	ldr	r3, [pc, #484]	; (818ec <udc_process_setup+0x254>)
   81708:	785b      	ldrb	r3, [r3, #1]
   8170a:	2b00      	cmp	r3, #0
   8170c:	f000 80e0 	beq.w	818d0 <udc_process_setup+0x238>
	return false;
   81710:	2300      	movs	r3, #0
   81712:	e1d0      	b.n	81ab6 <udc_process_setup+0x41e>
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
   81714:	2a02      	cmp	r2, #2
   81716:	d1d4      	bne.n	816c2 <udc_process_setup+0x2a>
	udd_set_setup_payload( (uint8_t *) & udc_device_status,
   81718:	2102      	movs	r1, #2
   8171a:	4875      	ldr	r0, [pc, #468]	; (818f0 <udc_process_setup+0x258>)
   8171c:	4b75      	ldr	r3, [pc, #468]	; (818f4 <udc_process_setup+0x25c>)
   8171e:	4798      	blx	r3
   81720:	e121      	b.n	81966 <udc_process_setup+0x2ce>
	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
   81722:	4b72      	ldr	r3, [pc, #456]	; (818ec <udc_process_setup+0x254>)
   81724:	885a      	ldrh	r2, [r3, #2]
   81726:	b2d4      	uxtb	r4, r2
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
   81728:	0a13      	lsrs	r3, r2, #8
   8172a:	3b01      	subs	r3, #1
   8172c:	2b0e      	cmp	r3, #14
   8172e:	f200 8211 	bhi.w	81b54 <udc_process_setup+0x4bc>
   81732:	e8df f013 	tbh	[pc, r3, lsl #1]
   81736:	000f      	.short	0x000f
   81738:	0079001e 	.word	0x0079001e
   8173c:	020f020f 	.word	0x020f020f
   81740:	004d003f 	.word	0x004d003f
   81744:	020f020f 	.word	0x020f020f
   81748:	020f020f 	.word	0x020f020f
   8174c:	020f020f 	.word	0x020f020f
   81750:	0070020f 	.word	0x0070020f
		if (!udd_is_high_speed()) {
   81754:	4b68      	ldr	r3, [pc, #416]	; (818f8 <udc_process_setup+0x260>)
   81756:	4798      	blx	r3
   81758:	b928      	cbnz	r0, 81766 <udc_process_setup+0xce>
				(uint8_t *) udc_config.confdev_hs,
   8175a:	4b68      	ldr	r3, [pc, #416]	; (818fc <udc_process_setup+0x264>)
   8175c:	6898      	ldr	r0, [r3, #8]
			udd_set_setup_payload(
   8175e:	7801      	ldrb	r1, [r0, #0]
   81760:	4b64      	ldr	r3, [pc, #400]	; (818f4 <udc_process_setup+0x25c>)
   81762:	4798      	blx	r3
   81764:	e02b      	b.n	817be <udc_process_setup+0x126>
				(uint8_t *) udc_config.confdev_lsfs,
   81766:	4b65      	ldr	r3, [pc, #404]	; (818fc <udc_process_setup+0x264>)
   81768:	6818      	ldr	r0, [r3, #0]
			udd_set_setup_payload(
   8176a:	7801      	ldrb	r1, [r0, #0]
   8176c:	4b61      	ldr	r3, [pc, #388]	; (818f4 <udc_process_setup+0x25c>)
   8176e:	4798      	blx	r3
   81770:	e025      	b.n	817be <udc_process_setup+0x126>
		if (udd_is_high_speed()) {
   81772:	4b61      	ldr	r3, [pc, #388]	; (818f8 <udc_process_setup+0x260>)
   81774:	4798      	blx	r3
   81776:	b180      	cbz	r0, 8179a <udc_process_setup+0x102>
			if (conf_num >= udc_config.confdev_hs->
   81778:	4b60      	ldr	r3, [pc, #384]	; (818fc <udc_process_setup+0x264>)
   8177a:	689b      	ldr	r3, [r3, #8]
   8177c:	7c5b      	ldrb	r3, [r3, #17]
   8177e:	42a3      	cmp	r3, r4
   81780:	d998      	bls.n	816b4 <udc_process_setup+0x1c>
				(uint8_t *)udc_config.conf_hs[conf_num].desc,
   81782:	4b5e      	ldr	r3, [pc, #376]	; (818fc <udc_process_setup+0x264>)
   81784:	691b      	ldr	r3, [r3, #16]
   81786:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
			udd_set_setup_payload(
   8178a:	8841      	ldrh	r1, [r0, #2]
   8178c:	4b59      	ldr	r3, [pc, #356]	; (818f4 <udc_process_setup+0x25c>)
   8178e:	4798      	blx	r3
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
   81790:	4b56      	ldr	r3, [pc, #344]	; (818ec <udc_process_setup+0x254>)
   81792:	689b      	ldr	r3, [r3, #8]
   81794:	2202      	movs	r2, #2
   81796:	705a      	strb	r2, [r3, #1]
   81798:	e011      	b.n	817be <udc_process_setup+0x126>
			if (conf_num >= udc_config.confdev_lsfs->
   8179a:	4b58      	ldr	r3, [pc, #352]	; (818fc <udc_process_setup+0x264>)
   8179c:	681b      	ldr	r3, [r3, #0]
   8179e:	7c5b      	ldrb	r3, [r3, #17]
   817a0:	42a3      	cmp	r3, r4
   817a2:	d987      	bls.n	816b4 <udc_process_setup+0x1c>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
   817a4:	4b55      	ldr	r3, [pc, #340]	; (818fc <udc_process_setup+0x264>)
   817a6:	685b      	ldr	r3, [r3, #4]
   817a8:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
			udd_set_setup_payload(
   817ac:	8841      	ldrh	r1, [r0, #2]
   817ae:	4b51      	ldr	r3, [pc, #324]	; (818f4 <udc_process_setup+0x25c>)
   817b0:	4798      	blx	r3
   817b2:	e7ed      	b.n	81790 <udc_process_setup+0xf8>
		udd_set_setup_payload( (uint8_t *) udc_config.qualifier,
   817b4:	4b51      	ldr	r3, [pc, #324]	; (818fc <udc_process_setup+0x264>)
   817b6:	68d8      	ldr	r0, [r3, #12]
   817b8:	7801      	ldrb	r1, [r0, #0]
   817ba:	4b4e      	ldr	r3, [pc, #312]	; (818f4 <udc_process_setup+0x25c>)
   817bc:	4798      	blx	r3
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
   817be:	4b4b      	ldr	r3, [pc, #300]	; (818ec <udc_process_setup+0x254>)
   817c0:	88da      	ldrh	r2, [r3, #6]
   817c2:	899b      	ldrh	r3, [r3, #12]
   817c4:	4293      	cmp	r3, r2
   817c6:	f240 80ce 	bls.w	81966 <udc_process_setup+0x2ce>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
   817ca:	4b48      	ldr	r3, [pc, #288]	; (818ec <udc_process_setup+0x254>)
   817cc:	819a      	strh	r2, [r3, #12]
   817ce:	e0ca      	b.n	81966 <udc_process_setup+0x2ce>
		if (!udd_is_high_speed()) {
   817d0:	4b49      	ldr	r3, [pc, #292]	; (818f8 <udc_process_setup+0x260>)
   817d2:	4798      	blx	r3
   817d4:	b988      	cbnz	r0, 817fa <udc_process_setup+0x162>
			if (conf_num >= udc_config.confdev_hs->
   817d6:	4b49      	ldr	r3, [pc, #292]	; (818fc <udc_process_setup+0x264>)
   817d8:	689b      	ldr	r3, [r3, #8]
   817da:	7c5b      	ldrb	r3, [r3, #17]
   817dc:	42a3      	cmp	r3, r4
   817de:	f67f af69 	bls.w	816b4 <udc_process_setup+0x1c>
				(uint8_t *)udc_config.conf_hs[conf_num].desc,
   817e2:	4b46      	ldr	r3, [pc, #280]	; (818fc <udc_process_setup+0x264>)
   817e4:	691b      	ldr	r3, [r3, #16]
   817e6:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
			udd_set_setup_payload(
   817ea:	8841      	ldrh	r1, [r0, #2]
   817ec:	4b41      	ldr	r3, [pc, #260]	; (818f4 <udc_process_setup+0x25c>)
   817ee:	4798      	blx	r3
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
   817f0:	4b3e      	ldr	r3, [pc, #248]	; (818ec <udc_process_setup+0x254>)
   817f2:	689b      	ldr	r3, [r3, #8]
   817f4:	2207      	movs	r2, #7
   817f6:	705a      	strb	r2, [r3, #1]
   817f8:	e7e1      	b.n	817be <udc_process_setup+0x126>
			if (conf_num >= udc_config.confdev_lsfs->
   817fa:	4b40      	ldr	r3, [pc, #256]	; (818fc <udc_process_setup+0x264>)
   817fc:	681b      	ldr	r3, [r3, #0]
   817fe:	7c5b      	ldrb	r3, [r3, #17]
   81800:	42a3      	cmp	r3, r4
   81802:	f67f af57 	bls.w	816b4 <udc_process_setup+0x1c>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
   81806:	4b3d      	ldr	r3, [pc, #244]	; (818fc <udc_process_setup+0x264>)
   81808:	685b      	ldr	r3, [r3, #4]
   8180a:	f853 0034 	ldr.w	r0, [r3, r4, lsl #3]
			udd_set_setup_payload(
   8180e:	8841      	ldrh	r1, [r0, #2]
   81810:	4b38      	ldr	r3, [pc, #224]	; (818f4 <udc_process_setup+0x25c>)
   81812:	4798      	blx	r3
   81814:	e7ec      	b.n	817f0 <udc_process_setup+0x158>
		if (udc_config.conf_bos == NULL) {
   81816:	4b39      	ldr	r3, [pc, #228]	; (818fc <udc_process_setup+0x264>)
   81818:	6958      	ldr	r0, [r3, #20]
   8181a:	2800      	cmp	r0, #0
   8181c:	f43f af51 	beq.w	816c2 <udc_process_setup+0x2a>
		udd_set_setup_payload( (uint8_t *) udc_config.conf_bos,
   81820:	8841      	ldrh	r1, [r0, #2]
   81822:	4b34      	ldr	r3, [pc, #208]	; (818f4 <udc_process_setup+0x25c>)
   81824:	4798      	blx	r3
   81826:	e7ca      	b.n	817be <udc_process_setup+0x126>
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
   81828:	b2d2      	uxtb	r2, r2
   8182a:	2a01      	cmp	r2, #1
   8182c:	d01c      	beq.n	81868 <udc_process_setup+0x1d0>
   8182e:	b1b2      	cbz	r2, 8185e <udc_process_setup+0x1c6>
   81830:	2a02      	cmp	r2, #2
   81832:	f47f af3f 	bne.w	816b4 <udc_process_setup+0x1c>
		str = udc_string_product_name;
   81836:	4a32      	ldr	r2, [pc, #200]	; (81900 <udc_process_setup+0x268>)
		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
   81838:	2111      	movs	r1, #17
   8183a:	3a01      	subs	r2, #1
   8183c:	4831      	ldr	r0, [pc, #196]	; (81904 <udc_process_setup+0x26c>)
   8183e:	2300      	movs	r3, #0
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
   81840:	f812 4f01 	ldrb.w	r4, [r2, #1]!
   81844:	f820 4b02 	strh.w	r4, [r0], #2
		for(i = 0; i < str_length; i++) {
   81848:	3301      	adds	r3, #1
   8184a:	b2db      	uxtb	r3, r3
   8184c:	428b      	cmp	r3, r1
   8184e:	d3f7      	bcc.n	81840 <udc_process_setup+0x1a8>
		udc_string_desc.header.bLength = 2 + (str_length) * 2;
   81850:	0049      	lsls	r1, r1, #1
   81852:	3102      	adds	r1, #2
   81854:	482c      	ldr	r0, [pc, #176]	; (81908 <udc_process_setup+0x270>)
   81856:	7001      	strb	r1, [r0, #0]
		udd_set_setup_payload(
   81858:	4b26      	ldr	r3, [pc, #152]	; (818f4 <udc_process_setup+0x25c>)
   8185a:	4798      	blx	r3
   8185c:	e7af      	b.n	817be <udc_process_setup+0x126>
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
   8185e:	2104      	movs	r1, #4
   81860:	482a      	ldr	r0, [pc, #168]	; (8190c <udc_process_setup+0x274>)
   81862:	4b24      	ldr	r3, [pc, #144]	; (818f4 <udc_process_setup+0x25c>)
   81864:	4798      	blx	r3
   81866:	e7aa      	b.n	817be <udc_process_setup+0x126>
		str = udc_string_manufacturer_name;
   81868:	4a29      	ldr	r2, [pc, #164]	; (81910 <udc_process_setup+0x278>)
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
   8186a:	2105      	movs	r1, #5
   8186c:	e7e5      	b.n	8183a <udc_process_setup+0x1a2>
	if (udd_g_ctrlreq.req.wLength != 1) {
   8186e:	2a01      	cmp	r2, #1
   81870:	f47f af27 	bne.w	816c2 <udc_process_setup+0x2a>
	udd_set_setup_payload(&udc_num_configuration,1);
   81874:	2101      	movs	r1, #1
   81876:	4827      	ldr	r0, [pc, #156]	; (81914 <udc_process_setup+0x27c>)
   81878:	4b1e      	ldr	r3, [pc, #120]	; (818f4 <udc_process_setup+0x25c>)
   8187a:	4798      	blx	r3
   8187c:	e073      	b.n	81966 <udc_process_setup+0x2ce>
			switch (udd_g_ctrlreq.req.bRequest) {
   8187e:	491b      	ldr	r1, [pc, #108]	; (818ec <udc_process_setup+0x254>)
   81880:	7849      	ldrb	r1, [r1, #1]
   81882:	290a      	cmp	r1, #10
   81884:	f47f af3d 	bne.w	81702 <udc_process_setup+0x6a>
	if (udd_g_ctrlreq.req.wLength != 1) {
   81888:	2a01      	cmp	r2, #1
   8188a:	f040 8122 	bne.w	81ad2 <udc_process_setup+0x43a>
	if (!udc_num_configuration) {
   8188e:	4b21      	ldr	r3, [pc, #132]	; (81914 <udc_process_setup+0x27c>)
   81890:	781b      	ldrb	r3, [r3, #0]
   81892:	2b00      	cmp	r3, #0
   81894:	f000 811d 	beq.w	81ad2 <udc_process_setup+0x43a>
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   81898:	4b14      	ldr	r3, [pc, #80]	; (818ec <udc_process_setup+0x254>)
   8189a:	791c      	ldrb	r4, [r3, #4]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   8189c:	4b1e      	ldr	r3, [pc, #120]	; (81918 <udc_process_setup+0x280>)
   8189e:	681d      	ldr	r5, [r3, #0]
   818a0:	682b      	ldr	r3, [r5, #0]
   818a2:	791b      	ldrb	r3, [r3, #4]
   818a4:	42a3      	cmp	r3, r4
   818a6:	f240 8114 	bls.w	81ad2 <udc_process_setup+0x43a>
	if (!udc_update_iface_desc(iface_num, 0)) {
   818aa:	2100      	movs	r1, #0
   818ac:	4620      	mov	r0, r4
   818ae:	4b1b      	ldr	r3, [pc, #108]	; (8191c <udc_process_setup+0x284>)
   818b0:	4798      	blx	r3
   818b2:	2800      	cmp	r0, #0
   818b4:	f43f aefe 	beq.w	816b4 <udc_process_setup+0x1c>
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   818b8:	686b      	ldr	r3, [r5, #4]
	udc_iface_setting = udi_api->getsetting();
   818ba:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   818be:	68db      	ldr	r3, [r3, #12]
   818c0:	4798      	blx	r3
   818c2:	4b17      	ldr	r3, [pc, #92]	; (81920 <udc_process_setup+0x288>)
   818c4:	7018      	strb	r0, [r3, #0]
	udd_set_setup_payload(&udc_iface_setting,1);
   818c6:	2101      	movs	r1, #1
   818c8:	4618      	mov	r0, r3
   818ca:	4b0a      	ldr	r3, [pc, #40]	; (818f4 <udc_process_setup+0x25c>)
   818cc:	4798      	blx	r3
   818ce:	e04a      	b.n	81966 <udc_process_setup+0x2ce>
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
   818d0:	2a02      	cmp	r2, #2
   818d2:	f47f aef6 	bne.w	816c2 <udc_process_setup+0x2a>
	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
   818d6:	4b05      	ldr	r3, [pc, #20]	; (818ec <udc_process_setup+0x254>)
   818d8:	7918      	ldrb	r0, [r3, #4]
   818da:	4b12      	ldr	r3, [pc, #72]	; (81924 <udc_process_setup+0x28c>)
   818dc:	4798      	blx	r3
   818de:	4b12      	ldr	r3, [pc, #72]	; (81928 <udc_process_setup+0x290>)
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;
   818e0:	8018      	strh	r0, [r3, #0]
	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
   818e2:	2102      	movs	r1, #2
   818e4:	4618      	mov	r0, r3
   818e6:	4b03      	ldr	r3, [pc, #12]	; (818f4 <udc_process_setup+0x25c>)
   818e8:	4798      	blx	r3
   818ea:	e03c      	b.n	81966 <udc_process_setup+0x2ce>
   818ec:	20075364 	.word	0x20075364
   818f0:	2007102e 	.word	0x2007102e
   818f4:	00082ca9 	.word	0x00082ca9
   818f8:	00082c3d 	.word	0x00082c3d
   818fc:	20070154 	.word	0x20070154
   81900:	2007025c 	.word	0x2007025c
   81904:	2007022e 	.word	0x2007022e
   81908:	2007022c 	.word	0x2007022c
   8190c:	20070250 	.word	0x20070250
   81910:	20070254 	.word	0x20070254
   81914:	20071038 	.word	0x20071038
   81918:	2007103c 	.word	0x2007103c
   8191c:	000814d5 	.word	0x000814d5
   81920:	20071034 	.word	0x20071034
   81924:	00082d11 	.word	0x00082d11
   81928:	20071030 	.word	0x20071030
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
   8192c:	f013 031f 	ands.w	r3, r3, #31
   81930:	f040 80b5 	bne.w	81a9e <udc_process_setup+0x406>
			switch (udd_g_ctrlreq.req.bRequest) {
   81934:	4a8a      	ldr	r2, [pc, #552]	; (81b60 <udc_process_setup+0x4c8>)
   81936:	7852      	ldrb	r2, [r2, #1]
   81938:	3a01      	subs	r2, #1
   8193a:	2a08      	cmp	r2, #8
   8193c:	f200 80af 	bhi.w	81a9e <udc_process_setup+0x406>
   81940:	e8df f012 	tbh	[pc, r2, lsl #1]
   81944:	00ad0013 	.word	0x00ad0013
   81948:	00ad0023 	.word	0x00ad0023
   8194c:	00ad0009 	.word	0x00ad0009
   81950:	00ad00ad 	.word	0x00ad00ad
   81954:	0054      	.short	0x0054
	if (udd_g_ctrlreq.req.wLength) {
   81956:	4b82      	ldr	r3, [pc, #520]	; (81b60 <udc_process_setup+0x4c8>)
   81958:	88db      	ldrh	r3, [r3, #6]
   8195a:	2b00      	cmp	r3, #0
   8195c:	f47f aeb1 	bne.w	816c2 <udc_process_setup+0x2a>
	udd_g_ctrlreq.callback = udc_valid_address;
   81960:	4a80      	ldr	r2, [pc, #512]	; (81b64 <udc_process_setup+0x4cc>)
   81962:	4b7f      	ldr	r3, [pc, #508]	; (81b60 <udc_process_setup+0x4c8>)
   81964:	611a      	str	r2, [r3, #16]
			return true;
   81966:	2301      	movs	r3, #1
   81968:	e6b3      	b.n	816d2 <udc_process_setup+0x3a>
	if (udd_g_ctrlreq.req.wLength) {
   8196a:	4b7d      	ldr	r3, [pc, #500]	; (81b60 <udc_process_setup+0x4c8>)
   8196c:	88db      	ldrh	r3, [r3, #6]
   8196e:	2b00      	cmp	r3, #0
   81970:	f47f aea7 	bne.w	816c2 <udc_process_setup+0x2a>
	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
   81974:	4b7a      	ldr	r3, [pc, #488]	; (81b60 <udc_process_setup+0x4c8>)
   81976:	885b      	ldrh	r3, [r3, #2]
   81978:	2b01      	cmp	r3, #1
   8197a:	f47f aea2 	bne.w	816c2 <udc_process_setup+0x2a>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
   8197e:	4a7a      	ldr	r2, [pc, #488]	; (81b68 <udc_process_setup+0x4d0>)
   81980:	8813      	ldrh	r3, [r2, #0]
   81982:	f023 0302 	bic.w	r3, r3, #2
   81986:	8013      	strh	r3, [r2, #0]
   81988:	e7ed      	b.n	81966 <udc_process_setup+0x2ce>
	if (udd_g_ctrlreq.req.wLength) {
   8198a:	4b75      	ldr	r3, [pc, #468]	; (81b60 <udc_process_setup+0x4c8>)
   8198c:	88db      	ldrh	r3, [r3, #6]
   8198e:	2b00      	cmp	r3, #0
   81990:	f47f ae97 	bne.w	816c2 <udc_process_setup+0x2a>
	switch (udd_g_ctrlreq.req.wValue) {
   81994:	4b72      	ldr	r3, [pc, #456]	; (81b60 <udc_process_setup+0x4c8>)
   81996:	885b      	ldrh	r3, [r3, #2]
   81998:	2b02      	cmp	r3, #2
   8199a:	f040 80dd 	bne.w	81b58 <udc_process_setup+0x4c0>
		if (!udd_is_high_speed()) {
   8199e:	4b73      	ldr	r3, [pc, #460]	; (81b6c <udc_process_setup+0x4d4>)
   819a0:	4798      	blx	r3
   819a2:	2800      	cmp	r0, #0
   819a4:	f43f ae86 	beq.w	816b4 <udc_process_setup+0x1c>
		if (udd_g_ctrlreq.req.wIndex & 0xff) {
   819a8:	4b6d      	ldr	r3, [pc, #436]	; (81b60 <udc_process_setup+0x4c8>)
   819aa:	791b      	ldrb	r3, [r3, #4]
   819ac:	2b00      	cmp	r3, #0
   819ae:	f47f ae81 	bne.w	816b4 <udc_process_setup+0x1c>
		udc_reset();
   819b2:	4b6f      	ldr	r3, [pc, #444]	; (81b70 <udc_process_setup+0x4d8>)
   819b4:	4798      	blx	r3
		switch ((udd_g_ctrlreq.req.wIndex >> 8) & 0xFF) {
   819b6:	4b6a      	ldr	r3, [pc, #424]	; (81b60 <udc_process_setup+0x4c8>)
   819b8:	889b      	ldrh	r3, [r3, #4]
   819ba:	0a1b      	lsrs	r3, r3, #8
   819bc:	3b01      	subs	r3, #1
   819be:	2b03      	cmp	r3, #3
   819c0:	f200 80cc 	bhi.w	81b5c <udc_process_setup+0x4c4>
   819c4:	e8df f003 	tbb	[pc, r3]
   819c8:	0e0a0602 	.word	0x0e0a0602
			udd_g_ctrlreq.callback = udd_test_mode_j;
   819cc:	4a69      	ldr	r2, [pc, #420]	; (81b74 <udc_process_setup+0x4dc>)
   819ce:	4b64      	ldr	r3, [pc, #400]	; (81b60 <udc_process_setup+0x4c8>)
   819d0:	611a      	str	r2, [r3, #16]
   819d2:	e7c8      	b.n	81966 <udc_process_setup+0x2ce>
			udd_g_ctrlreq.callback = udd_test_mode_k;
   819d4:	4a68      	ldr	r2, [pc, #416]	; (81b78 <udc_process_setup+0x4e0>)
   819d6:	4b62      	ldr	r3, [pc, #392]	; (81b60 <udc_process_setup+0x4c8>)
   819d8:	611a      	str	r2, [r3, #16]
   819da:	e7c4      	b.n	81966 <udc_process_setup+0x2ce>
			udd_g_ctrlreq.callback = udd_test_mode_se0_nak;
   819dc:	4a67      	ldr	r2, [pc, #412]	; (81b7c <udc_process_setup+0x4e4>)
   819de:	4b60      	ldr	r3, [pc, #384]	; (81b60 <udc_process_setup+0x4c8>)
   819e0:	611a      	str	r2, [r3, #16]
   819e2:	e7c0      	b.n	81966 <udc_process_setup+0x2ce>
			udd_g_ctrlreq.callback = udd_test_mode_packet;
   819e4:	4a66      	ldr	r2, [pc, #408]	; (81b80 <udc_process_setup+0x4e8>)
   819e6:	4b5e      	ldr	r3, [pc, #376]	; (81b60 <udc_process_setup+0x4c8>)
   819e8:	611a      	str	r2, [r3, #16]
   819ea:	e7bc      	b.n	81966 <udc_process_setup+0x2ce>
	if (udd_g_ctrlreq.req.wLength) {
   819ec:	4b5c      	ldr	r3, [pc, #368]	; (81b60 <udc_process_setup+0x4c8>)
   819ee:	88db      	ldrh	r3, [r3, #6]
   819f0:	2b00      	cmp	r3, #0
   819f2:	f47f ae66 	bne.w	816c2 <udc_process_setup+0x2a>
	if (!udd_getaddress()) {
   819f6:	4b63      	ldr	r3, [pc, #396]	; (81b84 <udc_process_setup+0x4ec>)
   819f8:	4798      	blx	r3
   819fa:	2800      	cmp	r0, #0
   819fc:	f43f ae5a 	beq.w	816b4 <udc_process_setup+0x1c>
	if (udd_is_high_speed()) {
   81a00:	4b5a      	ldr	r3, [pc, #360]	; (81b6c <udc_process_setup+0x4d4>)
   81a02:	4798      	blx	r3
   81a04:	2800      	cmp	r0, #0
   81a06:	d036      	beq.n	81a76 <udc_process_setup+0x3de>
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   81a08:	4b55      	ldr	r3, [pc, #340]	; (81b60 <udc_process_setup+0x4c8>)
   81a0a:	789a      	ldrb	r2, [r3, #2]
				udc_config.confdev_hs->bNumConfigurations) {
   81a0c:	4b5e      	ldr	r3, [pc, #376]	; (81b88 <udc_process_setup+0x4f0>)
   81a0e:	689b      	ldr	r3, [r3, #8]
   81a10:	7c5b      	ldrb	r3, [r3, #17]
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   81a12:	429a      	cmp	r2, r3
   81a14:	f73f ae4e 	bgt.w	816b4 <udc_process_setup+0x1c>
	udc_reset();
   81a18:	4b55      	ldr	r3, [pc, #340]	; (81b70 <udc_process_setup+0x4d8>)
   81a1a:	4798      	blx	r3
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
   81a1c:	4b50      	ldr	r3, [pc, #320]	; (81b60 <udc_process_setup+0x4c8>)
   81a1e:	789b      	ldrb	r3, [r3, #2]
   81a20:	4a5a      	ldr	r2, [pc, #360]	; (81b8c <udc_process_setup+0x4f4>)
   81a22:	7013      	strb	r3, [r2, #0]
	if (udc_num_configuration == 0) {
   81a24:	2b00      	cmp	r3, #0
   81a26:	d09e      	beq.n	81966 <udc_process_setup+0x2ce>
	if (udd_is_high_speed()) {
   81a28:	4b50      	ldr	r3, [pc, #320]	; (81b6c <udc_process_setup+0x4d4>)
   81a2a:	4798      	blx	r3
   81a2c:	2800      	cmp	r0, #0
   81a2e:	d02a      	beq.n	81a86 <udc_process_setup+0x3ee>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
   81a30:	4b56      	ldr	r3, [pc, #344]	; (81b8c <udc_process_setup+0x4f4>)
   81a32:	781b      	ldrb	r3, [r3, #0]
   81a34:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   81a38:	3b01      	subs	r3, #1
   81a3a:	4a53      	ldr	r2, [pc, #332]	; (81b88 <udc_process_setup+0x4f0>)
   81a3c:	6912      	ldr	r2, [r2, #16]
   81a3e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   81a42:	4a53      	ldr	r2, [pc, #332]	; (81b90 <udc_process_setup+0x4f8>)
   81a44:	6013      	str	r3, [r2, #0]
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81a46:	4b52      	ldr	r3, [pc, #328]	; (81b90 <udc_process_setup+0x4f8>)
   81a48:	681b      	ldr	r3, [r3, #0]
   81a4a:	681b      	ldr	r3, [r3, #0]
   81a4c:	791b      	ldrb	r3, [r3, #4]
   81a4e:	2b00      	cmp	r3, #0
   81a50:	d089      	beq.n	81966 <udc_process_setup+0x2ce>
   81a52:	2400      	movs	r4, #0
		if (!udc_iface_enable(iface_num, 0)) {
   81a54:	4626      	mov	r6, r4
   81a56:	4d4f      	ldr	r5, [pc, #316]	; (81b94 <udc_process_setup+0x4fc>)
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81a58:	4f4d      	ldr	r7, [pc, #308]	; (81b90 <udc_process_setup+0x4f8>)
		if (!udc_iface_enable(iface_num, 0)) {
   81a5a:	4631      	mov	r1, r6
   81a5c:	4620      	mov	r0, r4
   81a5e:	47a8      	blx	r5
   81a60:	2800      	cmp	r0, #0
   81a62:	f43f ae27 	beq.w	816b4 <udc_process_setup+0x1c>
			iface_num++) {
   81a66:	3401      	adds	r4, #1
   81a68:	b2e4      	uxtb	r4, r4
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81a6a:	683b      	ldr	r3, [r7, #0]
   81a6c:	681b      	ldr	r3, [r3, #0]
   81a6e:	791b      	ldrb	r3, [r3, #4]
   81a70:	42a3      	cmp	r3, r4
   81a72:	d8f2      	bhi.n	81a5a <udc_process_setup+0x3c2>
   81a74:	e777      	b.n	81966 <udc_process_setup+0x2ce>
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   81a76:	4b3a      	ldr	r3, [pc, #232]	; (81b60 <udc_process_setup+0x4c8>)
   81a78:	789a      	ldrb	r2, [r3, #2]
				udc_config.confdev_lsfs->bNumConfigurations) {
   81a7a:	4b43      	ldr	r3, [pc, #268]	; (81b88 <udc_process_setup+0x4f0>)
   81a7c:	681b      	ldr	r3, [r3, #0]
   81a7e:	7c5b      	ldrb	r3, [r3, #17]
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
   81a80:	429a      	cmp	r2, r3
   81a82:	ddc9      	ble.n	81a18 <udc_process_setup+0x380>
   81a84:	e616      	b.n	816b4 <udc_process_setup+0x1c>
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
   81a86:	4b41      	ldr	r3, [pc, #260]	; (81b8c <udc_process_setup+0x4f4>)
   81a88:	781b      	ldrb	r3, [r3, #0]
   81a8a:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
   81a8e:	3b01      	subs	r3, #1
   81a90:	4a3d      	ldr	r2, [pc, #244]	; (81b88 <udc_process_setup+0x4f0>)
   81a92:	6852      	ldr	r2, [r2, #4]
   81a94:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   81a98:	4a3d      	ldr	r2, [pc, #244]	; (81b90 <udc_process_setup+0x4f8>)
   81a9a:	6013      	str	r3, [r2, #0]
   81a9c:	e7d3      	b.n	81a46 <udc_process_setup+0x3ae>
		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
   81a9e:	2b01      	cmp	r3, #1
   81aa0:	d00d      	beq.n	81abe <udc_process_setup+0x426>
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
   81aa2:	2b02      	cmp	r3, #2
   81aa4:	f47f ae06 	bne.w	816b4 <udc_process_setup+0x1c>
			switch (udd_g_ctrlreq.req.bRequest) {
   81aa8:	4b2d      	ldr	r3, [pc, #180]	; (81b60 <udc_process_setup+0x4c8>)
   81aaa:	785b      	ldrb	r3, [r3, #1]
   81aac:	2b01      	cmp	r3, #1
   81aae:	d02e      	beq.n	81b0e <udc_process_setup+0x476>
   81ab0:	2b03      	cmp	r3, #3
   81ab2:	d03c      	beq.n	81b2e <udc_process_setup+0x496>
	return false;
   81ab4:	2300      	movs	r3, #0
		if (udc_reqstd()) {
   81ab6:	2b00      	cmp	r3, #0
   81ab8:	f47f ae0b 	bne.w	816d2 <udc_process_setup+0x3a>
   81abc:	e5fa      	b.n	816b4 <udc_process_setup+0x1c>
			switch (udd_g_ctrlreq.req.bRequest) {
   81abe:	4a28      	ldr	r2, [pc, #160]	; (81b60 <udc_process_setup+0x4c8>)
   81ac0:	7852      	ldrb	r2, [r2, #1]
   81ac2:	2a0b      	cmp	r2, #11
   81ac4:	d1ed      	bne.n	81aa2 <udc_process_setup+0x40a>
	if (udd_g_ctrlreq.req.wLength) {
   81ac6:	4b26      	ldr	r3, [pc, #152]	; (81b60 <udc_process_setup+0x4c8>)
   81ac8:	88db      	ldrh	r3, [r3, #6]
   81aca:	b913      	cbnz	r3, 81ad2 <udc_process_setup+0x43a>
	if (!udc_num_configuration) {
   81acc:	4b2f      	ldr	r3, [pc, #188]	; (81b8c <udc_process_setup+0x4f4>)
   81ace:	781b      	ldrb	r3, [r3, #0]
   81ad0:	b973      	cbnz	r3, 81af0 <udc_process_setup+0x458>
	if (0 == udc_num_configuration) {
   81ad2:	4b2e      	ldr	r3, [pc, #184]	; (81b8c <udc_process_setup+0x4f4>)
   81ad4:	781b      	ldrb	r3, [r3, #0]
   81ad6:	2b00      	cmp	r3, #0
   81ad8:	f000 80ab 	beq.w	81c32 <udc_process_setup+0x59a>
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   81adc:	4b20      	ldr	r3, [pc, #128]	; (81b60 <udc_process_setup+0x4c8>)
   81ade:	791c      	ldrb	r4, [r3, #4]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
   81ae0:	4b2b      	ldr	r3, [pc, #172]	; (81b90 <udc_process_setup+0x4f8>)
   81ae2:	681d      	ldr	r5, [r3, #0]
   81ae4:	682b      	ldr	r3, [r5, #0]
   81ae6:	791b      	ldrb	r3, [r3, #4]
   81ae8:	42a3      	cmp	r3, r4
   81aea:	d85d      	bhi.n	81ba8 <udc_process_setup+0x510>
	return false;
   81aec:	2300      	movs	r3, #0
   81aee:	e5f0      	b.n	816d2 <udc_process_setup+0x3a>
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
   81af0:	4b1b      	ldr	r3, [pc, #108]	; (81b60 <udc_process_setup+0x4c8>)
   81af2:	791c      	ldrb	r4, [r3, #4]
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
   81af4:	885d      	ldrh	r5, [r3, #2]
	if (!udc_iface_disable(iface_num)) {
   81af6:	4620      	mov	r0, r4
   81af8:	4b27      	ldr	r3, [pc, #156]	; (81b98 <udc_process_setup+0x500>)
   81afa:	4798      	blx	r3
   81afc:	2800      	cmp	r0, #0
   81afe:	f43f add9 	beq.w	816b4 <udc_process_setup+0x1c>
	return udc_iface_enable(iface_num, setting_num);
   81b02:	b2e9      	uxtb	r1, r5
   81b04:	4620      	mov	r0, r4
   81b06:	4b23      	ldr	r3, [pc, #140]	; (81b94 <udc_process_setup+0x4fc>)
   81b08:	4798      	blx	r3
   81b0a:	4603      	mov	r3, r0
   81b0c:	e7d3      	b.n	81ab6 <udc_process_setup+0x41e>
	if (udd_g_ctrlreq.req.wLength) {
   81b0e:	4b14      	ldr	r3, [pc, #80]	; (81b60 <udc_process_setup+0x4c8>)
   81b10:	88db      	ldrh	r3, [r3, #6]
   81b12:	2b00      	cmp	r3, #0
   81b14:	f47f add5 	bne.w	816c2 <udc_process_setup+0x2a>
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
   81b18:	4b11      	ldr	r3, [pc, #68]	; (81b60 <udc_process_setup+0x4c8>)
   81b1a:	885b      	ldrh	r3, [r3, #2]
   81b1c:	2b00      	cmp	r3, #0
   81b1e:	f47f add0 	bne.w	816c2 <udc_process_setup+0x2a>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
   81b22:	4b0f      	ldr	r3, [pc, #60]	; (81b60 <udc_process_setup+0x4c8>)
   81b24:	7918      	ldrb	r0, [r3, #4]
   81b26:	4b1d      	ldr	r3, [pc, #116]	; (81b9c <udc_process_setup+0x504>)
   81b28:	4798      	blx	r3
   81b2a:	4603      	mov	r3, r0
   81b2c:	e7c3      	b.n	81ab6 <udc_process_setup+0x41e>
	if (udd_g_ctrlreq.req.wLength) {
   81b2e:	4b0c      	ldr	r3, [pc, #48]	; (81b60 <udc_process_setup+0x4c8>)
   81b30:	88db      	ldrh	r3, [r3, #6]
   81b32:	2b00      	cmp	r3, #0
   81b34:	f47f adc5 	bne.w	816c2 <udc_process_setup+0x2a>
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
   81b38:	4b09      	ldr	r3, [pc, #36]	; (81b60 <udc_process_setup+0x4c8>)
   81b3a:	885b      	ldrh	r3, [r3, #2]
   81b3c:	2b00      	cmp	r3, #0
   81b3e:	f47f adc0 	bne.w	816c2 <udc_process_setup+0x2a>
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
   81b42:	4c07      	ldr	r4, [pc, #28]	; (81b60 <udc_process_setup+0x4c8>)
   81b44:	7920      	ldrb	r0, [r4, #4]
   81b46:	4b16      	ldr	r3, [pc, #88]	; (81ba0 <udc_process_setup+0x508>)
   81b48:	4798      	blx	r3
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
   81b4a:	7920      	ldrb	r0, [r4, #4]
   81b4c:	4b15      	ldr	r3, [pc, #84]	; (81ba4 <udc_process_setup+0x50c>)
   81b4e:	4798      	blx	r3
   81b50:	4603      	mov	r3, r0
   81b52:	e7b0      	b.n	81ab6 <udc_process_setup+0x41e>
		return false;
   81b54:	2300      	movs	r3, #0
   81b56:	e7ae      	b.n	81ab6 <udc_process_setup+0x41e>
		return false;
   81b58:	2300      	movs	r3, #0
   81b5a:	e7ac      	b.n	81ab6 <udc_process_setup+0x41e>
	return false;
   81b5c:	2300      	movs	r3, #0
   81b5e:	e7aa      	b.n	81ab6 <udc_process_setup+0x41e>
   81b60:	20075364 	.word	0x20075364
   81b64:	000814bd 	.word	0x000814bd
   81b68:	2007102e 	.word	0x2007102e
   81b6c:	00082c3d 	.word	0x00082c3d
   81b70:	00081611 	.word	0x00081611
   81b74:	00083275 	.word	0x00083275
   81b78:	00083291 	.word	0x00083291
   81b7c:	000832ad 	.word	0x000832ad
   81b80:	000832c1 	.word	0x000832c1
   81b84:	00082c79 	.word	0x00082c79
   81b88:	20070154 	.word	0x20070154
   81b8c:	20071038 	.word	0x20071038
   81b90:	2007103c 	.word	0x2007103c
   81b94:	000815b5 	.word	0x000815b5
   81b98:	00081549 	.word	0x00081549
   81b9c:	00082e25 	.word	0x00082e25
   81ba0:	000831f5 	.word	0x000831f5
   81ba4:	00082d25 	.word	0x00082d25
	if (!udc_update_iface_desc(iface_num, 0)) {
   81ba8:	2100      	movs	r1, #0
   81baa:	4620      	mov	r0, r4
   81bac:	4b22      	ldr	r3, [pc, #136]	; (81c38 <udc_process_setup+0x5a0>)
   81bae:	4798      	blx	r3
   81bb0:	2800      	cmp	r0, #0
   81bb2:	f43f ad86 	beq.w	816c2 <udc_process_setup+0x2a>
	udi_api = udc_ptr_conf->udi_apis[iface_num];
   81bb6:	686b      	ldr	r3, [r5, #4]
   81bb8:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   81bbc:	68eb      	ldr	r3, [r5, #12]
   81bbe:	4798      	blx	r3
   81bc0:	4601      	mov	r1, r0
   81bc2:	4620      	mov	r0, r4
   81bc4:	4b1c      	ldr	r3, [pc, #112]	; (81c38 <udc_process_setup+0x5a0>)
   81bc6:	4798      	blx	r3
   81bc8:	2800      	cmp	r0, #0
   81bca:	f43f ad7a 	beq.w	816c2 <udc_process_setup+0x2a>
	return udi_api->setup();
   81bce:	68ab      	ldr	r3, [r5, #8]
   81bd0:	4798      	blx	r3
		if (udc_req_iface()) {
   81bd2:	4603      	mov	r3, r0
   81bd4:	2800      	cmp	r0, #0
   81bd6:	f47f ad7c 	bne.w	816d2 <udc_process_setup+0x3a>
   81bda:	e572      	b.n	816c2 <udc_process_setup+0x2a>
	if (0 == udc_num_configuration) {
   81bdc:	4b17      	ldr	r3, [pc, #92]	; (81c3c <udc_process_setup+0x5a4>)
   81bde:	781b      	ldrb	r3, [r3, #0]
   81be0:	b30b      	cbz	r3, 81c26 <udc_process_setup+0x58e>
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81be2:	4b17      	ldr	r3, [pc, #92]	; (81c40 <udc_process_setup+0x5a8>)
   81be4:	681a      	ldr	r2, [r3, #0]
   81be6:	6813      	ldr	r3, [r2, #0]
   81be8:	791b      	ldrb	r3, [r3, #4]
   81bea:	b1f3      	cbz	r3, 81c2a <udc_process_setup+0x592>
   81bec:	2400      	movs	r4, #0
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   81bee:	4e12      	ldr	r6, [pc, #72]	; (81c38 <udc_process_setup+0x5a0>)
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81bf0:	4f13      	ldr	r7, [pc, #76]	; (81c40 <udc_process_setup+0x5a8>)
		udi_api = udc_ptr_conf->udi_apis[iface_num];
   81bf2:	6853      	ldr	r3, [r2, #4]
   81bf4:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
   81bf8:	68eb      	ldr	r3, [r5, #12]
   81bfa:	4798      	blx	r3
   81bfc:	4601      	mov	r1, r0
   81bfe:	4620      	mov	r0, r4
   81c00:	47b0      	blx	r6
   81c02:	4603      	mov	r3, r0
   81c04:	2800      	cmp	r0, #0
   81c06:	f43f ad64 	beq.w	816d2 <udc_process_setup+0x3a>
		if (udi_api->setup()) {
   81c0a:	68ab      	ldr	r3, [r5, #8]
   81c0c:	4798      	blx	r3
   81c0e:	4603      	mov	r3, r0
   81c10:	2800      	cmp	r0, #0
   81c12:	f47f ad5e 	bne.w	816d2 <udc_process_setup+0x3a>
			iface_num++) {
   81c16:	3401      	adds	r4, #1
   81c18:	b2e4      	uxtb	r4, r4
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
   81c1a:	683a      	ldr	r2, [r7, #0]
   81c1c:	6811      	ldr	r1, [r2, #0]
   81c1e:	7909      	ldrb	r1, [r1, #4]
   81c20:	42a1      	cmp	r1, r4
   81c22:	d8e6      	bhi.n	81bf2 <udc_process_setup+0x55a>
   81c24:	e555      	b.n	816d2 <udc_process_setup+0x3a>
		return false; // The device is not is configured state yet
   81c26:	2300      	movs	r3, #0
   81c28:	e553      	b.n	816d2 <udc_process_setup+0x3a>
	return false;
   81c2a:	2300      	movs	r3, #0
   81c2c:	e551      	b.n	816d2 <udc_process_setup+0x3a>
			return false; // Error from USB host
   81c2e:	2300      	movs	r3, #0
   81c30:	e54f      	b.n	816d2 <udc_process_setup+0x3a>
	return false;
   81c32:	2300      	movs	r3, #0
   81c34:	e54d      	b.n	816d2 <udc_process_setup+0x3a>
   81c36:	bf00      	nop
   81c38:	000814d5 	.word	0x000814d5
   81c3c:	20071038 	.word	0x20071038
   81c40:	2007103c 	.word	0x2007103c

00081c44 <board_init>:
#include "conf_board.h"
#include "gpio.h"
#include "ioport.h"

void board_init(void)
{
   81c44:	b510      	push	{r4, lr}
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
   81c46:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   81c4a:	4b1f      	ldr	r3, [pc, #124]	; (81cc8 <board_init+0x84>)
   81c4c:	605a      	str	r2, [r3, #4]
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
   81c4e:	200b      	movs	r0, #11
   81c50:	4c1e      	ldr	r4, [pc, #120]	; (81ccc <board_init+0x88>)
   81c52:	47a0      	blx	r4
   81c54:	200c      	movs	r0, #12
   81c56:	47a0      	blx	r4
   81c58:	200d      	movs	r0, #13
   81c5a:	47a0      	blx	r4
   81c5c:	200e      	movs	r0, #14
   81c5e:	47a0      	blx	r4
	 * In new designs IOPORT is used instead.
	 * Here IOPORT must be initialized for others to use before setting up IO.
	 */
	ioport_init();
	/* Configure LED pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
   81c60:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81c64:	203b      	movs	r0, #59	; 0x3b
   81c66:	4c1a      	ldr	r4, [pc, #104]	; (81cd0 <board_init+0x8c>)
   81c68:	47a0      	blx	r4
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
   81c6a:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81c6e:	2055      	movs	r0, #85	; 0x55
   81c70:	47a0      	blx	r4
	gpio_configure_pin(LED2_GPIO, LED2_FLAGS);
   81c72:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   81c76:	2056      	movs	r0, #86	; 0x56
   81c78:	47a0      	blx	r4

	/* Configure Push Button pins */
	gpio_configure_pin(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS);
   81c7a:	4916      	ldr	r1, [pc, #88]	; (81cd4 <board_init+0x90>)
   81c7c:	2068      	movs	r0, #104	; 0x68
   81c7e:	47a0      	blx	r4
	gpio_configure_pin(GPIO_PUSH_BUTTON_2, GPIO_PUSH_BUTTON_2_FLAGS);
   81c80:	4915      	ldr	r1, [pc, #84]	; (81cd8 <board_init+0x94>)
   81c82:	205c      	movs	r0, #92	; 0x5c
   81c84:	47a0      	blx	r4
	gpio_configure_pin(PIN_PWM_LED2_GPIO, PIN_PWM_LED2_FLAGS);
#endif

	/* Configure SPI0 pins */
#ifdef CONF_BOARD_SPI0
	gpio_configure_pin(SPI0_MISO_GPIO, SPI0_MISO_FLAGS);
   81c86:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81c8a:	2019      	movs	r0, #25
   81c8c:	47a0      	blx	r4
	gpio_configure_pin(SPI0_MOSI_GPIO, SPI0_MOSI_FLAGS);
   81c8e:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81c92:	201a      	movs	r0, #26
   81c94:	47a0      	blx	r4
	gpio_configure_pin(SPI0_SPCK_GPIO, SPI0_SPCK_FLAGS);
   81c96:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81c9a:	201b      	movs	r0, #27
   81c9c:	47a0      	blx	r4
	 * CONF_BOARD_SPI_NPCS_GPIO and
	 * CONF_BOARD_SPI_NPCS_FLAGS macros.
	 */

#   ifdef CONF_BOARD_SPI0_NPCS0
		gpio_configure_pin(SPI0_NPCS0_GPIO, SPI0_NPCS0_FLAGS);
   81c9e:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81ca2:	201c      	movs	r0, #28
   81ca4:	47a0      	blx	r4
		gpio_configure_pin(SPI1_NPCS3_GPIO, SPI1_NPCS3_FLAGS);
#   endif
#endif

#ifdef CONF_BOARD_TWI0
	gpio_configure_pin(TWI0_DATA_GPIO, TWI0_DATA_FLAGS);
   81ca6:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81caa:	2011      	movs	r0, #17
   81cac:	47a0      	blx	r4
	gpio_configure_pin(TWI0_CLK_GPIO, TWI0_CLK_FLAGS);
   81cae:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81cb2:	2012      	movs	r0, #18
   81cb4:	47a0      	blx	r4
	gpio_configure_pin(TWI1_CLK_GPIO, TWI1_CLK_FLAGS);
#endif

#ifdef CONF_BOARD_USART_RXD
	/* Configure USART RXD pin */
	gpio_configure_pin(PIN_USART0_RXD_IDX, PIN_USART0_RXD_FLAGS);
   81cb6:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81cba:	200a      	movs	r0, #10
   81cbc:	47a0      	blx	r4
#endif

#ifdef CONF_BOARD_USART_TXD
	/* Configure USART TXD pin */
	gpio_configure_pin(PIN_USART0_TXD_IDX, PIN_USART0_TXD_FLAGS);
   81cbe:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81cc2:	200b      	movs	r0, #11
   81cc4:	47a0      	blx	r4
   81cc6:	bd10      	pop	{r4, pc}
   81cc8:	400e1a50 	.word	0x400e1a50
   81ccc:	00082021 	.word	0x00082021
   81cd0:	00081dc9 	.word	0x00081dc9
   81cd4:	28000079 	.word	0x28000079
   81cd8:	28000001 	.word	0x28000001

00081cdc <pdc_tx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
   81cdc:	460b      	mov	r3, r1
   81cde:	b119      	cbz	r1, 81ce8 <pdc_tx_init+0xc>
		p_pdc->PERIPH_TPR = p_packet->ul_addr;
   81ce0:	6809      	ldr	r1, [r1, #0]
   81ce2:	6081      	str	r1, [r0, #8]
		p_pdc->PERIPH_TCR = p_packet->ul_size;
   81ce4:	685b      	ldr	r3, [r3, #4]
   81ce6:	60c3      	str	r3, [r0, #12]
	}
	if (p_next_packet) {
   81ce8:	b11a      	cbz	r2, 81cf2 <pdc_tx_init+0x16>
		p_pdc->PERIPH_TNPR = p_next_packet->ul_addr;
   81cea:	6813      	ldr	r3, [r2, #0]
   81cec:	6183      	str	r3, [r0, #24]
		p_pdc->PERIPH_TNCR = p_next_packet->ul_size;
   81cee:	6853      	ldr	r3, [r2, #4]
   81cf0:	61c3      	str	r3, [r0, #28]
   81cf2:	4770      	bx	lr

00081cf4 <pdc_rx_init>:
		pdc_packet_t *p_next_packet)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	if (p_packet) {
   81cf4:	460b      	mov	r3, r1
   81cf6:	b119      	cbz	r1, 81d00 <pdc_rx_init+0xc>
		p_pdc->PERIPH_RPR = p_packet->ul_addr;
   81cf8:	6809      	ldr	r1, [r1, #0]
   81cfa:	6001      	str	r1, [r0, #0]
		p_pdc->PERIPH_RCR = p_packet->ul_size;
   81cfc:	685b      	ldr	r3, [r3, #4]
   81cfe:	6043      	str	r3, [r0, #4]
	}
	if (p_next_packet) {
   81d00:	b11a      	cbz	r2, 81d0a <pdc_rx_init+0x16>
		p_pdc->PERIPH_RNPR = p_next_packet->ul_addr;
   81d02:	6813      	ldr	r3, [r2, #0]
   81d04:	6103      	str	r3, [r0, #16]
		p_pdc->PERIPH_RNCR = p_next_packet->ul_size;
   81d06:	6853      	ldr	r3, [r2, #4]
   81d08:	6143      	str	r3, [r0, #20]
   81d0a:	4770      	bx	lr

00081d0c <pdc_enable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTEN | PERIPH_PTCR_TXTEN);
   81d0c:	f021 01fe 	bic.w	r1, r1, #254	; 0xfe
   81d10:	05c9      	lsls	r1, r1, #23
   81d12:	0dc9      	lsrs	r1, r1, #23
	p_pdc->PERIPH_PTCR =
   81d14:	6201      	str	r1, [r0, #32]
   81d16:	4770      	bx	lr

00081d18 <pdc_disable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
   81d18:	f421 71fe 	bic.w	r1, r1, #508	; 0x1fc
   81d1c:	f021 0101 	bic.w	r1, r1, #1
   81d20:	0589      	lsls	r1, r1, #22
   81d22:	0d89      	lsrs	r1, r1, #22
	p_pdc->PERIPH_PTCR =
   81d24:	6201      	str	r1, [r0, #32]
   81d26:	4770      	bx	lr

00081d28 <pio_set_peripheral>:
		const uint32_t ul_mask)
{
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
   81d28:	6442      	str	r2, [r0, #68]	; 0x44
	case PIO_OUTPUT_1:
	case PIO_NOT_A_PIN:
		return;
	}
#elif (SAM3XA|| SAM3U)
	switch (ul_type) {
   81d2a:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
   81d2e:	d016      	beq.n	81d5e <pio_set_peripheral+0x36>
   81d30:	d80b      	bhi.n	81d4a <pio_set_peripheral+0x22>
   81d32:	b149      	cbz	r1, 81d48 <pio_set_peripheral+0x20>
   81d34:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
   81d38:	d105      	bne.n	81d46 <pio_set_peripheral+0x1e>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABSR;
   81d3a:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABSR &= (~ul_mask & ul_sr);
   81d3c:	6f01      	ldr	r1, [r0, #112]	; 0x70
   81d3e:	400b      	ands	r3, r1
   81d40:	ea23 0302 	bic.w	r3, r3, r2
   81d44:	6703      	str	r3, [r0, #112]	; 0x70
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
   81d46:	6042      	str	r2, [r0, #4]
   81d48:	4770      	bx	lr
	switch (ul_type) {
   81d4a:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
   81d4e:	d0fb      	beq.n	81d48 <pio_set_peripheral+0x20>
   81d50:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
   81d54:	d0f8      	beq.n	81d48 <pio_set_peripheral+0x20>
   81d56:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
   81d5a:	d1f4      	bne.n	81d46 <pio_set_peripheral+0x1e>
   81d5c:	4770      	bx	lr
		ul_sr = p_pio->PIO_ABSR;
   81d5e:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABSR = (ul_mask | ul_sr);
   81d60:	4313      	orrs	r3, r2
   81d62:	6703      	str	r3, [r0, #112]	; 0x70
		break;
   81d64:	e7ef      	b.n	81d46 <pio_set_peripheral+0x1e>

00081d66 <pio_set_input>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
   81d66:	6441      	str	r1, [r0, #68]	; 0x44
	if (ul_pull_up_enable) {
   81d68:	f012 0f01 	tst.w	r2, #1
		p_pio->PIO_PUER = ul_mask;
   81d6c:	bf14      	ite	ne
   81d6e:	6641      	strne	r1, [r0, #100]	; 0x64
		p_pio->PIO_PUDR = ul_mask;
   81d70:	6601      	streq	r1, [r0, #96]	; 0x60
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
   81d72:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
   81d76:	bf14      	ite	ne
   81d78:	6201      	strne	r1, [r0, #32]
		p_pio->PIO_IFDR = ul_mask;
   81d7a:	6241      	streq	r1, [r0, #36]	; 0x24
	if (ul_attribute & PIO_DEGLITCH) {
   81d7c:	f012 0f02 	tst.w	r2, #2
   81d80:	d107      	bne.n	81d92 <pio_set_input+0x2c>
		if (ul_attribute & PIO_DEBOUNCE) {
   81d82:	f012 0f08 	tst.w	r2, #8
			p_pio->PIO_DIFSR = ul_mask;
   81d86:	bf18      	it	ne
   81d88:	f8c0 1084 	strne.w	r1, [r0, #132]	; 0x84
	p_pio->PIO_ODR = ul_mask;
   81d8c:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
   81d8e:	6001      	str	r1, [r0, #0]
   81d90:	4770      	bx	lr
		p_pio->PIO_SCIFSR = ul_mask;
   81d92:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
   81d96:	e7f9      	b.n	81d8c <pio_set_input+0x26>

00081d98 <pio_set_output>:
{
   81d98:	b410      	push	{r4}
   81d9a:	9c01      	ldr	r4, [sp, #4]
	p_pio->PIO_IDR = ul_mask;
   81d9c:	6441      	str	r1, [r0, #68]	; 0x44
	if (ul_pull_up_enable) {
   81d9e:	b944      	cbnz	r4, 81db2 <pio_set_output+0x1a>
		p_pio->PIO_PUDR = ul_mask;
   81da0:	6601      	str	r1, [r0, #96]	; 0x60
	if (ul_multidrive_enable) {
   81da2:	b143      	cbz	r3, 81db6 <pio_set_output+0x1e>
		p_pio->PIO_MDER = ul_mask;
   81da4:	6501      	str	r1, [r0, #80]	; 0x50
	if (ul_default_level) {
   81da6:	b942      	cbnz	r2, 81dba <pio_set_output+0x22>
		p_pio->PIO_CODR = ul_mask;
   81da8:	6341      	str	r1, [r0, #52]	; 0x34
	p_pio->PIO_OER = ul_mask;
   81daa:	6101      	str	r1, [r0, #16]
	p_pio->PIO_PER = ul_mask;
   81dac:	6001      	str	r1, [r0, #0]
}
   81dae:	bc10      	pop	{r4}
   81db0:	4770      	bx	lr
		p_pio->PIO_PUER = ul_mask;
   81db2:	6641      	str	r1, [r0, #100]	; 0x64
   81db4:	e7f5      	b.n	81da2 <pio_set_output+0xa>
		p_pio->PIO_MDDR = ul_mask;
   81db6:	6541      	str	r1, [r0, #84]	; 0x54
   81db8:	e7f5      	b.n	81da6 <pio_set_output+0xe>
		p_pio->PIO_SODR = ul_mask;
   81dba:	6301      	str	r1, [r0, #48]	; 0x30
   81dbc:	e7f5      	b.n	81daa <pio_set_output+0x12>

00081dbe <pio_get_interrupt_status>:
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
   81dbe:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
   81dc0:	4770      	bx	lr

00081dc2 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
   81dc2:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
   81dc4:	4770      	bx	lr
	...

00081dc8 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
   81dc8:	b570      	push	{r4, r5, r6, lr}
   81dca:	b082      	sub	sp, #8
   81dcc:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
   81dce:	0943      	lsrs	r3, r0, #5
   81dd0:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   81dd4:	f203 7307 	addw	r3, r3, #1799	; 0x707
   81dd8:	025c      	lsls	r4, r3, #9
	switch (ul_flags & PIO_TYPE_Msk) {
   81dda:	f001 43f0 	and.w	r3, r1, #2013265920	; 0x78000000
   81dde:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
   81de2:	d031      	beq.n	81e48 <pio_configure_pin+0x80>
   81de4:	d816      	bhi.n	81e14 <pio_configure_pin+0x4c>
   81de6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
   81dea:	d01b      	beq.n	81e24 <pio_configure_pin+0x5c>
   81dec:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   81df0:	d116      	bne.n	81e20 <pio_configure_pin+0x58>
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
   81df2:	f000 001f 	and.w	r0, r0, #31
   81df6:	2601      	movs	r6, #1
   81df8:	4086      	lsls	r6, r0
   81dfa:	4632      	mov	r2, r6
   81dfc:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   81e00:	4620      	mov	r0, r4
   81e02:	4b22      	ldr	r3, [pc, #136]	; (81e8c <pio_configure_pin+0xc4>)
   81e04:	4798      	blx	r3
	if (ul_pull_up_enable) {
   81e06:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
   81e0a:	bf14      	ite	ne
   81e0c:	6666      	strne	r6, [r4, #100]	; 0x64
		p_pio->PIO_PUDR = ul_mask;
   81e0e:	6626      	streq	r6, [r4, #96]	; 0x60
	return 1;
   81e10:	2001      	movs	r0, #1
   81e12:	e017      	b.n	81e44 <pio_configure_pin+0x7c>
	switch (ul_flags & PIO_TYPE_Msk) {
   81e14:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   81e18:	d021      	beq.n	81e5e <pio_configure_pin+0x96>
   81e1a:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
   81e1e:	d01e      	beq.n	81e5e <pio_configure_pin+0x96>
		return 0;
   81e20:	2000      	movs	r0, #0
   81e22:	e00f      	b.n	81e44 <pio_configure_pin+0x7c>
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
   81e24:	f000 001f 	and.w	r0, r0, #31
   81e28:	2601      	movs	r6, #1
   81e2a:	4086      	lsls	r6, r0
   81e2c:	4632      	mov	r2, r6
   81e2e:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   81e32:	4620      	mov	r0, r4
   81e34:	4b15      	ldr	r3, [pc, #84]	; (81e8c <pio_configure_pin+0xc4>)
   81e36:	4798      	blx	r3
	if (ul_pull_up_enable) {
   81e38:	f015 0f01 	tst.w	r5, #1
		p_pio->PIO_PUER = ul_mask;
   81e3c:	bf14      	ite	ne
   81e3e:	6666      	strne	r6, [r4, #100]	; 0x64
		p_pio->PIO_PUDR = ul_mask;
   81e40:	6626      	streq	r6, [r4, #96]	; 0x60
	return 1;
   81e42:	2001      	movs	r0, #1
}
   81e44:	b002      	add	sp, #8
   81e46:	bd70      	pop	{r4, r5, r6, pc}
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
   81e48:	f000 011f 	and.w	r1, r0, #31
   81e4c:	2601      	movs	r6, #1
   81e4e:	462a      	mov	r2, r5
   81e50:	fa06 f101 	lsl.w	r1, r6, r1
   81e54:	4620      	mov	r0, r4
   81e56:	4b0e      	ldr	r3, [pc, #56]	; (81e90 <pio_configure_pin+0xc8>)
   81e58:	4798      	blx	r3
	return 1;
   81e5a:	4630      	mov	r0, r6
		break;
   81e5c:	e7f2      	b.n	81e44 <pio_configure_pin+0x7c>
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
   81e5e:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   81e62:	f000 011f 	and.w	r1, r0, #31
   81e66:	2601      	movs	r6, #1
   81e68:	ea05 0306 	and.w	r3, r5, r6
   81e6c:	9300      	str	r3, [sp, #0]
   81e6e:	f3c5 0380 	ubfx	r3, r5, #2, #1
   81e72:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
   81e76:	bf14      	ite	ne
   81e78:	2200      	movne	r2, #0
   81e7a:	2201      	moveq	r2, #1
   81e7c:	fa06 f101 	lsl.w	r1, r6, r1
   81e80:	4620      	mov	r0, r4
   81e82:	4c04      	ldr	r4, [pc, #16]	; (81e94 <pio_configure_pin+0xcc>)
   81e84:	47a0      	blx	r4
	return 1;
   81e86:	4630      	mov	r0, r6
		break;
   81e88:	e7dc      	b.n	81e44 <pio_configure_pin+0x7c>
   81e8a:	bf00      	nop
   81e8c:	00081d29 	.word	0x00081d29
   81e90:	00081d67 	.word	0x00081d67
   81e94:	00081d99 	.word	0x00081d99

00081e98 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
   81e98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   81e9c:	4604      	mov	r4, r0
   81e9e:	4688      	mov	r8, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
   81ea0:	4b0e      	ldr	r3, [pc, #56]	; (81edc <pio_handler_process+0x44>)
   81ea2:	4798      	blx	r3
   81ea4:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
   81ea6:	4620      	mov	r0, r4
   81ea8:	4b0d      	ldr	r3, [pc, #52]	; (81ee0 <pio_handler_process+0x48>)
   81eaa:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
   81eac:	4005      	ands	r5, r0
   81eae:	d013      	beq.n	81ed8 <pio_handler_process+0x40>
   81eb0:	4c0c      	ldr	r4, [pc, #48]	; (81ee4 <pio_handler_process+0x4c>)
   81eb2:	f104 0660 	add.w	r6, r4, #96	; 0x60
   81eb6:	e003      	b.n	81ec0 <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
   81eb8:	42b4      	cmp	r4, r6
   81eba:	d00d      	beq.n	81ed8 <pio_handler_process+0x40>
   81ebc:	3410      	adds	r4, #16
		while (status != 0) {
   81ebe:	b15d      	cbz	r5, 81ed8 <pio_handler_process+0x40>
			if (gs_interrupt_sources[i].id == ul_id) {
   81ec0:	6820      	ldr	r0, [r4, #0]
   81ec2:	4540      	cmp	r0, r8
   81ec4:	d1f8      	bne.n	81eb8 <pio_handler_process+0x20>
				if ((status & gs_interrupt_sources[i].mask) != 0) {
   81ec6:	6861      	ldr	r1, [r4, #4]
   81ec8:	4229      	tst	r1, r5
   81eca:	d0f5      	beq.n	81eb8 <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
   81ecc:	68e3      	ldr	r3, [r4, #12]
   81ece:	4798      	blx	r3
					status &= ~(gs_interrupt_sources[i].mask);
   81ed0:	6863      	ldr	r3, [r4, #4]
   81ed2:	ea25 0503 	bic.w	r5, r5, r3
   81ed6:	e7ef      	b.n	81eb8 <pio_handler_process+0x20>
   81ed8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   81edc:	00081dbf 	.word	0x00081dbf
   81ee0:	00081dc3 	.word	0x00081dc3
   81ee4:	20071044 	.word	0x20071044

00081ee8 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
   81ee8:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
   81eea:	210b      	movs	r1, #11
   81eec:	4801      	ldr	r0, [pc, #4]	; (81ef4 <PIOA_Handler+0xc>)
   81eee:	4b02      	ldr	r3, [pc, #8]	; (81ef8 <PIOA_Handler+0x10>)
   81ef0:	4798      	blx	r3
   81ef2:	bd08      	pop	{r3, pc}
   81ef4:	400e0e00 	.word	0x400e0e00
   81ef8:	00081e99 	.word	0x00081e99

00081efc <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
   81efc:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
   81efe:	210c      	movs	r1, #12
   81f00:	4801      	ldr	r0, [pc, #4]	; (81f08 <PIOB_Handler+0xc>)
   81f02:	4b02      	ldr	r3, [pc, #8]	; (81f0c <PIOB_Handler+0x10>)
   81f04:	4798      	blx	r3
   81f06:	bd08      	pop	{r3, pc}
   81f08:	400e1000 	.word	0x400e1000
   81f0c:	00081e99 	.word	0x00081e99

00081f10 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
   81f10:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
   81f12:	210d      	movs	r1, #13
   81f14:	4801      	ldr	r0, [pc, #4]	; (81f1c <PIOC_Handler+0xc>)
   81f16:	4b02      	ldr	r3, [pc, #8]	; (81f20 <PIOC_Handler+0x10>)
   81f18:	4798      	blx	r3
   81f1a:	bd08      	pop	{r3, pc}
   81f1c:	400e1200 	.word	0x400e1200
   81f20:	00081e99 	.word	0x00081e99

00081f24 <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
   81f24:	b508      	push	{r3, lr}
	pio_handler_process(PIOD, ID_PIOD);
   81f26:	210e      	movs	r1, #14
   81f28:	4801      	ldr	r0, [pc, #4]	; (81f30 <PIOD_Handler+0xc>)
   81f2a:	4b02      	ldr	r3, [pc, #8]	; (81f34 <PIOD_Handler+0x10>)
   81f2c:	4798      	blx	r3
   81f2e:	bd08      	pop	{r3, pc}
   81f30:	400e1400 	.word	0x400e1400
   81f34:	00081e99 	.word	0x00081e99

00081f38 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
   81f38:	4a17      	ldr	r2, [pc, #92]	; (81f98 <pmc_switch_mck_to_pllack+0x60>)
   81f3a:	6b13      	ldr	r3, [r2, #48]	; 0x30
   81f3c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
   81f40:	4318      	orrs	r0, r3
   81f42:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   81f44:	6e93      	ldr	r3, [r2, #104]	; 0x68
   81f46:	f013 0f08 	tst.w	r3, #8
   81f4a:	d10a      	bne.n	81f62 <pmc_switch_mck_to_pllack+0x2a>
   81f4c:	f44f 6300 	mov.w	r3, #2048	; 0x800
   81f50:	4911      	ldr	r1, [pc, #68]	; (81f98 <pmc_switch_mck_to_pllack+0x60>)
   81f52:	6e8a      	ldr	r2, [r1, #104]	; 0x68
   81f54:	f012 0f08 	tst.w	r2, #8
   81f58:	d103      	bne.n	81f62 <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
   81f5a:	3b01      	subs	r3, #1
   81f5c:	d1f9      	bne.n	81f52 <pmc_switch_mck_to_pllack+0x1a>
			return 1;
   81f5e:	2001      	movs	r0, #1
   81f60:	4770      	bx	lr
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
   81f62:	4a0d      	ldr	r2, [pc, #52]	; (81f98 <pmc_switch_mck_to_pllack+0x60>)
   81f64:	6b13      	ldr	r3, [r2, #48]	; 0x30
   81f66:	f023 0303 	bic.w	r3, r3, #3
   81f6a:	f043 0302 	orr.w	r3, r3, #2
   81f6e:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   81f70:	6e93      	ldr	r3, [r2, #104]	; 0x68
   81f72:	f013 0f08 	tst.w	r3, #8
   81f76:	d10a      	bne.n	81f8e <pmc_switch_mck_to_pllack+0x56>
   81f78:	f44f 6300 	mov.w	r3, #2048	; 0x800
   81f7c:	4906      	ldr	r1, [pc, #24]	; (81f98 <pmc_switch_mck_to_pllack+0x60>)
   81f7e:	6e8a      	ldr	r2, [r1, #104]	; 0x68
   81f80:	f012 0f08 	tst.w	r2, #8
   81f84:	d105      	bne.n	81f92 <pmc_switch_mck_to_pllack+0x5a>
			--ul_timeout) {
		if (ul_timeout == 0) {
   81f86:	3b01      	subs	r3, #1
   81f88:	d1f9      	bne.n	81f7e <pmc_switch_mck_to_pllack+0x46>
			return 1;
   81f8a:	2001      	movs	r0, #1
		}
	}

	return 0;
}
   81f8c:	4770      	bx	lr
	return 0;
   81f8e:	2000      	movs	r0, #0
   81f90:	4770      	bx	lr
   81f92:	2000      	movs	r0, #0
   81f94:	4770      	bx	lr
   81f96:	bf00      	nop
   81f98:	400e0600 	.word	0x400e0600

00081f9c <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
   81f9c:	b9c8      	cbnz	r0, 81fd2 <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
   81f9e:	4a11      	ldr	r2, [pc, #68]	; (81fe4 <pmc_switch_mainck_to_xtal+0x48>)
   81fa0:	6a13      	ldr	r3, [r2, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
   81fa2:	0209      	lsls	r1, r1, #8
   81fa4:	b289      	uxth	r1, r1
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
   81fa6:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
   81faa:	f023 0303 	bic.w	r3, r3, #3
   81fae:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
   81fb2:	f043 0301 	orr.w	r3, r3, #1
   81fb6:	430b      	orrs	r3, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
   81fb8:	6213      	str	r3, [r2, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
   81fba:	6e93      	ldr	r3, [r2, #104]	; 0x68
   81fbc:	f013 0f01 	tst.w	r3, #1
   81fc0:	d0fb      	beq.n	81fba <pmc_switch_mainck_to_xtal+0x1e>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
   81fc2:	4a08      	ldr	r2, [pc, #32]	; (81fe4 <pmc_switch_mainck_to_xtal+0x48>)
   81fc4:	6a13      	ldr	r3, [r2, #32]
   81fc6:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
   81fca:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   81fce:	6213      	str	r3, [r2, #32]
   81fd0:	4770      	bx	lr
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   81fd2:	4904      	ldr	r1, [pc, #16]	; (81fe4 <pmc_switch_mainck_to_xtal+0x48>)
   81fd4:	6a0b      	ldr	r3, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
   81fd6:	4a04      	ldr	r2, [pc, #16]	; (81fe8 <pmc_switch_mainck_to_xtal+0x4c>)
   81fd8:	401a      	ands	r2, r3
   81fda:	4b04      	ldr	r3, [pc, #16]	; (81fec <pmc_switch_mainck_to_xtal+0x50>)
   81fdc:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   81fde:	620b      	str	r3, [r1, #32]
   81fe0:	4770      	bx	lr
   81fe2:	bf00      	nop
   81fe4:	400e0600 	.word	0x400e0600
   81fe8:	fec8fffc 	.word	0xfec8fffc
   81fec:	01370002 	.word	0x01370002

00081ff0 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
   81ff0:	4b02      	ldr	r3, [pc, #8]	; (81ffc <pmc_osc_is_ready_mainck+0xc>)
   81ff2:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
   81ff4:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
   81ff8:	4770      	bx	lr
   81ffa:	bf00      	nop
   81ffc:	400e0600 	.word	0x400e0600

00082000 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
   82000:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   82004:	4b01      	ldr	r3, [pc, #4]	; (8200c <pmc_disable_pllack+0xc>)
   82006:	629a      	str	r2, [r3, #40]	; 0x28
   82008:	4770      	bx	lr
   8200a:	bf00      	nop
   8200c:	400e0600 	.word	0x400e0600

00082010 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
   82010:	4b02      	ldr	r3, [pc, #8]	; (8201c <pmc_is_locked_pllack+0xc>)
   82012:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
   82014:	f000 0002 	and.w	r0, r0, #2
   82018:	4770      	bx	lr
   8201a:	bf00      	nop
   8201c:	400e0600 	.word	0x400e0600

00082020 <pmc_enable_periph_clk>:
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
#if defined(REG_PMC_PCR) && !SAMG55
	uint32_t pcr;
	PMC->PMC_PCR = ul_id & 0x7F;
   82020:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   82024:	4b05      	ldr	r3, [pc, #20]	; (8203c <pmc_enable_periph_clk+0x1c>)
   82026:	f8c3 010c 	str.w	r0, [r3, #268]	; 0x10c
	pcr = PMC->PMC_PCR | PMC_PCR_EN | PMC_PCR_CMD;
   8202a:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
   8202e:	f042 2210 	orr.w	r2, r2, #268439552	; 0x10001000
	PMC->PMC_PCR = pcr;
   82032:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
#endif
	}

	return 0;
#endif /* defined(REG_PMC_PCR) && !SAMG55 */
}
   82036:	2000      	movs	r0, #0
   82038:	4770      	bx	lr
   8203a:	bf00      	nop
   8203c:	400e0600 	.word	0x400e0600

00082040 <pmc_is_wakeup_clocks_restored>:
	}
}

bool pmc_is_wakeup_clocks_restored(void)
{
	return !b_is_sleep_clock_used;
   82040:	4b02      	ldr	r3, [pc, #8]	; (8204c <pmc_is_wakeup_clocks_restored+0xc>)
   82042:	7818      	ldrb	r0, [r3, #0]
}
   82044:	f080 0001 	eor.w	r0, r0, #1
   82048:	4770      	bx	lr
   8204a:	bf00      	nop
   8204c:	200710b4 	.word	0x200710b4

00082050 <twi_disable_interrupt>:
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
   82050:	6281      	str	r1, [r0, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
   82052:	6a03      	ldr	r3, [r0, #32]
   82054:	4770      	bx	lr

00082056 <twi_get_interrupt_status>:
 *
 * \retval TWI interrupt status.
 */
uint32_t twi_get_interrupt_status(Twi *p_twi)
{
	return p_twi->TWI_SR;
   82056:	6a00      	ldr	r0, [r0, #32]
}
   82058:	4770      	bx	lr

0008205a <twi_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t twi_get_interrupt_mask(Twi *p_twi)
{
	return p_twi->TWI_IMR;
   8205a:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
   8205c:	4770      	bx	lr

0008205e <uart_enable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be enabled.
 */
void uart_enable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IER = ul_sources;
   8205e:	6081      	str	r1, [r0, #8]
   82060:	4770      	bx	lr

00082062 <uart_disable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be disabled.
 */
void uart_disable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IDR = ul_sources;
   82062:	60c1      	str	r1, [r0, #12]
   82064:	4770      	bx	lr

00082066 <uart_get_interrupt_mask>:
 *
 *  \return The interrupt mask value.
 */
uint32_t uart_get_interrupt_mask(Uart *p_uart)
{
	return p_uart->UART_IMR;
   82066:	6900      	ldr	r0, [r0, #16]
}
   82068:	4770      	bx	lr

0008206a <uart_get_status>:
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
	return p_uart->UART_SR;
   8206a:	6940      	ldr	r0, [r0, #20]
}
   8206c:	4770      	bx	lr

0008206e <uart_reset_status>:
 *
 * \param p_uart Pointer to a UART instance.
 */
void uart_reset_status(Uart *p_uart)
{
	p_uart->UART_CR = UART_CR_RSTSTA;
   8206e:	f44f 7380 	mov.w	r3, #256	; 0x100
   82072:	6003      	str	r3, [r0, #0]
   82074:	4770      	bx	lr
	...

00082078 <udd_ctrl_init>:
	udd_enable_endpoint_interrupt(0);
	cpu_irq_restore(flags);
}

static void udd_ctrl_init(void)
{
   82078:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   8207a:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   8207e:	fab3 f383 	clz	r3, r3
   82082:	095b      	lsrs	r3, r3, #5
   82084:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   82086:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82088:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   8208c:	2200      	movs	r2, #0
   8208e:	4b0c      	ldr	r3, [pc, #48]	; (820c0 <udd_ctrl_init+0x48>)
   82090:	701a      	strb	r2, [r3, #0]
	return flags;
   82092:	9b01      	ldr	r3, [sp, #4]
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI),
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
   82094:	2101      	movs	r1, #1
   82096:	4a0b      	ldr	r2, [pc, #44]	; (820c4 <udd_ctrl_init+0x4c>)
   82098:	6011      	str	r1, [r2, #0]
	if (cpu_irq_is_enabled_flags(flags))
   8209a:	b123      	cbz	r3, 820a6 <udd_ctrl_init+0x2e>
		cpu_irq_enable();
   8209c:	4b08      	ldr	r3, [pc, #32]	; (820c0 <udd_ctrl_init+0x48>)
   8209e:	7019      	strb	r1, [r3, #0]
   820a0:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   820a4:	b662      	cpsie	i
	cpu_irq_restore(flags);

	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
   820a6:	2202      	movs	r2, #2
   820a8:	4b07      	ldr	r3, [pc, #28]	; (820c8 <udd_ctrl_init+0x50>)
   820aa:	601a      	str	r2, [r3, #0]

	udd_g_ctrlreq.callback = NULL;
   820ac:	4a07      	ldr	r2, [pc, #28]	; (820cc <udd_ctrl_init+0x54>)
   820ae:	2300      	movs	r3, #0
   820b0:	6113      	str	r3, [r2, #16]
	udd_g_ctrlreq.over_under_run = NULL;
   820b2:	6153      	str	r3, [r2, #20]
	udd_g_ctrlreq.payload_size = 0;
   820b4:	8193      	strh	r3, [r2, #12]
	udd_ep_control_state = UDD_EPCTRL_SETUP;
   820b6:	4a06      	ldr	r2, [pc, #24]	; (820d0 <udd_ctrl_init+0x58>)
   820b8:	7013      	strb	r3, [r2, #0]
}
   820ba:	b002      	add	sp, #8
   820bc:	4770      	bx	lr
   820be:	bf00      	nop
   820c0:	2007026e 	.word	0x2007026e
   820c4:	400ac220 	.word	0x400ac220
   820c8:	400ac160 	.word	0x400ac160
   820cc:	20075364 	.word	0x20075364
   820d0:	200710bc 	.word	0x200710bc

000820d4 <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
   820d4:	2205      	movs	r2, #5
   820d6:	4b03      	ldr	r3, [pc, #12]	; (820e4 <udd_ctrl_stall_data+0x10>)
   820d8:	701a      	strb	r2, [r3, #0]
	udd_enable_stall_handshake(0);
   820da:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   820de:	4b02      	ldr	r3, [pc, #8]	; (820e8 <udd_ctrl_stall_data+0x14>)
   820e0:	601a      	str	r2, [r3, #0]
   820e2:	4770      	bx	lr
   820e4:	200710bc 	.word	0x200710bc
   820e8:	400ac1f0 	.word	0x400ac1f0

000820ec <udd_ctrl_send_zlp_in>:
}


static void udd_ctrl_send_zlp_in(void)
{
   820ec:	b082      	sub	sp, #8
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
   820ee:	2203      	movs	r2, #3
   820f0:	4b0f      	ldr	r3, [pc, #60]	; (82130 <udd_ctrl_send_zlp_in+0x44>)
   820f2:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   820f4:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   820f8:	fab3 f383 	clz	r3, r3
   820fc:	095b      	lsrs	r3, r3, #5
   820fe:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   82100:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82102:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82106:	2200      	movs	r2, #0
   82108:	4b0a      	ldr	r3, [pc, #40]	; (82134 <udd_ctrl_send_zlp_in+0x48>)
   8210a:	701a      	strb	r2, [r3, #0]
	return flags;
   8210c:	9801      	ldr	r0, [sp, #4]

	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
   8210e:	490a      	ldr	r1, [pc, #40]	; (82138 <udd_ctrl_send_zlp_in+0x4c>)
   82110:	2201      	movs	r2, #1
   82112:	600a      	str	r2, [r1, #0]
	udd_enable_in_send_interrupt(0);
   82114:	4b09      	ldr	r3, [pc, #36]	; (8213c <udd_ctrl_send_zlp_in+0x50>)
   82116:	601a      	str	r2, [r3, #0]
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
   82118:	2208      	movs	r2, #8
   8211a:	600a      	str	r2, [r1, #0]
	udd_enable_nak_out_interrupt(0);
   8211c:	601a      	str	r2, [r3, #0]
	if (cpu_irq_is_enabled_flags(flags))
   8211e:	b128      	cbz	r0, 8212c <udd_ctrl_send_zlp_in+0x40>
		cpu_irq_enable();
   82120:	2201      	movs	r2, #1
   82122:	4b04      	ldr	r3, [pc, #16]	; (82134 <udd_ctrl_send_zlp_in+0x48>)
   82124:	701a      	strb	r2, [r3, #0]
   82126:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   8212a:	b662      	cpsie	i
	cpu_irq_restore(flags);
}
   8212c:	b002      	add	sp, #8
   8212e:	4770      	bx	lr
   82130:	200710bc 	.word	0x200710bc
   82134:	2007026e 	.word	0x2007026e
   82138:	400ac160 	.word	0x400ac160
   8213c:	400ac1f0 	.word	0x400ac1f0

00082140 <udd_ctrl_endofrequest>:
	cpu_irq_restore(flags);
}


static void udd_ctrl_endofrequest(void)
{
   82140:	b508      	push	{r3, lr}
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
   82142:	4b02      	ldr	r3, [pc, #8]	; (8214c <udd_ctrl_endofrequest+0xc>)
   82144:	691b      	ldr	r3, [r3, #16]
   82146:	b103      	cbz	r3, 8214a <udd_ctrl_endofrequest+0xa>
		udd_g_ctrlreq.callback();
   82148:	4798      	blx	r3
   8214a:	bd08      	pop	{r3, pc}
   8214c:	20075364 	.word	0x20075364

00082150 <udd_ctrl_in_sent>:
{
   82150:	b530      	push	{r4, r5, lr}
   82152:	b085      	sub	sp, #20
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   82154:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   82158:	fab3 f383 	clz	r3, r3
   8215c:	095b      	lsrs	r3, r3, #5
   8215e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   82160:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82162:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82166:	2200      	movs	r2, #0
   82168:	4b4c      	ldr	r3, [pc, #304]	; (8229c <udd_ctrl_in_sent+0x14c>)
   8216a:	701a      	strb	r2, [r3, #0]
	return flags;
   8216c:	9b01      	ldr	r3, [sp, #4]
	udd_disable_in_send_interrupt(0);
   8216e:	2101      	movs	r1, #1
   82170:	4a4b      	ldr	r2, [pc, #300]	; (822a0 <udd_ctrl_in_sent+0x150>)
   82172:	6011      	str	r1, [r2, #0]
	if (cpu_irq_is_enabled_flags(flags))
   82174:	b123      	cbz	r3, 82180 <udd_ctrl_in_sent+0x30>
		cpu_irq_enable();
   82176:	4b49      	ldr	r3, [pc, #292]	; (8229c <udd_ctrl_in_sent+0x14c>)
   82178:	7019      	strb	r1, [r3, #0]
   8217a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   8217e:	b662      	cpsie	i
	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
   82180:	4b48      	ldr	r3, [pc, #288]	; (822a4 <udd_ctrl_in_sent+0x154>)
   82182:	781b      	ldrb	r3, [r3, #0]
   82184:	2b03      	cmp	r3, #3
   82186:	d057      	beq.n	82238 <udd_ctrl_in_sent+0xe8>
	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
   82188:	4b47      	ldr	r3, [pc, #284]	; (822a8 <udd_ctrl_in_sent+0x158>)
   8218a:	881b      	ldrh	r3, [r3, #0]
   8218c:	4a47      	ldr	r2, [pc, #284]	; (822ac <udd_ctrl_in_sent+0x15c>)
   8218e:	8994      	ldrh	r4, [r2, #12]
   82190:	1ae4      	subs	r4, r4, r3
   82192:	b2a4      	uxth	r4, r4
	if (0 == nb_remain) {
   82194:	b9c4      	cbnz	r4, 821c8 <udd_ctrl_in_sent+0x78>
		udd_ctrl_prev_payload_buf_cnt += udd_ctrl_payload_buf_cnt;
   82196:	4a46      	ldr	r2, [pc, #280]	; (822b0 <udd_ctrl_in_sent+0x160>)
   82198:	8811      	ldrh	r1, [r2, #0]
   8219a:	440b      	add	r3, r1
   8219c:	b29b      	uxth	r3, r3
   8219e:	8013      	strh	r3, [r2, #0]
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_buf_cnt)
   821a0:	4a42      	ldr	r2, [pc, #264]	; (822ac <udd_ctrl_in_sent+0x15c>)
   821a2:	88d2      	ldrh	r2, [r2, #6]
   821a4:	429a      	cmp	r2, r3
   821a6:	d04c      	beq.n	82242 <udd_ctrl_in_sent+0xf2>
					|| b_shortpacket) {
   821a8:	4b42      	ldr	r3, [pc, #264]	; (822b4 <udd_ctrl_in_sent+0x164>)
   821aa:	781b      	ldrb	r3, [r3, #0]
   821ac:	2b00      	cmp	r3, #0
   821ae:	d148      	bne.n	82242 <udd_ctrl_in_sent+0xf2>
		if ((!udd_g_ctrlreq.over_under_run)
   821b0:	4b3e      	ldr	r3, [pc, #248]	; (822ac <udd_ctrl_in_sent+0x15c>)
   821b2:	695b      	ldr	r3, [r3, #20]
   821b4:	2b00      	cmp	r3, #0
   821b6:	d061      	beq.n	8227c <udd_ctrl_in_sent+0x12c>
				|| (!udd_g_ctrlreq.over_under_run())) {
   821b8:	4798      	blx	r3
   821ba:	2800      	cmp	r0, #0
   821bc:	d05e      	beq.n	8227c <udd_ctrl_in_sent+0x12c>
			udd_ctrl_payload_buf_cnt = 0;
   821be:	2200      	movs	r2, #0
   821c0:	4b39      	ldr	r3, [pc, #228]	; (822a8 <udd_ctrl_in_sent+0x158>)
   821c2:	801a      	strh	r2, [r3, #0]
			nb_remain = udd_g_ctrlreq.payload_size;
   821c4:	4b39      	ldr	r3, [pc, #228]	; (822ac <udd_ctrl_in_sent+0x15c>)
   821c6:	899c      	ldrh	r4, [r3, #12]
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
   821c8:	2c3f      	cmp	r4, #63	; 0x3f
   821ca:	d957      	bls.n	8227c <udd_ctrl_in_sent+0x12c>
		b_shortpacket = false;
   821cc:	2200      	movs	r2, #0
   821ce:	4b39      	ldr	r3, [pc, #228]	; (822b4 <udd_ctrl_in_sent+0x164>)
   821d0:	701a      	strb	r2, [r3, #0]
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
   821d2:	2440      	movs	r4, #64	; 0x40
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   821d4:	4b35      	ldr	r3, [pc, #212]	; (822ac <udd_ctrl_in_sent+0x15c>)
   821d6:	689a      	ldr	r2, [r3, #8]
   821d8:	4b33      	ldr	r3, [pc, #204]	; (822a8 <udd_ctrl_in_sent+0x158>)
   821da:	881d      	ldrh	r5, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   821dc:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   821e0:	fab3 f383 	clz	r3, r3
   821e4:	095b      	lsrs	r3, r3, #5
   821e6:	9302      	str	r3, [sp, #8]
  __ASM volatile ("cpsid i" : : : "memory");
   821e8:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   821ea:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   821ee:	2100      	movs	r1, #0
   821f0:	4b2a      	ldr	r3, [pc, #168]	; (8229c <udd_ctrl_in_sent+0x14c>)
   821f2:	7019      	strb	r1, [r3, #0]
	return flags;
   821f4:	9802      	ldr	r0, [sp, #8]
	if (Is_udd_out_received(0)) {
   821f6:	4b30      	ldr	r3, [pc, #192]	; (822b8 <udd_ctrl_in_sent+0x168>)
   821f8:	681b      	ldr	r3, [r3, #0]
   821fa:	f013 0f02 	tst.w	r3, #2
   821fe:	d141      	bne.n	82284 <udd_ctrl_in_sent+0x134>
	for (i = 0; i < nb_remain; i++) {
   82200:	b144      	cbz	r4, 82214 <udd_ctrl_in_sent+0xc4>
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   82202:	442a      	add	r2, r5
   82204:	4b2d      	ldr	r3, [pc, #180]	; (822bc <udd_ctrl_in_sent+0x16c>)
		*ptr_dest++ = *ptr_src++;
   82206:	f812 1b01 	ldrb.w	r1, [r2], #1
   8220a:	f803 1b01 	strb.w	r1, [r3], #1
	for (i = 0; i < nb_remain; i++) {
   8220e:	b2d9      	uxtb	r1, r3
   82210:	42a1      	cmp	r1, r4
   82212:	d3f8      	bcc.n	82206 <udd_ctrl_in_sent+0xb6>
	udd_ctrl_payload_buf_cnt += nb_remain;
   82214:	4b24      	ldr	r3, [pc, #144]	; (822a8 <udd_ctrl_in_sent+0x158>)
   82216:	881a      	ldrh	r2, [r3, #0]
   82218:	4414      	add	r4, r2
   8221a:	801c      	strh	r4, [r3, #0]
	udd_ack_in_send(0);
   8221c:	2301      	movs	r3, #1
   8221e:	4a28      	ldr	r2, [pc, #160]	; (822c0 <udd_ctrl_in_sent+0x170>)
   82220:	6013      	str	r3, [r2, #0]
	udd_enable_in_send_interrupt(0);
   82222:	3290      	adds	r2, #144	; 0x90
   82224:	6013      	str	r3, [r2, #0]
	if (cpu_irq_is_enabled_flags(flags))
   82226:	2800      	cmp	r0, #0
   82228:	d036      	beq.n	82298 <udd_ctrl_in_sent+0x148>
		cpu_irq_enable();
   8222a:	461a      	mov	r2, r3
   8222c:	4b1b      	ldr	r3, [pc, #108]	; (8229c <udd_ctrl_in_sent+0x14c>)
   8222e:	701a      	strb	r2, [r3, #0]
   82230:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82234:	b662      	cpsie	i
   82236:	e02f      	b.n	82298 <udd_ctrl_in_sent+0x148>
		udd_ctrl_endofrequest();
   82238:	4b22      	ldr	r3, [pc, #136]	; (822c4 <udd_ctrl_in_sent+0x174>)
   8223a:	4798      	blx	r3
		udd_ctrl_init();
   8223c:	4b22      	ldr	r3, [pc, #136]	; (822c8 <udd_ctrl_in_sent+0x178>)
   8223e:	4798      	blx	r3
		return;
   82240:	e02a      	b.n	82298 <udd_ctrl_in_sent+0x148>
	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
   82242:	2204      	movs	r2, #4
   82244:	4b17      	ldr	r3, [pc, #92]	; (822a4 <udd_ctrl_in_sent+0x154>)
   82246:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   82248:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   8224c:	fab3 f383 	clz	r3, r3
   82250:	095b      	lsrs	r3, r3, #5
   82252:	9303      	str	r3, [sp, #12]
  __ASM volatile ("cpsid i" : : : "memory");
   82254:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82256:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   8225a:	2200      	movs	r2, #0
   8225c:	4b0f      	ldr	r3, [pc, #60]	; (8229c <udd_ctrl_in_sent+0x14c>)
   8225e:	701a      	strb	r2, [r3, #0]
	return flags;
   82260:	9a03      	ldr	r2, [sp, #12]
	udd_ack_nak_in(0);
   82262:	2310      	movs	r3, #16
   82264:	4916      	ldr	r1, [pc, #88]	; (822c0 <udd_ctrl_in_sent+0x170>)
   82266:	600b      	str	r3, [r1, #0]
	udd_enable_nak_in_interrupt(0);
   82268:	3190      	adds	r1, #144	; 0x90
   8226a:	600b      	str	r3, [r1, #0]
	if (cpu_irq_is_enabled_flags(flags))
   8226c:	b1a2      	cbz	r2, 82298 <udd_ctrl_in_sent+0x148>
		cpu_irq_enable();
   8226e:	2201      	movs	r2, #1
   82270:	4b0a      	ldr	r3, [pc, #40]	; (8229c <udd_ctrl_in_sent+0x14c>)
   82272:	701a      	strb	r2, [r3, #0]
   82274:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82278:	b662      	cpsie	i
   8227a:	e00d      	b.n	82298 <udd_ctrl_in_sent+0x148>
		b_shortpacket = true;
   8227c:	2201      	movs	r2, #1
   8227e:	4b0d      	ldr	r3, [pc, #52]	; (822b4 <udd_ctrl_in_sent+0x164>)
   82280:	701a      	strb	r2, [r3, #0]
   82282:	e7a7      	b.n	821d4 <udd_ctrl_in_sent+0x84>
	if (cpu_irq_is_enabled_flags(flags))
   82284:	b128      	cbz	r0, 82292 <udd_ctrl_in_sent+0x142>
		cpu_irq_enable();
   82286:	2201      	movs	r2, #1
   82288:	4b04      	ldr	r3, [pc, #16]	; (8229c <udd_ctrl_in_sent+0x14c>)
   8228a:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   8228c:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82290:	b662      	cpsie	i
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
   82292:	2204      	movs	r2, #4
   82294:	4b03      	ldr	r3, [pc, #12]	; (822a4 <udd_ctrl_in_sent+0x154>)
   82296:	701a      	strb	r2, [r3, #0]
}
   82298:	b005      	add	sp, #20
   8229a:	bd30      	pop	{r4, r5, pc}
   8229c:	2007026e 	.word	0x2007026e
   822a0:	400ac220 	.word	0x400ac220
   822a4:	200710bc 	.word	0x200710bc
   822a8:	200710b8 	.word	0x200710b8
   822ac:	20075364 	.word	0x20075364
   822b0:	200710ba 	.word	0x200710ba
   822b4:	200710b5 	.word	0x200710b5
   822b8:	400ac130 	.word	0x400ac130
   822bc:	20180000 	.word	0x20180000
   822c0:	400ac160 	.word	0x400ac160
   822c4:	00082141 	.word	0x00082141
   822c8:	00082079 	.word	0x00082079

000822cc <udd_ep_finish_job>:
}


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num)
{
	if (ptr_job->busy == false) {
   822cc:	7d03      	ldrb	r3, [r0, #20]
   822ce:	f013 0f01 	tst.w	r3, #1
   822d2:	d013      	beq.n	822fc <udd_ep_finish_job+0x30>
{
   822d4:	b510      	push	{r4, lr}
   822d6:	460c      	mov	r4, r1
		return; // No on-going job
	}
	dbg_print("(JobE%x:%d) ", (ptr_job-udd_ep_job)+1, b_abort);
	ptr_job->busy = false;
   822d8:	7d03      	ldrb	r3, [r0, #20]
   822da:	f36f 0300 	bfc	r3, #0, #1
   822de:	7503      	strb	r3, [r0, #20]
	if (NULL == ptr_job->call_trans) {
   822e0:	6803      	ldr	r3, [r0, #0]
   822e2:	b153      	cbz	r3, 822fa <udd_ep_finish_job+0x2e>
		return; // No callback linked to job
	}
	if (Is_udd_endpoint_in(ep_num)) {
   822e4:	4906      	ldr	r1, [pc, #24]	; (82300 <udd_ep_finish_job+0x34>)
   822e6:	f851 1022 	ldr.w	r1, [r1, r2, lsl #2]
   822ea:	f411 7f80 	tst.w	r1, #256	; 0x100
		ep_num |= USB_EP_DIR_IN;
   822ee:	bf18      	it	ne
   822f0:	f042 0280 	orrne.w	r2, r2, #128	; 0x80
	}
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
   822f4:	6881      	ldr	r1, [r0, #8]
   822f6:	4620      	mov	r0, r4
   822f8:	4798      	blx	r3
   822fa:	bd10      	pop	{r4, pc}
   822fc:	4770      	bx	lr
   822fe:	bf00      	nop
   82300:	400ac100 	.word	0x400ac100

00082304 <udd_ep_trans_done>:
	udd_ep_job_t *ptr_job;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep - 1];
   82304:	1e43      	subs	r3, r0, #1

	if (!ptr_job->busy) {
   82306:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   8230a:	4a5f      	ldr	r2, [pc, #380]	; (82488 <udd_ep_trans_done+0x184>)
   8230c:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   82310:	7d12      	ldrb	r2, [r2, #20]
   82312:	f012 0f01 	tst.w	r2, #1
   82316:	f000 80b5 	beq.w	82484 <udd_ep_trans_done+0x180>
{
   8231a:	b5f0      	push	{r4, r5, r6, r7, lr}
   8231c:	b083      	sub	sp, #12
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->buf_cnt != ptr_job->buf_size) {
   8231e:	460a      	mov	r2, r1
   82320:	4959      	ldr	r1, [pc, #356]	; (82488 <udd_ep_trans_done+0x184>)
   82322:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   82326:	68d1      	ldr	r1, [r2, #12]
   82328:	6892      	ldr	r2, [r2, #8]
   8232a:	4291      	cmp	r1, r2
   8232c:	d077      	beq.n	8241e <udd_ep_trans_done+0x11a>
		// Need to send or receiv other data
		next_trans = ptr_job->buf_size - ptr_job->buf_cnt;
   8232e:	1a52      	subs	r2, r2, r1

		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
   82330:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
			next_trans = UDD_ENDPOINT_MAX_TRANS;

			// Set 0 to tranfer the maximum
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(0);
		} else {
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(next_trans);
   82334:	bf92      	itee	ls
   82336:	0417      	lslls	r7, r2, #16
			next_trans = UDD_ENDPOINT_MAX_TRANS;
   82338:	f44f 3280 	movhi.w	r2, #65536	; 0x10000
			udd_dma_ctrl = UOTGHS_DEVDMACONTROL_BUFF_LENGTH(0);
   8233c:	2700      	movhi	r7, #0
		}
		if (Is_udd_endpoint_in(ep)) {
   8233e:	4c53      	ldr	r4, [pc, #332]	; (8248c <udd_ep_trans_done+0x188>)
   82340:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
   82344:	f415 7f80 	tst.w	r5, #256	; 0x100
   82348:	d014      	beq.n	82374 <udd_ep_trans_done+0x70>
			if (0 != (next_trans % udd_get_endpoint_size(ep))) {
   8234a:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
   8234e:	f3c5 1502 	ubfx	r5, r5, #4, #3
   82352:	2408      	movs	r4, #8
   82354:	40ac      	lsls	r4, r5
   82356:	3c01      	subs	r4, #1
   82358:	4214      	tst	r4, r2
   8235a:	d013      	beq.n	82384 <udd_ep_trans_done+0x80>
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_B_EN;
   8235c:	f047 0708 	orr.w	r7, r7, #8
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
   82360:	eb03 0443 	add.w	r4, r3, r3, lsl #1
   82364:	4d48      	ldr	r5, [pc, #288]	; (82488 <udd_ep_trans_done+0x184>)
   82366:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
   8236a:	7d25      	ldrb	r5, [r4, #20]
   8236c:	f36f 0541 	bfc	r5, #1, #1
   82370:	7525      	strb	r5, [r4, #20]
   82372:	e007      	b.n	82384 <udd_ep_trans_done+0x80>
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != udd_get_endpoint_type(ep))
   82374:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
   82378:	f3c5 25c1 	ubfx	r5, r5, #11, #2
   8237c:	2d01      	cmp	r5, #1
   8237e:	d037      	beq.n	823f0 <udd_ep_trans_done+0xec>
					|| (next_trans <= (iram_size_t) udd_get_endpoint_size(ep))) {

				// Enable short packet reception
				udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_TR_IT
   82380:	f047 0714 	orr.w	r7, r7, #20
						| UOTGHS_DEVDMACONTROL_END_TR_EN;
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		udd_endpoint_dma_set_addr(ep, (uint32_t) & ptr_job->buf[ptr_job->buf_cnt]);
   82384:	4c42      	ldr	r4, [pc, #264]	; (82490 <udd_ep_trans_done+0x18c>)
   82386:	eb04 1400 	add.w	r4, r4, r0, lsl #4
   8238a:	eb03 0543 	add.w	r5, r3, r3, lsl #1
   8238e:	4e3e      	ldr	r6, [pc, #248]	; (82488 <udd_ep_trans_done+0x184>)
   82390:	eb06 05c5 	add.w	r5, r6, r5, lsl #3
   82394:	686d      	ldr	r5, [r5, #4]
   82396:	4429      	add	r1, r5
   82398:	6061      	str	r1, [r4, #4]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   8239a:	f3ef 8110 	mrs	r1, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   8239e:	fab1 f181 	clz	r1, r1
   823a2:	0949      	lsrs	r1, r1, #5
   823a4:	9101      	str	r1, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   823a6:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   823a8:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   823ac:	2500      	movs	r5, #0
   823ae:	4939      	ldr	r1, [pc, #228]	; (82494 <udd_ep_trans_done+0x190>)
   823b0:	700d      	strb	r5, [r1, #0]
	return flags;
   823b2:	9d01      	ldr	r5, [sp, #4]


		// Disable IRQs to have a short sequence
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
		if (!(udd_endpoint_dma_get_status(ep)
   823b4:	68e1      	ldr	r1, [r4, #12]
   823b6:	f011 0f10 	tst.w	r1, #16
   823ba:	d122      	bne.n	82402 <udd_ep_trans_done+0xfe>
		udd_dma_ctrl |= UOTGHS_DEVDMACONTROL_END_BUFFIT |
   823bc:	f047 0721 	orr.w	r7, r7, #33	; 0x21
				& UOTGHS_DEVDMASTATUS_END_TR_ST)) {
			dbg_print("dmaS%x ", ep);
			udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
   823c0:	60a7      	str	r7, [r4, #8]
			ptr_job->buf_cnt += next_trans;
   823c2:	eb03 0043 	add.w	r0, r3, r3, lsl #1
   823c6:	eb06 01c0 	add.w	r1, r6, r0, lsl #3
   823ca:	68c8      	ldr	r0, [r1, #12]
   823cc:	4410      	add	r0, r2
   823ce:	60c8      	str	r0, [r1, #12]
			ptr_job->buf_load = next_trans;
   823d0:	610a      	str	r2, [r1, #16]
			udd_enable_endpoint_dma_interrupt(ep);
   823d2:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
   823d6:	fa00 f303 	lsl.w	r3, r0, r3
   823da:	4a2f      	ldr	r2, [pc, #188]	; (82498 <udd_ep_trans_done+0x194>)
   823dc:	6193      	str	r3, [r2, #24]
	if (cpu_irq_is_enabled_flags(flags))
   823de:	2d00      	cmp	r5, #0
   823e0:	d04e      	beq.n	82480 <udd_ep_trans_done+0x17c>
		cpu_irq_enable();
   823e2:	2201      	movs	r2, #1
   823e4:	4b2b      	ldr	r3, [pc, #172]	; (82494 <udd_ep_trans_done+0x190>)
   823e6:	701a      	strb	r2, [r3, #0]
   823e8:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   823ec:	b662      	cpsie	i
   823ee:	e047      	b.n	82480 <udd_ep_trans_done+0x17c>
					|| (next_trans <= (iram_size_t) udd_get_endpoint_size(ep))) {
   823f0:	f854 5020 	ldr.w	r5, [r4, r0, lsl #2]
   823f4:	f3c5 1502 	ubfx	r5, r5, #4, #3
   823f8:	2408      	movs	r4, #8
   823fa:	40ac      	lsls	r4, r5
   823fc:	42a2      	cmp	r2, r4
   823fe:	d8c1      	bhi.n	82384 <udd_ep_trans_done+0x80>
   82400:	e7be      	b.n	82380 <udd_ep_trans_done+0x7c>
	if (cpu_irq_is_enabled_flags(flags))
   82402:	b12d      	cbz	r5, 82410 <udd_ep_trans_done+0x10c>
		cpu_irq_enable();
   82404:	2101      	movs	r1, #1
   82406:	4a23      	ldr	r2, [pc, #140]	; (82494 <udd_ep_trans_done+0x190>)
   82408:	7011      	strb	r1, [r2, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   8240a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   8240e:	b662      	cpsie	i
		cpu_irq_restore(flags);

		// Here a ZLP has been recieved
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->buf_cnt;
   82410:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   82414:	491c      	ldr	r1, [pc, #112]	; (82488 <udd_ep_trans_done+0x184>)
   82416:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   8241a:	68d1      	ldr	r1, [r2, #12]
   8241c:	6091      	str	r1, [r2, #8]
	}
	if (Is_udd_endpoint_in(ep)) {
   8241e:	4a1b      	ldr	r2, [pc, #108]	; (8248c <udd_ep_trans_done+0x188>)
   82420:	f852 2020 	ldr.w	r2, [r2, r0, lsl #2]
   82424:	f412 7f80 	tst.w	r2, #256	; 0x100
   82428:	d021      	beq.n	8246e <udd_ep_trans_done+0x16a>
		if (ptr_job->b_shortpacket) {
   8242a:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   8242e:	4916      	ldr	r1, [pc, #88]	; (82488 <udd_ep_trans_done+0x184>)
   82430:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   82434:	7d12      	ldrb	r2, [r2, #20]
   82436:	f012 0f02 	tst.w	r2, #2
   8243a:	d018      	beq.n	8246e <udd_ep_trans_done+0x16a>
			dbg_print("zlpS%x ", ep);
			// Need to send a ZLP (No possible with USB DMA)
			// enable interrupt to wait a free bank to sent ZLP
			udd_ack_in_send(ep);
   8243c:	2201      	movs	r2, #1
   8243e:	4b17      	ldr	r3, [pc, #92]	; (8249c <udd_ep_trans_done+0x198>)
   82440:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
			if (Is_udd_write_enabled(ep)) {
   82444:	3b30      	subs	r3, #48	; 0x30
   82446:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
   8244a:	f413 3f80 	tst.w	r3, #65536	; 0x10000
				// Force interrupt in case of ep already free
				udd_raise_in_send(ep);
   8244e:	bf1c      	itt	ne
   82450:	4b13      	ldrne	r3, [pc, #76]	; (824a0 <udd_ep_trans_done+0x19c>)
   82452:	f843 2020 	strne.w	r2, [r3, r0, lsl #2]
			}
			udd_enable_in_send_interrupt(ep);
   82456:	2201      	movs	r2, #1
   82458:	4b12      	ldr	r3, [pc, #72]	; (824a4 <udd_ep_trans_done+0x1a0>)
   8245a:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
			udd_enable_endpoint_interrupt(ep);
   8245e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   82462:	fa02 f000 	lsl.w	r0, r2, r0
   82466:	f5a3 73f8 	sub.w	r3, r3, #496	; 0x1f0
   8246a:	6198      	str	r0, [r3, #24]
			return;
   8246c:	e008      	b.n	82480 <udd_ep_trans_done+0x17c>
   8246e:	4602      	mov	r2, r0
	ptr_job = &udd_ep_job[ep - 1];
   82470:	eb03 0343 	add.w	r3, r3, r3, lsl #1
		}
	}
	dbg_print("dmaE ");
	// Call callback to signal end of transfer
	udd_ep_finish_job(ptr_job, false, ep);
   82474:	2100      	movs	r1, #0
   82476:	4804      	ldr	r0, [pc, #16]	; (82488 <udd_ep_trans_done+0x184>)
   82478:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
   8247c:	4b0a      	ldr	r3, [pc, #40]	; (824a8 <udd_ep_trans_done+0x1a4>)
   8247e:	4798      	blx	r3
}
   82480:	b003      	add	sp, #12
   82482:	bdf0      	pop	{r4, r5, r6, r7, pc}
   82484:	4770      	bx	lr
   82486:	bf00      	nop
   82488:	200710c0 	.word	0x200710c0
   8248c:	400ac100 	.word	0x400ac100
   82490:	400ac300 	.word	0x400ac300
   82494:	2007026e 	.word	0x2007026e
   82498:	400ac000 	.word	0x400ac000
   8249c:	400ac160 	.word	0x400ac160
   824a0:	400ac190 	.word	0x400ac190
   824a4:	400ac1f0 	.word	0x400ac1f0
   824a8:	000822cd 	.word	0x000822cd

000824ac <udd_sleep_mode>:
{
   824ac:	b082      	sub	sp, #8
	if (!b_idle && udd_b_idle) {
   824ae:	4601      	mov	r1, r0
   824b0:	bb28      	cbnz	r0, 824fe <udd_sleep_mode+0x52>
   824b2:	4b24      	ldr	r3, [pc, #144]	; (82544 <udd_sleep_mode+0x98>)
   824b4:	781b      	ldrb	r3, [r3, #0]
   824b6:	b91b      	cbnz	r3, 824c0 <udd_sleep_mode+0x14>
	udd_b_idle = b_idle;
   824b8:	4b22      	ldr	r3, [pc, #136]	; (82544 <udd_sleep_mode+0x98>)
   824ba:	7019      	strb	r1, [r3, #0]
}
   824bc:	b002      	add	sp, #8
   824be:	4770      	bx	lr
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	irqflags_t flags;

	if(sleepmgr_locks[mode] == 0) {
   824c0:	4b21      	ldr	r3, [pc, #132]	; (82548 <udd_sleep_mode+0x9c>)
   824c2:	789b      	ldrb	r3, [r3, #2]
   824c4:	b903      	cbnz	r3, 824c8 <udd_sleep_mode+0x1c>
   824c6:	e7fe      	b.n	824c6 <udd_sleep_mode+0x1a>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   824c8:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   824cc:	fab3 f383 	clz	r3, r3
   824d0:	095b      	lsrs	r3, r3, #5
   824d2:	9300      	str	r3, [sp, #0]
  __ASM volatile ("cpsid i" : : : "memory");
   824d4:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   824d6:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   824da:	2200      	movs	r2, #0
   824dc:	4b1b      	ldr	r3, [pc, #108]	; (8254c <udd_sleep_mode+0xa0>)
   824de:	701a      	strb	r2, [r3, #0]
	return flags;
   824e0:	9800      	ldr	r0, [sp, #0]
	}

	// Enter a critical section
	flags = cpu_irq_save();

	--sleepmgr_locks[mode];
   824e2:	4a19      	ldr	r2, [pc, #100]	; (82548 <udd_sleep_mode+0x9c>)
   824e4:	7893      	ldrb	r3, [r2, #2]
   824e6:	3b01      	subs	r3, #1
   824e8:	7093      	strb	r3, [r2, #2]
	if (cpu_irq_is_enabled_flags(flags))
   824ea:	2800      	cmp	r0, #0
   824ec:	d0e4      	beq.n	824b8 <udd_sleep_mode+0xc>
		cpu_irq_enable();
   824ee:	2201      	movs	r2, #1
   824f0:	4b16      	ldr	r3, [pc, #88]	; (8254c <udd_sleep_mode+0xa0>)
   824f2:	701a      	strb	r2, [r3, #0]
   824f4:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   824f8:	b662      	cpsie	i
   824fa:	e7dd      	b.n	824b8 <udd_sleep_mode+0xc>
   824fc:	e7fe      	b.n	824fc <udd_sleep_mode+0x50>
	if (b_idle && !udd_b_idle) {
   824fe:	4b11      	ldr	r3, [pc, #68]	; (82544 <udd_sleep_mode+0x98>)
   82500:	781b      	ldrb	r3, [r3, #0]
   82502:	2b00      	cmp	r3, #0
   82504:	d1d8      	bne.n	824b8 <udd_sleep_mode+0xc>
	if(sleepmgr_locks[mode] >= 0xff) {
   82506:	4b10      	ldr	r3, [pc, #64]	; (82548 <udd_sleep_mode+0x9c>)
   82508:	789b      	ldrb	r3, [r3, #2]
   8250a:	2bff      	cmp	r3, #255	; 0xff
   8250c:	d0f6      	beq.n	824fc <udd_sleep_mode+0x50>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   8250e:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   82512:	fab3 f383 	clz	r3, r3
   82516:	095b      	lsrs	r3, r3, #5
   82518:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   8251a:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   8251c:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82520:	2200      	movs	r2, #0
   82522:	4b0a      	ldr	r3, [pc, #40]	; (8254c <udd_sleep_mode+0xa0>)
   82524:	701a      	strb	r2, [r3, #0]
	return flags;
   82526:	9801      	ldr	r0, [sp, #4]
	++sleepmgr_locks[mode];
   82528:	4a07      	ldr	r2, [pc, #28]	; (82548 <udd_sleep_mode+0x9c>)
   8252a:	7893      	ldrb	r3, [r2, #2]
   8252c:	3301      	adds	r3, #1
   8252e:	7093      	strb	r3, [r2, #2]
	if (cpu_irq_is_enabled_flags(flags))
   82530:	2800      	cmp	r0, #0
   82532:	d0c1      	beq.n	824b8 <udd_sleep_mode+0xc>
		cpu_irq_enable();
   82534:	2201      	movs	r2, #1
   82536:	4b05      	ldr	r3, [pc, #20]	; (8254c <udd_sleep_mode+0xa0>)
   82538:	701a      	strb	r2, [r3, #0]
   8253a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   8253e:	b662      	cpsie	i
   82540:	e7ba      	b.n	824b8 <udd_sleep_mode+0xc>
   82542:	bf00      	nop
   82544:	200710b6 	.word	0x200710b6
   82548:	2007535c 	.word	0x2007535c
   8254c:	2007026e 	.word	0x2007026e

00082550 <udd_attach>:
{
   82550:	b570      	push	{r4, r5, r6, lr}
   82552:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   82554:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   82558:	fab3 f383 	clz	r3, r3
   8255c:	095b      	lsrs	r3, r3, #5
   8255e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   82560:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82562:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82566:	2200      	movs	r2, #0
   82568:	4b19      	ldr	r3, [pc, #100]	; (825d0 <udd_attach+0x80>)
   8256a:	701a      	strb	r2, [r3, #0]
	return flags;
   8256c:	9c01      	ldr	r4, [sp, #4]
	udd_sleep_mode(true);
   8256e:	2001      	movs	r0, #1
   82570:	4b18      	ldr	r3, [pc, #96]	; (825d4 <udd_attach+0x84>)
   82572:	4798      	blx	r3
	otg_unfreeze_clock();
   82574:	4a18      	ldr	r2, [pc, #96]	; (825d8 <udd_attach+0x88>)
   82576:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
   8257a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
   8257e:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
	while (!Is_otg_clock_usable());
   82582:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
   82586:	f413 4f80 	tst.w	r3, #16384	; 0x4000
   8258a:	d0fa      	beq.n	82582 <udd_attach+0x32>
	udd_attach_device();
   8258c:	4b12      	ldr	r3, [pc, #72]	; (825d8 <udd_attach+0x88>)
   8258e:	681a      	ldr	r2, [r3, #0]
   82590:	f422 7280 	bic.w	r2, r2, #256	; 0x100
   82594:	601a      	str	r2, [r3, #0]
	udd_enable_reset_interrupt();
   82596:	2608      	movs	r6, #8
   82598:	619e      	str	r6, [r3, #24]
	udd_enable_suspend_interrupt();
   8259a:	2101      	movs	r1, #1
   8259c:	6199      	str	r1, [r3, #24]
	udd_enable_wake_up_interrupt();
   8259e:	2210      	movs	r2, #16
   825a0:	619a      	str	r2, [r3, #24]
	udd_enable_sof_interrupt();
   825a2:	2504      	movs	r5, #4
   825a4:	619d      	str	r5, [r3, #24]
	udd_enable_msof_interrupt();
   825a6:	2002      	movs	r0, #2
   825a8:	6198      	str	r0, [r3, #24]
	udd_ack_reset();
   825aa:	609e      	str	r6, [r3, #8]
	udd_ack_sof();
   825ac:	609d      	str	r5, [r3, #8]
	udd_ack_msof();
   825ae:	6098      	str	r0, [r3, #8]
	udd_raise_suspend();
   825b0:	60d9      	str	r1, [r3, #12]
	udd_ack_wake_up();
   825b2:	609a      	str	r2, [r3, #8]
	otg_freeze_clock();
   825b4:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   825b8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   825bc:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	if (cpu_irq_is_enabled_flags(flags))
   825c0:	b124      	cbz	r4, 825cc <udd_attach+0x7c>
		cpu_irq_enable();
   825c2:	4b03      	ldr	r3, [pc, #12]	; (825d0 <udd_attach+0x80>)
   825c4:	7019      	strb	r1, [r3, #0]
   825c6:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   825ca:	b662      	cpsie	i
}
   825cc:	b002      	add	sp, #8
   825ce:	bd70      	pop	{r4, r5, r6, pc}
   825d0:	2007026e 	.word	0x2007026e
   825d4:	000824ad 	.word	0x000824ad
   825d8:	400ac000 	.word	0x400ac000

000825dc <udd_detach>:
{
   825dc:	b508      	push	{r3, lr}
	otg_unfreeze_clock();
   825de:	4b0a      	ldr	r3, [pc, #40]	; (82608 <udd_detach+0x2c>)
   825e0:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   825e4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   825e8:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	udd_detach_device();
   825ec:	681a      	ldr	r2, [r3, #0]
   825ee:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   825f2:	601a      	str	r2, [r3, #0]
	otg_freeze_clock();
   825f4:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   825f8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   825fc:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
	udd_sleep_mode(false);
   82600:	2000      	movs	r0, #0
   82602:	4b02      	ldr	r3, [pc, #8]	; (8260c <udd_detach+0x30>)
   82604:	4798      	blx	r3
   82606:	bd08      	pop	{r3, pc}
   82608:	400ac000 	.word	0x400ac000
   8260c:	000824ad 	.word	0x000824ad

00082610 <UOTGHS_Handler>:
{
   82610:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   82614:	b085      	sub	sp, #20
	if (!pmc_is_wakeup_clocks_restored() && !Is_udd_suspend()) {
   82616:	4b9a      	ldr	r3, [pc, #616]	; (82880 <UOTGHS_Handler+0x270>)
   82618:	4798      	blx	r3
   8261a:	b920      	cbnz	r0, 82626 <UOTGHS_Handler+0x16>
   8261c:	4b99      	ldr	r3, [pc, #612]	; (82884 <UOTGHS_Handler+0x274>)
   8261e:	685b      	ldr	r3, [r3, #4]
   82620:	f013 0f01 	tst.w	r3, #1
   82624:	d00f      	beq.n	82646 <UOTGHS_Handler+0x36>
	if (Is_udd_sof()) {
   82626:	4b97      	ldr	r3, [pc, #604]	; (82884 <UOTGHS_Handler+0x274>)
   82628:	685b      	ldr	r3, [r3, #4]
   8262a:	f013 0f04 	tst.w	r3, #4
   8262e:	d014      	beq.n	8265a <UOTGHS_Handler+0x4a>
		udd_ack_sof();
   82630:	4b94      	ldr	r3, [pc, #592]	; (82884 <UOTGHS_Handler+0x274>)
   82632:	2204      	movs	r2, #4
   82634:	609a      	str	r2, [r3, #8]
		if (Is_udd_full_speed_mode()) {
   82636:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   8263a:	f413 5f40 	tst.w	r3, #12288	; 0x3000
   8263e:	d009      	beq.n	82654 <UOTGHS_Handler+0x44>
}
   82640:	b005      	add	sp, #20
   82642:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  __ASM volatile ("cpsid i" : : : "memory");
   82646:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82648:	f3bf 8f5f 	dmb	sy
		cpu_irq_disable();
   8264c:	2200      	movs	r2, #0
   8264e:	4b8e      	ldr	r3, [pc, #568]	; (82888 <UOTGHS_Handler+0x278>)
   82650:	701a      	strb	r2, [r3, #0]
		return;
   82652:	e7f5      	b.n	82640 <UOTGHS_Handler+0x30>
			udc_sof_notify();
   82654:	4b8d      	ldr	r3, [pc, #564]	; (8288c <UOTGHS_Handler+0x27c>)
   82656:	4798      	blx	r3
   82658:	e7f2      	b.n	82640 <UOTGHS_Handler+0x30>
	if (Is_udd_msof()) {
   8265a:	4b8a      	ldr	r3, [pc, #552]	; (82884 <UOTGHS_Handler+0x274>)
   8265c:	685b      	ldr	r3, [r3, #4]
   8265e:	f013 0f02 	tst.w	r3, #2
   82662:	d133      	bne.n	826cc <UOTGHS_Handler+0xbc>
	if (!Is_udd_endpoint_interrupt(0)) {
   82664:	4b87      	ldr	r3, [pc, #540]	; (82884 <UOTGHS_Handler+0x274>)
   82666:	685b      	ldr	r3, [r3, #4]
   82668:	f413 5f80 	tst.w	r3, #4096	; 0x1000
   8266c:	d026      	beq.n	826bc <UOTGHS_Handler+0xac>
	udd_disable_nak_in_interrupt(0);
   8266e:	4b88      	ldr	r3, [pc, #544]	; (82890 <UOTGHS_Handler+0x280>)
   82670:	2210      	movs	r2, #16
   82672:	601a      	str	r2, [r3, #0]
	udd_disable_nak_out_interrupt(0);
   82674:	2208      	movs	r2, #8
   82676:	601a      	str	r2, [r3, #0]
	if (Is_udd_setup_received(0)) {
   82678:	3bf0      	subs	r3, #240	; 0xf0
   8267a:	681b      	ldr	r3, [r3, #0]
   8267c:	f013 0f04 	tst.w	r3, #4
   82680:	d12a      	bne.n	826d8 <UOTGHS_Handler+0xc8>
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
   82682:	4b84      	ldr	r3, [pc, #528]	; (82894 <UOTGHS_Handler+0x284>)
   82684:	681b      	ldr	r3, [r3, #0]
   82686:	f013 0f01 	tst.w	r3, #1
   8268a:	d005      	beq.n	82698 <UOTGHS_Handler+0x88>
   8268c:	4b82      	ldr	r3, [pc, #520]	; (82898 <UOTGHS_Handler+0x288>)
   8268e:	681b      	ldr	r3, [r3, #0]
   82690:	f013 0f01 	tst.w	r3, #1
   82694:	f040 8085 	bne.w	827a2 <UOTGHS_Handler+0x192>
	if (Is_udd_out_received(0)) {
   82698:	4b7e      	ldr	r3, [pc, #504]	; (82894 <UOTGHS_Handler+0x284>)
   8269a:	681b      	ldr	r3, [r3, #0]
   8269c:	f013 0f02 	tst.w	r3, #2
   826a0:	f040 8082 	bne.w	827a8 <UOTGHS_Handler+0x198>
	if (Is_udd_nak_out(0)) {
   826a4:	4b7b      	ldr	r3, [pc, #492]	; (82894 <UOTGHS_Handler+0x284>)
   826a6:	681b      	ldr	r3, [r3, #0]
   826a8:	f013 0f08 	tst.w	r3, #8
   826ac:	f040 8130 	bne.w	82910 <UOTGHS_Handler+0x300>
	if (Is_udd_nak_in(0)) {
   826b0:	4b78      	ldr	r3, [pc, #480]	; (82894 <UOTGHS_Handler+0x284>)
   826b2:	681b      	ldr	r3, [r3, #0]
   826b4:	f013 0f10 	tst.w	r3, #16
   826b8:	f040 813d 	bne.w	82936 <UOTGHS_Handler+0x326>
	for (i = 0; i < nb_data; i++) {
   826bc:	4e77      	ldr	r6, [pc, #476]	; (8289c <UOTGHS_Handler+0x28c>)
   826be:	2301      	movs	r3, #1
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];

#ifdef UDD_EP_DMA_SUPPORTED
		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
   826c0:	4a70      	ldr	r2, [pc, #448]	; (82884 <UOTGHS_Handler+0x274>)
   826c2:	f04f 7e00 	mov.w	lr, #33554432	; 0x2000000
				return true;
			}
		}
#endif // UDD_EP_FIFO_SUPPORTED
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
   826c6:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
   826ca:	e17f      	b.n	829cc <UOTGHS_Handler+0x3bc>
		udd_ack_msof();
   826cc:	2202      	movs	r2, #2
   826ce:	4b6d      	ldr	r3, [pc, #436]	; (82884 <UOTGHS_Handler+0x274>)
   826d0:	609a      	str	r2, [r3, #8]
		udc_sof_notify();
   826d2:	4b6e      	ldr	r3, [pc, #440]	; (8288c <UOTGHS_Handler+0x27c>)
   826d4:	4798      	blx	r3
		goto udd_interrupt_sof_end;
   826d6:	e7b3      	b.n	82640 <UOTGHS_Handler+0x30>
	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
   826d8:	4b71      	ldr	r3, [pc, #452]	; (828a0 <UOTGHS_Handler+0x290>)
   826da:	781b      	ldrb	r3, [r3, #0]
   826dc:	2b00      	cmp	r3, #0
   826de:	d141      	bne.n	82764 <UOTGHS_Handler+0x154>
	if (8 != udd_byte_count(0)) {
   826e0:	4b6c      	ldr	r3, [pc, #432]	; (82894 <UOTGHS_Handler+0x284>)
   826e2:	681b      	ldr	r3, [r3, #0]
   826e4:	f3c3 530a 	ubfx	r3, r3, #20, #11
   826e8:	2b08      	cmp	r3, #8
   826ea:	d140      	bne.n	8276e <UOTGHS_Handler+0x15e>
   826ec:	4a6d      	ldr	r2, [pc, #436]	; (828a4 <UOTGHS_Handler+0x294>)
   826ee:	4b6e      	ldr	r3, [pc, #440]	; (828a8 <UOTGHS_Handler+0x298>)
	for (i = 0; i < 8; i++) {
   826f0:	486e      	ldr	r0, [pc, #440]	; (828ac <UOTGHS_Handler+0x29c>)
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
   826f2:	f813 1b01 	ldrb.w	r1, [r3], #1
   826f6:	f802 1f01 	strb.w	r1, [r2, #1]!
	for (i = 0; i < 8; i++) {
   826fa:	4283      	cmp	r3, r0
   826fc:	d1f9      	bne.n	826f2 <UOTGHS_Handler+0xe2>
	if (udc_process_setup() == false) {
   826fe:	4b6c      	ldr	r3, [pc, #432]	; (828b0 <UOTGHS_Handler+0x2a0>)
   82700:	4798      	blx	r3
   82702:	2800      	cmp	r0, #0
   82704:	d039      	beq.n	8277a <UOTGHS_Handler+0x16a>
	udd_ack_setup_received(0);
   82706:	2204      	movs	r2, #4
   82708:	4b6a      	ldr	r3, [pc, #424]	; (828b4 <UOTGHS_Handler+0x2a4>)
   8270a:	601a      	str	r2, [r3, #0]
	if (Udd_setup_is_in()) {
   8270c:	4b6a      	ldr	r3, [pc, #424]	; (828b8 <UOTGHS_Handler+0x2a8>)
   8270e:	f993 3000 	ldrsb.w	r3, [r3]
   82712:	2b00      	cmp	r3, #0
   82714:	db37      	blt.n	82786 <UOTGHS_Handler+0x176>
		if (0 == udd_g_ctrlreq.req.wLength) {
   82716:	4b68      	ldr	r3, [pc, #416]	; (828b8 <UOTGHS_Handler+0x2a8>)
   82718:	88db      	ldrh	r3, [r3, #6]
   8271a:	2b00      	cmp	r3, #0
   8271c:	d03e      	beq.n	8279c <UOTGHS_Handler+0x18c>
		udd_ctrl_prev_payload_buf_cnt = 0;
   8271e:	2200      	movs	r2, #0
   82720:	4b66      	ldr	r3, [pc, #408]	; (828bc <UOTGHS_Handler+0x2ac>)
   82722:	801a      	strh	r2, [r3, #0]
		udd_ctrl_payload_buf_cnt = 0;
   82724:	4b66      	ldr	r3, [pc, #408]	; (828c0 <UOTGHS_Handler+0x2b0>)
   82726:	801a      	strh	r2, [r3, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
   82728:	2101      	movs	r1, #1
   8272a:	4b5d      	ldr	r3, [pc, #372]	; (828a0 <UOTGHS_Handler+0x290>)
   8272c:	7019      	strb	r1, [r3, #0]
		udd_ack_nak_in(0);
   8272e:	2110      	movs	r1, #16
   82730:	4b60      	ldr	r3, [pc, #384]	; (828b4 <UOTGHS_Handler+0x2a4>)
   82732:	6019      	str	r1, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   82734:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   82738:	fab3 f383 	clz	r3, r3
   8273c:	095b      	lsrs	r3, r3, #5
   8273e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   82740:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82742:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82746:	4b50      	ldr	r3, [pc, #320]	; (82888 <UOTGHS_Handler+0x278>)
   82748:	701a      	strb	r2, [r3, #0]
	return flags;
   8274a:	9b01      	ldr	r3, [sp, #4]
		udd_enable_nak_in_interrupt(0);
   8274c:	4a5d      	ldr	r2, [pc, #372]	; (828c4 <UOTGHS_Handler+0x2b4>)
   8274e:	6011      	str	r1, [r2, #0]
	if (cpu_irq_is_enabled_flags(flags))
   82750:	2b00      	cmp	r3, #0
   82752:	f43f af75 	beq.w	82640 <UOTGHS_Handler+0x30>
		cpu_irq_enable();
   82756:	2201      	movs	r2, #1
   82758:	4b4b      	ldr	r3, [pc, #300]	; (82888 <UOTGHS_Handler+0x278>)
   8275a:	701a      	strb	r2, [r3, #0]
   8275c:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82760:	b662      	cpsie	i
   82762:	e76d      	b.n	82640 <UOTGHS_Handler+0x30>
		udd_ctrl_endofrequest();
   82764:	4b58      	ldr	r3, [pc, #352]	; (828c8 <UOTGHS_Handler+0x2b8>)
   82766:	4798      	blx	r3
		udd_ctrl_init();
   82768:	4b58      	ldr	r3, [pc, #352]	; (828cc <UOTGHS_Handler+0x2bc>)
   8276a:	4798      	blx	r3
   8276c:	e7b8      	b.n	826e0 <UOTGHS_Handler+0xd0>
		udd_ctrl_stall_data();
   8276e:	4b58      	ldr	r3, [pc, #352]	; (828d0 <UOTGHS_Handler+0x2c0>)
   82770:	4798      	blx	r3
		udd_ack_setup_received(0);
   82772:	2204      	movs	r2, #4
   82774:	4b4f      	ldr	r3, [pc, #316]	; (828b4 <UOTGHS_Handler+0x2a4>)
   82776:	601a      	str	r2, [r3, #0]
   82778:	e762      	b.n	82640 <UOTGHS_Handler+0x30>
		udd_ctrl_stall_data();
   8277a:	4b55      	ldr	r3, [pc, #340]	; (828d0 <UOTGHS_Handler+0x2c0>)
   8277c:	4798      	blx	r3
		udd_ack_setup_received(0);
   8277e:	2204      	movs	r2, #4
   82780:	4b4c      	ldr	r3, [pc, #304]	; (828b4 <UOTGHS_Handler+0x2a4>)
   82782:	601a      	str	r2, [r3, #0]
   82784:	e75c      	b.n	82640 <UOTGHS_Handler+0x30>
		udd_ctrl_prev_payload_buf_cnt = 0;
   82786:	2300      	movs	r3, #0
   82788:	4a4c      	ldr	r2, [pc, #304]	; (828bc <UOTGHS_Handler+0x2ac>)
   8278a:	8013      	strh	r3, [r2, #0]
		udd_ctrl_payload_buf_cnt = 0;
   8278c:	4a4c      	ldr	r2, [pc, #304]	; (828c0 <UOTGHS_Handler+0x2b0>)
   8278e:	8013      	strh	r3, [r2, #0]
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
   82790:	2202      	movs	r2, #2
   82792:	4b43      	ldr	r3, [pc, #268]	; (828a0 <UOTGHS_Handler+0x290>)
   82794:	701a      	strb	r2, [r3, #0]
		udd_ctrl_in_sent(); // Send first data transfer
   82796:	4b4f      	ldr	r3, [pc, #316]	; (828d4 <UOTGHS_Handler+0x2c4>)
   82798:	4798      	blx	r3
   8279a:	e751      	b.n	82640 <UOTGHS_Handler+0x30>
			udd_ctrl_send_zlp_in();
   8279c:	4b4e      	ldr	r3, [pc, #312]	; (828d8 <UOTGHS_Handler+0x2c8>)
   8279e:	4798      	blx	r3
   827a0:	e74e      	b.n	82640 <UOTGHS_Handler+0x30>
		udd_ctrl_in_sent();
   827a2:	4b4c      	ldr	r3, [pc, #304]	; (828d4 <UOTGHS_Handler+0x2c4>)
   827a4:	4798      	blx	r3
   827a6:	e74b      	b.n	82640 <UOTGHS_Handler+0x30>
	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
   827a8:	4b3d      	ldr	r3, [pc, #244]	; (828a0 <UOTGHS_Handler+0x290>)
   827aa:	781b      	ldrb	r3, [r3, #0]
   827ac:	2b01      	cmp	r3, #1
   827ae:	d00b      	beq.n	827c8 <UOTGHS_Handler+0x1b8>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
   827b0:	2b02      	cmp	r3, #2
   827b2:	d004      	beq.n	827be <UOTGHS_Handler+0x1ae>
				|| (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP ==
   827b4:	2b04      	cmp	r3, #4
   827b6:	d002      	beq.n	827be <UOTGHS_Handler+0x1ae>
			udd_ctrl_stall_data();
   827b8:	4b45      	ldr	r3, [pc, #276]	; (828d0 <UOTGHS_Handler+0x2c0>)
   827ba:	4798      	blx	r3
   827bc:	e001      	b.n	827c2 <UOTGHS_Handler+0x1b2>
			udd_ctrl_endofrequest();
   827be:	4b42      	ldr	r3, [pc, #264]	; (828c8 <UOTGHS_Handler+0x2b8>)
   827c0:	4798      	blx	r3
		udd_ctrl_init();
   827c2:	4b42      	ldr	r3, [pc, #264]	; (828cc <UOTGHS_Handler+0x2bc>)
   827c4:	4798      	blx	r3
   827c6:	e73b      	b.n	82640 <UOTGHS_Handler+0x30>
	nb_data = udd_byte_count(0);
   827c8:	4b32      	ldr	r3, [pc, #200]	; (82894 <UOTGHS_Handler+0x284>)
   827ca:	6818      	ldr	r0, [r3, #0]
   827cc:	f3c0 500a 	ubfx	r0, r0, #20, #11
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_buf_cnt + nb_data)) {
   827d0:	4b39      	ldr	r3, [pc, #228]	; (828b8 <UOTGHS_Handler+0x2a8>)
   827d2:	899b      	ldrh	r3, [r3, #12]
   827d4:	4a3a      	ldr	r2, [pc, #232]	; (828c0 <UOTGHS_Handler+0x2b0>)
   827d6:	8814      	ldrh	r4, [r2, #0]
   827d8:	1822      	adds	r2, r4, r0
   827da:	4293      	cmp	r3, r2
		nb_data = udd_g_ctrlreq.payload_size - udd_ctrl_payload_buf_cnt;
   827dc:	bfbc      	itt	lt
   827de:	1b1b      	sublt	r3, r3, r4
   827e0:	b298      	uxthlt	r0, r3
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_buf_cnt;
   827e2:	4b35      	ldr	r3, [pc, #212]	; (828b8 <UOTGHS_Handler+0x2a8>)
   827e4:	689a      	ldr	r2, [r3, #8]
	for (i = 0; i < nb_data; i++) {
   827e6:	b178      	cbz	r0, 82808 <UOTGHS_Handler+0x1f8>
   827e8:	1e63      	subs	r3, r4, #1
   827ea:	441a      	add	r2, r3
   827ec:	4b2e      	ldr	r3, [pc, #184]	; (828a8 <UOTGHS_Handler+0x298>)
		*ptr_dest++ = *ptr_src++;
   827ee:	f813 1b01 	ldrb.w	r1, [r3], #1
   827f2:	f802 1f01 	strb.w	r1, [r2, #1]!
	for (i = 0; i < nb_data; i++) {
   827f6:	b2d9      	uxtb	r1, r3
   827f8:	4281      	cmp	r1, r0
   827fa:	d3f8      	bcc.n	827ee <UOTGHS_Handler+0x1de>
	udd_ctrl_payload_buf_cnt += nb_data;
   827fc:	4404      	add	r4, r0
   827fe:	b2a4      	uxth	r4, r4
   82800:	4b2f      	ldr	r3, [pc, #188]	; (828c0 <UOTGHS_Handler+0x2b0>)
   82802:	801c      	strh	r4, [r3, #0]
	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
   82804:	2840      	cmp	r0, #64	; 0x40
   82806:	d00c      	beq.n	82822 <UOTGHS_Handler+0x212>
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_buf_cnt;
   82808:	4b2b      	ldr	r3, [pc, #172]	; (828b8 <UOTGHS_Handler+0x2a8>)
   8280a:	819c      	strh	r4, [r3, #12]
		if (NULL != udd_g_ctrlreq.over_under_run) {
   8280c:	695b      	ldr	r3, [r3, #20]
   8280e:	b113      	cbz	r3, 82816 <UOTGHS_Handler+0x206>
			if (!udd_g_ctrlreq.over_under_run()) {
   82810:	4798      	blx	r3
   82812:	2800      	cmp	r0, #0
   82814:	d02e      	beq.n	82874 <UOTGHS_Handler+0x264>
		udd_ack_out_received(0);
   82816:	2202      	movs	r2, #2
   82818:	4b26      	ldr	r3, [pc, #152]	; (828b4 <UOTGHS_Handler+0x2a4>)
   8281a:	601a      	str	r2, [r3, #0]
		udd_ctrl_send_zlp_in();
   8281c:	4b2e      	ldr	r3, [pc, #184]	; (828d8 <UOTGHS_Handler+0x2c8>)
   8281e:	4798      	blx	r3
   82820:	e70e      	b.n	82640 <UOTGHS_Handler+0x30>
			|| (udd_g_ctrlreq.req.wLength <=
   82822:	4b25      	ldr	r3, [pc, #148]	; (828b8 <UOTGHS_Handler+0x2a8>)
   82824:	88da      	ldrh	r2, [r3, #6]
					(udd_ctrl_prev_payload_buf_cnt +
   82826:	4b25      	ldr	r3, [pc, #148]	; (828bc <UOTGHS_Handler+0x2ac>)
   82828:	881b      	ldrh	r3, [r3, #0]
   8282a:	4423      	add	r3, r4
			|| (udd_g_ctrlreq.req.wLength <=
   8282c:	429a      	cmp	r2, r3
   8282e:	ddeb      	ble.n	82808 <UOTGHS_Handler+0x1f8>
	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_buf_cnt) {
   82830:	4b21      	ldr	r3, [pc, #132]	; (828b8 <UOTGHS_Handler+0x2a8>)
   82832:	899b      	ldrh	r3, [r3, #12]
   82834:	42a3      	cmp	r3, r4
   82836:	d051      	beq.n	828dc <UOTGHS_Handler+0x2cc>
	udd_ack_out_received(0);
   82838:	4b1e      	ldr	r3, [pc, #120]	; (828b4 <UOTGHS_Handler+0x2a4>)
   8283a:	2202      	movs	r2, #2
   8283c:	601a      	str	r2, [r3, #0]
	udd_ack_nak_in(0);
   8283e:	2210      	movs	r2, #16
   82840:	601a      	str	r2, [r3, #0]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   82842:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   82846:	fab3 f383 	clz	r3, r3
   8284a:	095b      	lsrs	r3, r3, #5
   8284c:	9302      	str	r3, [sp, #8]
  __ASM volatile ("cpsid i" : : : "memory");
   8284e:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82850:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82854:	2100      	movs	r1, #0
   82856:	4b0c      	ldr	r3, [pc, #48]	; (82888 <UOTGHS_Handler+0x278>)
   82858:	7019      	strb	r1, [r3, #0]
	return flags;
   8285a:	9b02      	ldr	r3, [sp, #8]
	udd_enable_nak_in_interrupt(0);
   8285c:	4919      	ldr	r1, [pc, #100]	; (828c4 <UOTGHS_Handler+0x2b4>)
   8285e:	600a      	str	r2, [r1, #0]
	if (cpu_irq_is_enabled_flags(flags))
   82860:	2b00      	cmp	r3, #0
   82862:	f43f aeed 	beq.w	82640 <UOTGHS_Handler+0x30>
		cpu_irq_enable();
   82866:	2201      	movs	r2, #1
   82868:	4b07      	ldr	r3, [pc, #28]	; (82888 <UOTGHS_Handler+0x278>)
   8286a:	701a      	strb	r2, [r3, #0]
   8286c:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82870:	b662      	cpsie	i
   82872:	e6e5      	b.n	82640 <UOTGHS_Handler+0x30>
				udd_ctrl_stall_data();
   82874:	4b16      	ldr	r3, [pc, #88]	; (828d0 <UOTGHS_Handler+0x2c0>)
   82876:	4798      	blx	r3
				udd_ack_out_received(0);
   82878:	2202      	movs	r2, #2
   8287a:	4b0e      	ldr	r3, [pc, #56]	; (828b4 <UOTGHS_Handler+0x2a4>)
   8287c:	601a      	str	r2, [r3, #0]
   8287e:	e6df      	b.n	82640 <UOTGHS_Handler+0x30>
   82880:	00082041 	.word	0x00082041
   82884:	400ac000 	.word	0x400ac000
   82888:	2007026e 	.word	0x2007026e
   8288c:	00081659 	.word	0x00081659
   82890:	400ac220 	.word	0x400ac220
   82894:	400ac130 	.word	0x400ac130
   82898:	400ac1c0 	.word	0x400ac1c0
   8289c:	400ac134 	.word	0x400ac134
   828a0:	200710bc 	.word	0x200710bc
   828a4:	20075363 	.word	0x20075363
   828a8:	20180000 	.word	0x20180000
   828ac:	20180008 	.word	0x20180008
   828b0:	00081699 	.word	0x00081699
   828b4:	400ac160 	.word	0x400ac160
   828b8:	20075364 	.word	0x20075364
   828bc:	200710ba 	.word	0x200710ba
   828c0:	200710b8 	.word	0x200710b8
   828c4:	400ac1f0 	.word	0x400ac1f0
   828c8:	00082141 	.word	0x00082141
   828cc:	00082079 	.word	0x00082079
   828d0:	000820d5 	.word	0x000820d5
   828d4:	00082151 	.word	0x00082151
   828d8:	000820ed 	.word	0x000820ed
		if (!udd_g_ctrlreq.over_under_run) {
   828dc:	4ba5      	ldr	r3, [pc, #660]	; (82b74 <UOTGHS_Handler+0x564>)
   828de:	695b      	ldr	r3, [r3, #20]
   828e0:	b153      	cbz	r3, 828f8 <UOTGHS_Handler+0x2e8>
		if (!udd_g_ctrlreq.over_under_run()) {
   828e2:	4798      	blx	r3
   828e4:	b170      	cbz	r0, 82904 <UOTGHS_Handler+0x2f4>
		udd_ctrl_prev_payload_buf_cnt += udd_ctrl_payload_buf_cnt;
   828e6:	49a4      	ldr	r1, [pc, #656]	; (82b78 <UOTGHS_Handler+0x568>)
   828e8:	4aa4      	ldr	r2, [pc, #656]	; (82b7c <UOTGHS_Handler+0x56c>)
   828ea:	880b      	ldrh	r3, [r1, #0]
   828ec:	8810      	ldrh	r0, [r2, #0]
   828ee:	4403      	add	r3, r0
   828f0:	800b      	strh	r3, [r1, #0]
		udd_ctrl_payload_buf_cnt = 0;
   828f2:	2300      	movs	r3, #0
   828f4:	8013      	strh	r3, [r2, #0]
   828f6:	e79f      	b.n	82838 <UOTGHS_Handler+0x228>
			udd_ctrl_stall_data();
   828f8:	4ba1      	ldr	r3, [pc, #644]	; (82b80 <UOTGHS_Handler+0x570>)
   828fa:	4798      	blx	r3
			udd_ack_out_received(0);
   828fc:	2202      	movs	r2, #2
   828fe:	4ba1      	ldr	r3, [pc, #644]	; (82b84 <UOTGHS_Handler+0x574>)
   82900:	601a      	str	r2, [r3, #0]
   82902:	e69d      	b.n	82640 <UOTGHS_Handler+0x30>
			udd_ctrl_stall_data();
   82904:	4b9e      	ldr	r3, [pc, #632]	; (82b80 <UOTGHS_Handler+0x570>)
   82906:	4798      	blx	r3
			udd_ack_out_received(0);
   82908:	2202      	movs	r2, #2
   8290a:	4b9e      	ldr	r3, [pc, #632]	; (82b84 <UOTGHS_Handler+0x574>)
   8290c:	601a      	str	r2, [r3, #0]
   8290e:	e697      	b.n	82640 <UOTGHS_Handler+0x30>
		udd_ack_nak_out(0);
   82910:	2208      	movs	r2, #8
   82912:	4b9c      	ldr	r3, [pc, #624]	; (82b84 <UOTGHS_Handler+0x574>)
   82914:	601a      	str	r2, [r3, #0]
	if (Is_udd_in_send(0))
   82916:	3b30      	subs	r3, #48	; 0x30
   82918:	681b      	ldr	r3, [r3, #0]
   8291a:	f013 0f01 	tst.w	r3, #1
   8291e:	f47f ae8f 	bne.w	82640 <UOTGHS_Handler+0x30>
	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
   82922:	4b99      	ldr	r3, [pc, #612]	; (82b88 <UOTGHS_Handler+0x578>)
   82924:	781b      	ldrb	r3, [r3, #0]
   82926:	2b03      	cmp	r3, #3
   82928:	f47f ae8a 	bne.w	82640 <UOTGHS_Handler+0x30>
		udd_enable_stall_handshake(0);
   8292c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   82930:	4b96      	ldr	r3, [pc, #600]	; (82b8c <UOTGHS_Handler+0x57c>)
   82932:	601a      	str	r2, [r3, #0]
   82934:	e684      	b.n	82640 <UOTGHS_Handler+0x30>
		udd_ack_nak_in(0);
   82936:	2210      	movs	r2, #16
   82938:	4b92      	ldr	r3, [pc, #584]	; (82b84 <UOTGHS_Handler+0x574>)
   8293a:	601a      	str	r2, [r3, #0]
	if (Is_udd_out_received(0))
   8293c:	3b30      	subs	r3, #48	; 0x30
   8293e:	681b      	ldr	r3, [r3, #0]
   82940:	f013 0f02 	tst.w	r3, #2
   82944:	f47f ae7c 	bne.w	82640 <UOTGHS_Handler+0x30>
	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
   82948:	4b8f      	ldr	r3, [pc, #572]	; (82b88 <UOTGHS_Handler+0x578>)
   8294a:	781b      	ldrb	r3, [r3, #0]
   8294c:	2b01      	cmp	r3, #1
   8294e:	d007      	beq.n	82960 <UOTGHS_Handler+0x350>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
   82950:	2b04      	cmp	r3, #4
   82952:	f47f ae75 	bne.w	82640 <UOTGHS_Handler+0x30>
		udd_enable_stall_handshake(0);
   82956:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   8295a:	4b8c      	ldr	r3, [pc, #560]	; (82b8c <UOTGHS_Handler+0x57c>)
   8295c:	601a      	str	r2, [r3, #0]
   8295e:	e66f      	b.n	82640 <UOTGHS_Handler+0x30>
		udd_ctrl_send_zlp_in();
   82960:	4b8b      	ldr	r3, [pc, #556]	; (82b90 <UOTGHS_Handler+0x580>)
   82962:	4798      	blx	r3
   82964:	e66c      	b.n	82640 <UOTGHS_Handler+0x30>
			if (udd_endpoint_dma_get_status(ep)
   82966:	4b8b      	ldr	r3, [pc, #556]	; (82b94 <UOTGHS_Handler+0x584>)
   82968:	eb03 1300 	add.w	r3, r3, r0, lsl #4
   8296c:	68da      	ldr	r2, [r3, #12]
   8296e:	f012 0f01 	tst.w	r2, #1
   82972:	f47f ae65 	bne.w	82640 <UOTGHS_Handler+0x30>
			udd_disable_endpoint_dma_interrupt(ep);
   82976:	4a88      	ldr	r2, [pc, #544]	; (82b98 <UOTGHS_Handler+0x588>)
   82978:	6151      	str	r1, [r2, #20]
			nb_remaining = (udd_endpoint_dma_get_status(ep) &
   8297a:	68dd      	ldr	r5, [r3, #12]
			if (nb_remaining) {
   8297c:	0c2d      	lsrs	r5, r5, #16
   8297e:	d008      	beq.n	82992 <UOTGHS_Handler+0x382>
				ptr_job->buf_cnt -= nb_remaining;
   82980:	4b86      	ldr	r3, [pc, #536]	; (82b9c <UOTGHS_Handler+0x58c>)
   82982:	0079      	lsls	r1, r7, #1
   82984:	19cc      	adds	r4, r1, r7
   82986:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   8298a:	68e2      	ldr	r2, [r4, #12]
   8298c:	1b52      	subs	r2, r2, r5
   8298e:	60e2      	str	r2, [r4, #12]
				ptr_job->buf_size = ptr_job->buf_cnt;
   82990:	60a2      	str	r2, [r4, #8]
			udd_ep_trans_done(ep);
   82992:	4b83      	ldr	r3, [pc, #524]	; (82ba0 <UOTGHS_Handler+0x590>)
   82994:	4798      	blx	r3
   82996:	e653      	b.n	82640 <UOTGHS_Handler+0x30>
			dbg_print("bg%x: ", ep);
			if (Is_udd_in_send_interrupt_enabled(ep)
					&& Is_udd_in_send(ep)) {
				dbg_print("I ");
				udd_disable_in_send_interrupt(ep);
   82998:	4b82      	ldr	r3, [pc, #520]	; (82ba4 <UOTGHS_Handler+0x594>)
   8299a:	2201      	movs	r2, #1
   8299c:	f849 2003 	str.w	r2, [r9, r3]
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
   829a0:	4978      	ldr	r1, [pc, #480]	; (82b84 <UOTGHS_Handler+0x574>)
   829a2:	f849 2001 	str.w	r2, [r9, r1]
				udd_ack_fifocon(ep);
   829a6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   829aa:	f849 2003 	str.w	r2, [r9, r3]
		ptr_job = &udd_ep_job[ep - 1];
   829ae:	eb07 0747 	add.w	r7, r7, r7, lsl #1
				udd_ep_finish_job(ptr_job, false, ep);
   829b2:	4602      	mov	r2, r0
   829b4:	2100      	movs	r1, #0
   829b6:	4879      	ldr	r0, [pc, #484]	; (82b9c <UOTGHS_Handler+0x58c>)
   829b8:	eb00 00c7 	add.w	r0, r0, r7, lsl #3
   829bc:	4b7a      	ldr	r3, [pc, #488]	; (82ba8 <UOTGHS_Handler+0x598>)
   829be:	4798      	blx	r3
   829c0:	e63e      	b.n	82640 <UOTGHS_Handler+0x30>
   829c2:	3301      	adds	r3, #1
   829c4:	3604      	adds	r6, #4
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
   829c6:	2b04      	cmp	r3, #4
   829c8:	f000 8100 	beq.w	82bcc <UOTGHS_Handler+0x5bc>
   829cc:	b2d8      	uxtb	r0, r3
		ptr_job = &udd_ep_job[ep - 1];
   829ce:	461d      	mov	r5, r3
   829d0:	1e5f      	subs	r7, r3, #1
   829d2:	46b8      	mov	r8, r7
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
   829d4:	6914      	ldr	r4, [r2, #16]
   829d6:	fa0e f107 	lsl.w	r1, lr, r7
   829da:	420c      	tst	r4, r1
   829dc:	d002      	beq.n	829e4 <UOTGHS_Handler+0x3d4>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
   829de:	6854      	ldr	r4, [r2, #4]
   829e0:	4221      	tst	r1, r4
   829e2:	d1c0      	bne.n	82966 <UOTGHS_Handler+0x356>
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
   829e4:	6911      	ldr	r1, [r2, #16]
   829e6:	fa0c f505 	lsl.w	r5, ip, r5
   829ea:	4229      	tst	r1, r5
   829ec:	d0e9      	beq.n	829c2 <UOTGHS_Handler+0x3b2>
   829ee:	ea4f 0983 	mov.w	r9, r3, lsl #2
   829f2:	f106 0490 	add.w	r4, r6, #144	; 0x90
			if (Is_udd_in_send_interrupt_enabled(ep)
   829f6:	f8d6 1090 	ldr.w	r1, [r6, #144]	; 0x90
   829fa:	f011 0f01 	tst.w	r1, #1
   829fe:	d003      	beq.n	82a08 <UOTGHS_Handler+0x3f8>
					&& Is_udd_in_send(ep)) {
   82a00:	6831      	ldr	r1, [r6, #0]
   82a02:	f011 0f01 	tst.w	r1, #1
   82a06:	d1c7      	bne.n	82998 <UOTGHS_Handler+0x388>
				return true;
			}
			if (Is_udd_bank_interrupt_enabled(ep)
   82a08:	6821      	ldr	r1, [r4, #0]
   82a0a:	f411 5f80 	tst.w	r1, #4096	; 0x1000
   82a0e:	d0d8      	beq.n	829c2 <UOTGHS_Handler+0x3b2>
					&& (0 == udd_nb_busy_bank(ep))) {
   82a10:	6831      	ldr	r1, [r6, #0]
   82a12:	f411 5f40 	tst.w	r1, #12288	; 0x3000
   82a16:	d1d4      	bne.n	829c2 <UOTGHS_Handler+0x3b2>
				dbg_print("EoT ");
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
   82a18:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   82a1c:	4b61      	ldr	r3, [pc, #388]	; (82ba4 <UOTGHS_Handler+0x594>)
   82a1e:	f849 2003 	str.w	r2, [r9, r3]
				udd_disable_endpoint_interrupt(ep);
   82a22:	f5a3 7308 	sub.w	r3, r3, #544	; 0x220
   82a26:	615d      	str	r5, [r3, #20]

				Assert(ptr_job->stall_requested);
				// A stall has been requested during backgound transfer
				ptr_job->stall_requested = false;
   82a28:	eb08 0848 	add.w	r8, r8, r8, lsl #1
   82a2c:	4b5b      	ldr	r3, [pc, #364]	; (82b9c <UOTGHS_Handler+0x58c>)
   82a2e:	eb03 08c8 	add.w	r8, r3, r8, lsl #3
   82a32:	f898 2014 	ldrb.w	r2, [r8, #20]
   82a36:	f36f 0282 	bfc	r2, #2, #1
   82a3a:	f888 2014 	strb.w	r2, [r8, #20]
				udd_disable_endpoint_bank_autoswitch(ep);
   82a3e:	4a5b      	ldr	r2, [pc, #364]	; (82bac <UOTGHS_Handler+0x59c>)
   82a40:	f859 3002 	ldr.w	r3, [r9, r2]
   82a44:	f423 7300 	bic.w	r3, r3, #512	; 0x200
   82a48:	f849 3002 	str.w	r3, [r9, r2]
				udd_enable_stall_handshake(ep);
   82a4c:	4b4f      	ldr	r3, [pc, #316]	; (82b8c <UOTGHS_Handler+0x57c>)
   82a4e:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   82a52:	f849 2003 	str.w	r2, [r9, r3]
				udd_reset_data_toggle(ep);
   82a56:	f44f 2280 	mov.w	r2, #262144	; 0x40000
   82a5a:	f849 2003 	str.w	r2, [r9, r3]
   82a5e:	e5ef      	b.n	82640 <UOTGHS_Handler+0x30>
		udd_ack_reset();
   82a60:	4c4d      	ldr	r4, [pc, #308]	; (82b98 <UOTGHS_Handler+0x588>)
   82a62:	2308      	movs	r3, #8
   82a64:	60a3      	str	r3, [r4, #8]
		udd_ep_finish_job(&udd_ep_job[i], true, i + 1);
   82a66:	4e4d      	ldr	r6, [pc, #308]	; (82b9c <UOTGHS_Handler+0x58c>)
   82a68:	2201      	movs	r2, #1
   82a6a:	4611      	mov	r1, r2
   82a6c:	4630      	mov	r0, r6
   82a6e:	4d4e      	ldr	r5, [pc, #312]	; (82ba8 <UOTGHS_Handler+0x598>)
   82a70:	47a8      	blx	r5
   82a72:	2202      	movs	r2, #2
   82a74:	2101      	movs	r1, #1
   82a76:	f106 0018 	add.w	r0, r6, #24
   82a7a:	47a8      	blx	r5
   82a7c:	2203      	movs	r2, #3
   82a7e:	2101      	movs	r1, #1
   82a80:	f106 0030 	add.w	r0, r6, #48	; 0x30
   82a84:	47a8      	blx	r5
		udc_reset();
   82a86:	4b4a      	ldr	r3, [pc, #296]	; (82bb0 <UOTGHS_Handler+0x5a0>)
   82a88:	4798      	blx	r3
	udd_configure_address(0);
   82a8a:	6823      	ldr	r3, [r4, #0]
   82a8c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   82a90:	6023      	str	r3, [r4, #0]
	udd_enable_address();
   82a92:	6823      	ldr	r3, [r4, #0]
   82a94:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   82a98:	6023      	str	r3, [r4, #0]
	udd_configure_endpoint(0,
   82a9a:	4a44      	ldr	r2, [pc, #272]	; (82bac <UOTGHS_Handler+0x59c>)
   82a9c:	6813      	ldr	r3, [r2, #0]
   82a9e:	f423 53cb 	bic.w	r3, r3, #6496	; 0x1960
   82aa2:	f023 031c 	bic.w	r3, r3, #28
   82aa6:	f043 0330 	orr.w	r3, r3, #48	; 0x30
   82aaa:	6013      	str	r3, [r2, #0]
	udd_allocate_memory(0);
   82aac:	6813      	ldr	r3, [r2, #0]
   82aae:	f043 0302 	orr.w	r3, r3, #2
   82ab2:	6013      	str	r3, [r2, #0]
	udd_enable_endpoint(0);
   82ab4:	69e3      	ldr	r3, [r4, #28]
   82ab6:	f043 0301 	orr.w	r3, r3, #1
   82aba:	61e3      	str	r3, [r4, #28]
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   82abc:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   82ac0:	fab3 f383 	clz	r3, r3
   82ac4:	095b      	lsrs	r3, r3, #5
   82ac6:	9303      	str	r3, [sp, #12]
  __ASM volatile ("cpsid i" : : : "memory");
   82ac8:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82aca:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82ace:	2200      	movs	r2, #0
   82ad0:	4b38      	ldr	r3, [pc, #224]	; (82bb4 <UOTGHS_Handler+0x5a4>)
   82ad2:	701a      	strb	r2, [r3, #0]
	return flags;
   82ad4:	9a03      	ldr	r2, [sp, #12]
	udd_enable_setup_received_interrupt(0);
   82ad6:	4b2d      	ldr	r3, [pc, #180]	; (82b8c <UOTGHS_Handler+0x57c>)
   82ad8:	2104      	movs	r1, #4
   82ada:	6019      	str	r1, [r3, #0]
	udd_enable_out_received_interrupt(0);
   82adc:	2102      	movs	r1, #2
   82ade:	6019      	str	r1, [r3, #0]
	udd_enable_endpoint_interrupt(0);
   82ae0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   82ae4:	61a3      	str	r3, [r4, #24]
	if (cpu_irq_is_enabled_flags(flags))
   82ae6:	b12a      	cbz	r2, 82af4 <UOTGHS_Handler+0x4e4>
		cpu_irq_enable();
   82ae8:	2201      	movs	r2, #1
   82aea:	4b32      	ldr	r3, [pc, #200]	; (82bb4 <UOTGHS_Handler+0x5a4>)
   82aec:	701a      	strb	r2, [r3, #0]
   82aee:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82af2:	b662      	cpsie	i
		udd_ctrl_init();
   82af4:	4b30      	ldr	r3, [pc, #192]	; (82bb8 <UOTGHS_Handler+0x5a8>)
   82af6:	4798      	blx	r3
		goto udd_interrupt_end;
   82af8:	e5a2      	b.n	82640 <UOTGHS_Handler+0x30>
		otg_unfreeze_clock();
   82afa:	4b27      	ldr	r3, [pc, #156]	; (82b98 <UOTGHS_Handler+0x588>)
   82afc:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82b00:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   82b04:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		udd_disable_suspend_interrupt();
   82b08:	2201      	movs	r2, #1
   82b0a:	615a      	str	r2, [r3, #20]
		udd_enable_wake_up_interrupt();
   82b0c:	2210      	movs	r2, #16
   82b0e:	619a      	str	r2, [r3, #24]
		otg_freeze_clock(); // Mandatory to exit of sleep mode after a wakeup event
   82b10:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82b14:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   82b18:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		udd_sleep_mode(false);  // Enter in SUSPEND mode
   82b1c:	2000      	movs	r0, #0
   82b1e:	4b27      	ldr	r3, [pc, #156]	; (82bbc <UOTGHS_Handler+0x5ac>)
   82b20:	4798      	blx	r3
		goto udd_interrupt_end;
   82b22:	e58d      	b.n	82640 <UOTGHS_Handler+0x30>
	if (Is_otg_vbus_transition()) {
   82b24:	4b1c      	ldr	r3, [pc, #112]	; (82b98 <UOTGHS_Handler+0x588>)
   82b26:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   82b2a:	f013 0f02 	tst.w	r3, #2
   82b2e:	f43f ad87 	beq.w	82640 <UOTGHS_Handler+0x30>
		otg_unfreeze_clock();
   82b32:	4b19      	ldr	r3, [pc, #100]	; (82b98 <UOTGHS_Handler+0x588>)
   82b34:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82b38:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
   82b3c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		otg_ack_vbus_transition();
   82b40:	2202      	movs	r2, #2
   82b42:	f8c3 2808 	str.w	r2, [r3, #2056]	; 0x808
		otg_freeze_clock();
   82b46:	f8d3 2800 	ldr.w	r2, [r3, #2048]	; 0x800
   82b4a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
   82b4e:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
		if (Is_otg_vbus_high()) {
   82b52:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
   82b56:	f413 6f00 	tst.w	r3, #2048	; 0x800
			udd_attach();
   82b5a:	bf14      	ite	ne
   82b5c:	4b18      	ldrne	r3, [pc, #96]	; (82bc0 <UOTGHS_Handler+0x5b0>)
			udd_detach();
   82b5e:	4b19      	ldreq	r3, [pc, #100]	; (82bc4 <UOTGHS_Handler+0x5b4>)
   82b60:	4798      	blx	r3
		UDC_VBUS_EVENT(Is_otg_vbus_high());
   82b62:	4b0d      	ldr	r3, [pc, #52]	; (82b98 <UOTGHS_Handler+0x588>)
   82b64:	f8d3 0804 	ldr.w	r0, [r3, #2052]	; 0x804
   82b68:	f3c0 20c0 	ubfx	r0, r0, #11, #1
   82b6c:	4b16      	ldr	r3, [pc, #88]	; (82bc8 <UOTGHS_Handler+0x5b8>)
   82b6e:	4798      	blx	r3
		goto udd_interrupt_end;
   82b70:	e566      	b.n	82640 <UOTGHS_Handler+0x30>
   82b72:	bf00      	nop
   82b74:	20075364 	.word	0x20075364
   82b78:	200710ba 	.word	0x200710ba
   82b7c:	200710b8 	.word	0x200710b8
   82b80:	000820d5 	.word	0x000820d5
   82b84:	400ac160 	.word	0x400ac160
   82b88:	200710bc 	.word	0x200710bc
   82b8c:	400ac1f0 	.word	0x400ac1f0
   82b90:	000820ed 	.word	0x000820ed
   82b94:	400ac300 	.word	0x400ac300
   82b98:	400ac000 	.word	0x400ac000
   82b9c:	200710c0 	.word	0x200710c0
   82ba0:	00082305 	.word	0x00082305
   82ba4:	400ac220 	.word	0x400ac220
   82ba8:	000822cd 	.word	0x000822cd
   82bac:	400ac100 	.word	0x400ac100
   82bb0:	00081611 	.word	0x00081611
   82bb4:	2007026e 	.word	0x2007026e
   82bb8:	00082079 	.word	0x00082079
   82bbc:	000824ad 	.word	0x000824ad
   82bc0:	00082551 	.word	0x00082551
   82bc4:	000825dd 	.word	0x000825dd
   82bc8:	00083801 	.word	0x00083801
	if (Is_udd_reset()) {
   82bcc:	4b19      	ldr	r3, [pc, #100]	; (82c34 <UOTGHS_Handler+0x624>)
   82bce:	685b      	ldr	r3, [r3, #4]
   82bd0:	f013 0f08 	tst.w	r3, #8
   82bd4:	f47f af44 	bne.w	82a60 <UOTGHS_Handler+0x450>
	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
   82bd8:	4b16      	ldr	r3, [pc, #88]	; (82c34 <UOTGHS_Handler+0x624>)
   82bda:	691b      	ldr	r3, [r3, #16]
   82bdc:	f013 0f01 	tst.w	r3, #1
   82be0:	d004      	beq.n	82bec <UOTGHS_Handler+0x5dc>
   82be2:	4b14      	ldr	r3, [pc, #80]	; (82c34 <UOTGHS_Handler+0x624>)
   82be4:	685b      	ldr	r3, [r3, #4]
   82be6:	f013 0f01 	tst.w	r3, #1
   82bea:	d186      	bne.n	82afa <UOTGHS_Handler+0x4ea>
	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
   82bec:	4b11      	ldr	r3, [pc, #68]	; (82c34 <UOTGHS_Handler+0x624>)
   82bee:	691b      	ldr	r3, [r3, #16]
   82bf0:	f013 0f10 	tst.w	r3, #16
   82bf4:	d096      	beq.n	82b24 <UOTGHS_Handler+0x514>
   82bf6:	4b0f      	ldr	r3, [pc, #60]	; (82c34 <UOTGHS_Handler+0x624>)
   82bf8:	685b      	ldr	r3, [r3, #4]
   82bfa:	f013 0f10 	tst.w	r3, #16
   82bfe:	d091      	beq.n	82b24 <UOTGHS_Handler+0x514>
		otg_unfreeze_clock();
   82c00:	4a0c      	ldr	r2, [pc, #48]	; (82c34 <UOTGHS_Handler+0x624>)
   82c02:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
   82c06:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
   82c0a:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
		while (!Is_otg_clock_usable()) {
   82c0e:	4613      	mov	r3, r2
   82c10:	f8d3 2804 	ldr.w	r2, [r3, #2052]	; 0x804
   82c14:	f412 4f80 	tst.w	r2, #16384	; 0x4000
   82c18:	d103      	bne.n	82c22 <UOTGHS_Handler+0x612>
			if (Is_udd_suspend()) {
   82c1a:	685a      	ldr	r2, [r3, #4]
   82c1c:	f012 0f01 	tst.w	r2, #1
   82c20:	d0f6      	beq.n	82c10 <UOTGHS_Handler+0x600>
		udd_disable_wake_up_interrupt();
   82c22:	4b04      	ldr	r3, [pc, #16]	; (82c34 <UOTGHS_Handler+0x624>)
   82c24:	2210      	movs	r2, #16
   82c26:	615a      	str	r2, [r3, #20]
		udd_enable_suspend_interrupt();
   82c28:	2001      	movs	r0, #1
   82c2a:	6198      	str	r0, [r3, #24]
		udd_sleep_mode(true); // Enter in IDLE mode
   82c2c:	4b02      	ldr	r3, [pc, #8]	; (82c38 <UOTGHS_Handler+0x628>)
   82c2e:	4798      	blx	r3
		goto udd_interrupt_end;
   82c30:	e506      	b.n	82640 <UOTGHS_Handler+0x30>
   82c32:	bf00      	nop
   82c34:	400ac000 	.word	0x400ac000
   82c38:	000824ad 	.word	0x000824ad

00082c3c <udd_is_high_speed>:
	return !Is_udd_full_speed_mode();
   82c3c:	4b03      	ldr	r3, [pc, #12]	; (82c4c <udd_is_high_speed+0x10>)
   82c3e:	f8d3 0804 	ldr.w	r0, [r3, #2052]	; 0x804
}
   82c42:	f410 5040 	ands.w	r0, r0, #12288	; 0x3000
   82c46:	bf18      	it	ne
   82c48:	2001      	movne	r0, #1
   82c4a:	4770      	bx	lr
   82c4c:	400ac000 	.word	0x400ac000

00082c50 <udd_set_address>:
	udd_disable_address();
   82c50:	4b08      	ldr	r3, [pc, #32]	; (82c74 <udd_set_address+0x24>)
   82c52:	681a      	ldr	r2, [r3, #0]
   82c54:	f022 0280 	bic.w	r2, r2, #128	; 0x80
   82c58:	601a      	str	r2, [r3, #0]
	udd_configure_address(address);
   82c5a:	681a      	ldr	r2, [r3, #0]
   82c5c:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   82c60:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   82c64:	4302      	orrs	r2, r0
   82c66:	601a      	str	r2, [r3, #0]
	udd_enable_address();
   82c68:	681a      	ldr	r2, [r3, #0]
   82c6a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
   82c6e:	601a      	str	r2, [r3, #0]
   82c70:	4770      	bx	lr
   82c72:	bf00      	nop
   82c74:	400ac000 	.word	0x400ac000

00082c78 <udd_getaddress>:
	return udd_get_configured_address();
   82c78:	4b02      	ldr	r3, [pc, #8]	; (82c84 <udd_getaddress+0xc>)
   82c7a:	6818      	ldr	r0, [r3, #0]
}
   82c7c:	f000 007f 	and.w	r0, r0, #127	; 0x7f
   82c80:	4770      	bx	lr
   82c82:	bf00      	nop
   82c84:	400ac000 	.word	0x400ac000

00082c88 <udd_get_frame_number>:
	return udd_frame_number();
   82c88:	4b02      	ldr	r3, [pc, #8]	; (82c94 <udd_get_frame_number+0xc>)
   82c8a:	6a18      	ldr	r0, [r3, #32]
}
   82c8c:	f3c0 00ca 	ubfx	r0, r0, #3, #11
   82c90:	4770      	bx	lr
   82c92:	bf00      	nop
   82c94:	400ac000 	.word	0x400ac000

00082c98 <udd_get_micro_frame_number>:
	return udd_micro_frame_number();
   82c98:	4b02      	ldr	r3, [pc, #8]	; (82ca4 <udd_get_micro_frame_number+0xc>)
   82c9a:	6a18      	ldr	r0, [r3, #32]
}
   82c9c:	f3c0 000d 	ubfx	r0, r0, #0, #14
   82ca0:	4770      	bx	lr
   82ca2:	bf00      	nop
   82ca4:	400ac000 	.word	0x400ac000

00082ca8 <udd_set_setup_payload>:
	udd_g_ctrlreq.payload = payload;
   82ca8:	4b01      	ldr	r3, [pc, #4]	; (82cb0 <udd_set_setup_payload+0x8>)
   82caa:	6098      	str	r0, [r3, #8]
	udd_g_ctrlreq.payload_size = payload_size;
   82cac:	8199      	strh	r1, [r3, #12]
   82cae:	4770      	bx	lr
   82cb0:	20075364 	.word	0x20075364

00082cb4 <udd_ep_free>:
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   82cb4:	f000 020f 	and.w	r2, r0, #15
	if (USB_DEVICE_MAX_EP < ep_index) {
   82cb8:	2a03      	cmp	r2, #3
   82cba:	d900      	bls.n	82cbe <udd_ep_free+0xa>
   82cbc:	4770      	bx	lr
{
   82cbe:	b570      	push	{r4, r5, r6, lr}
	udd_disable_endpoint(ep_index);
   82cc0:	4810      	ldr	r0, [pc, #64]	; (82d04 <udd_ep_free+0x50>)
   82cc2:	69c3      	ldr	r3, [r0, #28]
   82cc4:	2101      	movs	r1, #1
   82cc6:	fa01 f402 	lsl.w	r4, r1, r2
   82cca:	ea23 0304 	bic.w	r3, r3, r4
   82cce:	61c3      	str	r3, [r0, #28]
	udd_unallocate_memory(ep_index);
   82cd0:	f500 7080 	add.w	r0, r0, #256	; 0x100
   82cd4:	f850 3022 	ldr.w	r3, [r0, r2, lsl #2]
   82cd8:	f023 0302 	bic.w	r3, r3, #2
   82cdc:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
   82ce0:	1e56      	subs	r6, r2, #1
   82ce2:	4c09      	ldr	r4, [pc, #36]	; (82d08 <udd_ep_free+0x54>)
   82ce4:	fa06 f501 	lsl.w	r5, r6, r1
   82ce8:	19a8      	adds	r0, r5, r6
   82cea:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
   82cee:	4b07      	ldr	r3, [pc, #28]	; (82d0c <udd_ep_free+0x58>)
   82cf0:	4798      	blx	r3
	udd_ep_job[ep_index - 1].stall_requested = false;
   82cf2:	4435      	add	r5, r6
   82cf4:	eb04 04c5 	add.w	r4, r4, r5, lsl #3
   82cf8:	7d23      	ldrb	r3, [r4, #20]
   82cfa:	f36f 0382 	bfc	r3, #2, #1
   82cfe:	7523      	strb	r3, [r4, #20]
   82d00:	bd70      	pop	{r4, r5, r6, pc}
   82d02:	bf00      	nop
   82d04:	400ac000 	.word	0x400ac000
   82d08:	200710c0 	.word	0x200710c0
   82d0c:	000822cd 	.word	0x000822cd

00082d10 <udd_ep_is_halted>:
	return Is_udd_endpoint_stall_requested(ep_index);
   82d10:	f000 000f 	and.w	r0, r0, #15
   82d14:	4b02      	ldr	r3, [pc, #8]	; (82d20 <udd_ep_is_halted+0x10>)
   82d16:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
   82d1a:	f3c0 40c0 	ubfx	r0, r0, #19, #1
   82d1e:	4770      	bx	lr
   82d20:	400ac1c0 	.word	0x400ac1c0

00082d24 <udd_ep_set_halt>:
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   82d24:	f000 030f 	and.w	r3, r0, #15
	if (USB_DEVICE_MAX_EP < ep_index) {
   82d28:	2b03      	cmp	r3, #3
   82d2a:	d85d      	bhi.n	82de8 <udd_ep_set_halt+0xc4>
	if (Is_udd_endpoint_stall_requested(ep_index) // Endpoint stalled
   82d2c:	4a35      	ldr	r2, [pc, #212]	; (82e04 <udd_ep_set_halt+0xe0>)
   82d2e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   82d32:	f412 2f00 	tst.w	r2, #524288	; 0x80000
   82d36:	d159      	bne.n	82dec <udd_ep_set_halt+0xc8>
{
   82d38:	b410      	push	{r4}
   82d3a:	b083      	sub	sp, #12
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
   82d3c:	1e59      	subs	r1, r3, #1
			|| ptr_job->stall_requested) { // Endpoint stall is requested
   82d3e:	eb01 0441 	add.w	r4, r1, r1, lsl #1
   82d42:	4a31      	ldr	r2, [pc, #196]	; (82e08 <udd_ep_set_halt+0xe4>)
   82d44:	eb02 02c4 	add.w	r2, r2, r4, lsl #3
   82d48:	7d12      	ldrb	r2, [r2, #20]
   82d4a:	f012 0f04 	tst.w	r2, #4
   82d4e:	d14f      	bne.n	82df0 <udd_ep_set_halt+0xcc>
	if (ptr_job->busy == true) {
   82d50:	f012 0f01 	tst.w	r2, #1
   82d54:	d150      	bne.n	82df8 <udd_ep_set_halt+0xd4>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   82d56:	f3ef 8210 	mrs	r2, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   82d5a:	fab2 f282 	clz	r2, r2
   82d5e:	0952      	lsrs	r2, r2, #5
   82d60:	9201      	str	r2, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   82d62:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82d64:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82d68:	2400      	movs	r4, #0
   82d6a:	4a28      	ldr	r2, [pc, #160]	; (82e0c <udd_ep_set_halt+0xe8>)
   82d6c:	7014      	strb	r4, [r2, #0]
	return flags;
   82d6e:	9c01      	ldr	r4, [sp, #4]
	if ((ep & USB_EP_DIR_IN) && (0 != udd_nb_busy_bank(ep_index))) {
   82d70:	f010 0f80 	tst.w	r0, #128	; 0x80
   82d74:	d118      	bne.n	82da8 <udd_ep_set_halt+0x84>
	udd_disable_endpoint_bank_autoswitch(ep_index);
   82d76:	4926      	ldr	r1, [pc, #152]	; (82e10 <udd_ep_set_halt+0xec>)
   82d78:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
   82d7c:	f422 7200 	bic.w	r2, r2, #512	; 0x200
   82d80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	udd_ack_stall(ep_index);
   82d84:	2140      	movs	r1, #64	; 0x40
   82d86:	4a23      	ldr	r2, [pc, #140]	; (82e14 <udd_ep_set_halt+0xf0>)
   82d88:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	udd_enable_stall_handshake(ep_index);
   82d8c:	f44f 2100 	mov.w	r1, #524288	; 0x80000
   82d90:	3290      	adds	r2, #144	; 0x90
   82d92:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
	if (cpu_irq_is_enabled_flags(flags))
   82d96:	2c00      	cmp	r4, #0
   82d98:	d032      	beq.n	82e00 <udd_ep_set_halt+0xdc>
		cpu_irq_enable();
   82d9a:	2001      	movs	r0, #1
   82d9c:	4b1b      	ldr	r3, [pc, #108]	; (82e0c <udd_ep_set_halt+0xe8>)
   82d9e:	7018      	strb	r0, [r3, #0]
   82da0:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82da4:	b662      	cpsie	i
   82da6:	e024      	b.n	82df2 <udd_ep_set_halt+0xce>
	if ((ep & USB_EP_DIR_IN) && (0 != udd_nb_busy_bank(ep_index))) {
   82da8:	4a1b      	ldr	r2, [pc, #108]	; (82e18 <udd_ep_set_halt+0xf4>)
   82daa:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
   82dae:	f412 5f40 	tst.w	r2, #12288	; 0x3000
   82db2:	d0e0      	beq.n	82d76 <udd_ep_set_halt+0x52>
		ptr_job->stall_requested = true;
   82db4:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   82db8:	4a13      	ldr	r2, [pc, #76]	; (82e08 <udd_ep_set_halt+0xe4>)
   82dba:	eb02 01c1 	add.w	r1, r2, r1, lsl #3
   82dbe:	7d0a      	ldrb	r2, [r1, #20]
   82dc0:	f042 0204 	orr.w	r2, r2, #4
   82dc4:	750a      	strb	r2, [r1, #20]
		udd_enable_bank_interrupt(ep_index);
   82dc6:	f44f 5280 	mov.w	r2, #4096	; 0x1000
   82dca:	4914      	ldr	r1, [pc, #80]	; (82e1c <udd_ep_set_halt+0xf8>)
   82dcc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		udd_enable_endpoint_interrupt(ep_index);
   82dd0:	fa02 f303 	lsl.w	r3, r2, r3
   82dd4:	4a12      	ldr	r2, [pc, #72]	; (82e20 <udd_ep_set_halt+0xfc>)
   82dd6:	6193      	str	r3, [r2, #24]
	if (cpu_irq_is_enabled_flags(flags))
   82dd8:	b184      	cbz	r4, 82dfc <udd_ep_set_halt+0xd8>
		cpu_irq_enable();
   82dda:	2001      	movs	r0, #1
   82ddc:	4b0b      	ldr	r3, [pc, #44]	; (82e0c <udd_ep_set_halt+0xe8>)
   82dde:	7018      	strb	r0, [r3, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   82de0:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82de4:	b662      	cpsie	i
   82de6:	e004      	b.n	82df2 <udd_ep_set_halt+0xce>
		return false;
   82de8:	2000      	movs	r0, #0
   82dea:	4770      	bx	lr
		return true; // Already STALL
   82dec:	2001      	movs	r0, #1
   82dee:	4770      	bx	lr
   82df0:	2001      	movs	r0, #1
}
   82df2:	b003      	add	sp, #12
   82df4:	bc10      	pop	{r4}
   82df6:	4770      	bx	lr
		return false; // Job on going, stall impossible
   82df8:	2000      	movs	r0, #0
   82dfa:	e7fa      	b.n	82df2 <udd_ep_set_halt+0xce>
		return true;
   82dfc:	2001      	movs	r0, #1
   82dfe:	e7f8      	b.n	82df2 <udd_ep_set_halt+0xce>
	return true;
   82e00:	2001      	movs	r0, #1
   82e02:	e7f6      	b.n	82df2 <udd_ep_set_halt+0xce>
   82e04:	400ac1c0 	.word	0x400ac1c0
   82e08:	200710c0 	.word	0x200710c0
   82e0c:	2007026e 	.word	0x2007026e
   82e10:	400ac100 	.word	0x400ac100
   82e14:	400ac160 	.word	0x400ac160
   82e18:	400ac130 	.word	0x400ac130
   82e1c:	400ac1f0 	.word	0x400ac1f0
   82e20:	400ac000 	.word	0x400ac000

00082e24 <udd_ep_clear_halt>:
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   82e24:	f000 000f 	and.w	r0, r0, #15
	if (USB_DEVICE_MAX_EP < ep_index)
   82e28:	2803      	cmp	r0, #3
   82e2a:	d851      	bhi.n	82ed0 <udd_ep_clear_halt+0xac>
{
   82e2c:	b510      	push	{r4, lr}
	udd_ep_job_t *ptr_job = &udd_ep_job[ep_index - 1];
   82e2e:	1e43      	subs	r3, r0, #1
	if (ptr_job->stall_requested) {
   82e30:	eb03 0143 	add.w	r1, r3, r3, lsl #1
   82e34:	4a2c      	ldr	r2, [pc, #176]	; (82ee8 <udd_ep_clear_halt+0xc4>)
   82e36:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
   82e3a:	7d12      	ldrb	r2, [r2, #20]
   82e3c:	f012 0f04 	tst.w	r2, #4
   82e40:	d048      	beq.n	82ed4 <udd_ep_clear_halt+0xb0>
		ptr_job->stall_requested = false;
   82e42:	460a      	mov	r2, r1
   82e44:	4928      	ldr	r1, [pc, #160]	; (82ee8 <udd_ep_clear_halt+0xc4>)
   82e46:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   82e4a:	7d11      	ldrb	r1, [r2, #20]
   82e4c:	f36f 0182 	bfc	r1, #2, #1
   82e50:	7511      	strb	r1, [r2, #20]
		udd_disable_bank_interrupt(ep_index);
   82e52:	0082      	lsls	r2, r0, #2
   82e54:	f44f 5180 	mov.w	r1, #4096	; 0x1000
   82e58:	4c24      	ldr	r4, [pc, #144]	; (82eec <udd_ep_clear_halt+0xc8>)
   82e5a:	f844 1020 	str.w	r1, [r4, r0, lsl #2]
		udd_disable_endpoint_interrupt(ep_index);
   82e5e:	4081      	lsls	r1, r0
   82e60:	f5a4 7408 	sub.w	r4, r4, #544	; 0x220
   82e64:	6161      	str	r1, [r4, #20]
	if (Is_udd_endpoint_stall_requested(ep_index)) {
   82e66:	4922      	ldr	r1, [pc, #136]	; (82ef0 <udd_ep_clear_halt+0xcc>)
   82e68:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   82e6c:	f411 2f00 	tst.w	r1, #524288	; 0x80000
   82e70:	d014      	beq.n	82e9c <udd_ep_clear_halt+0x78>
		if (Is_udd_stall(ep_index)) {
   82e72:	4920      	ldr	r1, [pc, #128]	; (82ef4 <udd_ep_clear_halt+0xd0>)
   82e74:	5851      	ldr	r1, [r2, r1]
   82e76:	f011 0f40 	tst.w	r1, #64	; 0x40
   82e7a:	d006      	beq.n	82e8a <udd_ep_clear_halt+0x66>
			udd_ack_stall(ep_index);
   82e7c:	2040      	movs	r0, #64	; 0x40
   82e7e:	491e      	ldr	r1, [pc, #120]	; (82ef8 <udd_ep_clear_halt+0xd4>)
   82e80:	5050      	str	r0, [r2, r1]
			udd_reset_data_toggle(ep_index);
   82e82:	f44f 2080 	mov.w	r0, #262144	; 0x40000
   82e86:	3190      	adds	r1, #144	; 0x90
   82e88:	5050      	str	r0, [r2, r1]
		udd_disable_stall_handshake(ep_index);
   82e8a:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   82e8e:	4917      	ldr	r1, [pc, #92]	; (82eec <udd_ep_clear_halt+0xc8>)
   82e90:	5050      	str	r0, [r2, r1]
		udd_enable_endpoint_bank_autoswitch(ep_index);
   82e92:	481a      	ldr	r0, [pc, #104]	; (82efc <udd_ep_clear_halt+0xd8>)
   82e94:	5811      	ldr	r1, [r2, r0]
   82e96:	f441 7100 	orr.w	r1, r1, #512	; 0x200
   82e9a:	5011      	str	r1, [r2, r0]
		if (ptr_job->busy == true) {
   82e9c:	eb03 0243 	add.w	r2, r3, r3, lsl #1
   82ea0:	4911      	ldr	r1, [pc, #68]	; (82ee8 <udd_ep_clear_halt+0xc4>)
   82ea2:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   82ea6:	7d12      	ldrb	r2, [r2, #20]
   82ea8:	f012 0f01 	tst.w	r2, #1
   82eac:	d101      	bne.n	82eb2 <udd_ep_clear_halt+0x8e>
	return true;
   82eae:	2001      	movs	r0, #1
   82eb0:	bd10      	pop	{r4, pc}
			ptr_job->busy = false;
   82eb2:	4608      	mov	r0, r1
   82eb4:	0059      	lsls	r1, r3, #1
   82eb6:	18ca      	adds	r2, r1, r3
   82eb8:	eb00 02c2 	add.w	r2, r0, r2, lsl #3
   82ebc:	7d14      	ldrb	r4, [r2, #20]
   82ebe:	f36f 0400 	bfc	r4, #0, #1
   82ec2:	7514      	strb	r4, [r2, #20]
			ptr_job->call_nohalt();
   82ec4:	440b      	add	r3, r1
   82ec6:	f850 3033 	ldr.w	r3, [r0, r3, lsl #3]
   82eca:	4798      	blx	r3
	return true;
   82ecc:	2001      	movs	r0, #1
   82ece:	bd10      	pop	{r4, pc}
		return false;
   82ed0:	2000      	movs	r0, #0
   82ed2:	4770      	bx	lr
	if (Is_udd_endpoint_stall_requested(ep_index)) {
   82ed4:	0082      	lsls	r2, r0, #2
   82ed6:	4906      	ldr	r1, [pc, #24]	; (82ef0 <udd_ep_clear_halt+0xcc>)
   82ed8:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
   82edc:	f411 2f00 	tst.w	r1, #524288	; 0x80000
   82ee0:	d1c7      	bne.n	82e72 <udd_ep_clear_halt+0x4e>
	return true;
   82ee2:	2001      	movs	r0, #1
}
   82ee4:	bd10      	pop	{r4, pc}
   82ee6:	bf00      	nop
   82ee8:	200710c0 	.word	0x200710c0
   82eec:	400ac220 	.word	0x400ac220
   82ef0:	400ac1c0 	.word	0x400ac1c0
   82ef4:	400ac130 	.word	0x400ac130
   82ef8:	400ac160 	.word	0x400ac160
   82efc:	400ac100 	.word	0x400ac100

00082f00 <udd_ep_run>:
	ep &= USB_EP_ADDR_MASK;
   82f00:	f000 000f 	and.w	r0, r0, #15
	if (USB_DEVICE_MAX_EP < ep) {
   82f04:	2803      	cmp	r0, #3
   82f06:	d864      	bhi.n	82fd2 <udd_ep_run+0xd2>
{
   82f08:	b5f0      	push	{r4, r5, r6, r7, lr}
   82f0a:	b083      	sub	sp, #12
	if ((!Is_udd_endpoint_enabled(ep))
   82f0c:	4c36      	ldr	r4, [pc, #216]	; (82fe8 <udd_ep_run+0xe8>)
   82f0e:	69e5      	ldr	r5, [r4, #28]
   82f10:	2401      	movs	r4, #1
   82f12:	4084      	lsls	r4, r0
   82f14:	422c      	tst	r4, r5
   82f16:	d05e      	beq.n	82fd6 <udd_ep_run+0xd6>
			|| Is_udd_endpoint_stall_requested(ep)
   82f18:	4c34      	ldr	r4, [pc, #208]	; (82fec <udd_ep_run+0xec>)
   82f1a:	f854 4020 	ldr.w	r4, [r4, r0, lsl #2]
   82f1e:	f414 2f00 	tst.w	r4, #524288	; 0x80000
   82f22:	d15b      	bne.n	82fdc <udd_ep_run+0xdc>
	ptr_job = &udd_ep_job[ep - 1];
   82f24:	1e44      	subs	r4, r0, #1
			|| ptr_job->stall_requested) {
   82f26:	eb04 0644 	add.w	r6, r4, r4, lsl #1
   82f2a:	4d31      	ldr	r5, [pc, #196]	; (82ff0 <udd_ep_run+0xf0>)
   82f2c:	eb05 05c6 	add.w	r5, r5, r6, lsl #3
   82f30:	7d2d      	ldrb	r5, [r5, #20]
   82f32:	f015 0f04 	tst.w	r5, #4
   82f36:	d153      	bne.n	82fe0 <udd_ep_run+0xe0>
  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
   82f38:	f3ef 8510 	mrs	r5, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
   82f3c:	fab5 f585 	clz	r5, r5
   82f40:	096d      	lsrs	r5, r5, #5
   82f42:	9501      	str	r5, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
   82f44:	b672      	cpsid	i
  __ASM volatile ("dmb 0xF":::"memory");
   82f46:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
   82f4a:	2600      	movs	r6, #0
   82f4c:	4d29      	ldr	r5, [pc, #164]	; (82ff4 <udd_ep_run+0xf4>)
   82f4e:	702e      	strb	r6, [r5, #0]
	return flags;
   82f50:	9f01      	ldr	r7, [sp, #4]
	if (ptr_job->busy == true) {
   82f52:	eb04 0544 	add.w	r5, r4, r4, lsl #1
   82f56:	4e26      	ldr	r6, [pc, #152]	; (82ff0 <udd_ep_run+0xf0>)
   82f58:	eb06 05c5 	add.w	r5, r6, r5, lsl #3
   82f5c:	7d2d      	ldrb	r5, [r5, #20]
   82f5e:	f015 0f01 	tst.w	r5, #1
   82f62:	d009      	beq.n	82f78 <udd_ep_run+0x78>
	if (cpu_irq_is_enabled_flags(flags))
   82f64:	2f00      	cmp	r7, #0
   82f66:	d03d      	beq.n	82fe4 <udd_ep_run+0xe4>
		cpu_irq_enable();
   82f68:	2201      	movs	r2, #1
   82f6a:	4b22      	ldr	r3, [pc, #136]	; (82ff4 <udd_ep_run+0xf4>)
   82f6c:	701a      	strb	r2, [r3, #0]
   82f6e:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82f72:	b662      	cpsie	i
		return false; // Job already on going
   82f74:	2000      	movs	r0, #0
   82f76:	e02f      	b.n	82fd8 <udd_ep_run+0xd8>
	ptr_job->busy = true;
   82f78:	eb04 0544 	add.w	r5, r4, r4, lsl #1
   82f7c:	4e1c      	ldr	r6, [pc, #112]	; (82ff0 <udd_ep_run+0xf0>)
   82f7e:	eb06 05c5 	add.w	r5, r6, r5, lsl #3
   82f82:	7d2e      	ldrb	r6, [r5, #20]
   82f84:	f046 0601 	orr.w	r6, r6, #1
   82f88:	752e      	strb	r6, [r5, #20]
	if (cpu_irq_is_enabled_flags(flags))
   82f8a:	b12f      	cbz	r7, 82f98 <udd_ep_run+0x98>
		cpu_irq_enable();
   82f8c:	2601      	movs	r6, #1
   82f8e:	4d19      	ldr	r5, [pc, #100]	; (82ff4 <udd_ep_run+0xf4>)
   82f90:	702e      	strb	r6, [r5, #0]
  __ASM volatile ("dmb 0xF":::"memory");
   82f92:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
   82f96:	b662      	cpsie	i
	ptr_job->buf = buf;
   82f98:	4f15      	ldr	r7, [pc, #84]	; (82ff0 <udd_ep_run+0xf0>)
   82f9a:	eb04 0544 	add.w	r5, r4, r4, lsl #1
   82f9e:	00ed      	lsls	r5, r5, #3
   82fa0:	197e      	adds	r6, r7, r5
   82fa2:	6072      	str	r2, [r6, #4]
	ptr_job->buf_size = buf_size;
   82fa4:	60b3      	str	r3, [r6, #8]
	ptr_job->buf_cnt = 0;
   82fa6:	2200      	movs	r2, #0
   82fa8:	60f2      	str	r2, [r6, #12]
	ptr_job->buf_load = 0;
   82faa:	6132      	str	r2, [r6, #16]
	ptr_job->call_trans = callback;
   82fac:	9a08      	ldr	r2, [sp, #32]
   82fae:	517a      	str	r2, [r7, r5]
	ptr_job->b_shortpacket = b_shortpacket || (buf_size == 0);
   82fb0:	b911      	cbnz	r1, 82fb8 <udd_ep_run+0xb8>
   82fb2:	fab3 f183 	clz	r1, r3
   82fb6:	0949      	lsrs	r1, r1, #5
   82fb8:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   82fbc:	4b0c      	ldr	r3, [pc, #48]	; (82ff0 <udd_ep_run+0xf0>)
   82fbe:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
   82fc2:	7d23      	ldrb	r3, [r4, #20]
   82fc4:	f361 0341 	bfi	r3, r1, #1, #1
   82fc8:	7523      	strb	r3, [r4, #20]
	udd_ep_trans_done(ep);
   82fca:	4b0b      	ldr	r3, [pc, #44]	; (82ff8 <udd_ep_run+0xf8>)
   82fcc:	4798      	blx	r3
	return true;
   82fce:	2001      	movs	r0, #1
   82fd0:	e002      	b.n	82fd8 <udd_ep_run+0xd8>
		return false;
   82fd2:	2000      	movs	r0, #0
   82fd4:	4770      	bx	lr
		return false; // Endpoint is halted
   82fd6:	2000      	movs	r0, #0
}
   82fd8:	b003      	add	sp, #12
   82fda:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return false; // Endpoint is halted
   82fdc:	2000      	movs	r0, #0
   82fde:	e7fb      	b.n	82fd8 <udd_ep_run+0xd8>
   82fe0:	2000      	movs	r0, #0
   82fe2:	e7f9      	b.n	82fd8 <udd_ep_run+0xd8>
		return false; // Job already on going
   82fe4:	2000      	movs	r0, #0
   82fe6:	e7f7      	b.n	82fd8 <udd_ep_run+0xd8>
   82fe8:	400ac000 	.word	0x400ac000
   82fec:	400ac1c0 	.word	0x400ac1c0
   82ff0:	200710c0 	.word	0x200710c0
   82ff4:	2007026e 	.word	0x2007026e
   82ff8:	00082305 	.word	0x00082305

00082ffc <udd_ep_alloc>:
{
   82ffc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   83000:	b083      	sub	sp, #12
	ep = ep & USB_EP_ADDR_MASK;
   83002:	f000 040f 	and.w	r4, r0, #15
	if (ep > USB_DEVICE_MAX_EP) {
   83006:	2c03      	cmp	r4, #3
   83008:	f200 80df 	bhi.w	831ca <udd_ep_alloc+0x1ce>
	if (Is_udd_endpoint_enabled(ep)) {
   8300c:	4b74      	ldr	r3, [pc, #464]	; (831e0 <udd_ep_alloc+0x1e4>)
   8300e:	69dd      	ldr	r5, [r3, #28]
   83010:	2301      	movs	r3, #1
   83012:	40a3      	lsls	r3, r4
   83014:	402b      	ands	r3, r5
   83016:	f040 80dd 	bne.w	831d4 <udd_ep_alloc+0x1d8>
	switch (bmAttributes & USB_EP_TYPE_MASK) {
   8301a:	f011 0503 	ands.w	r5, r1, #3
   8301e:	f000 80db 	beq.w	831d8 <udd_ep_alloc+0x1dc>
   83022:	2d02      	cmp	r5, #2
   83024:	d920      	bls.n	83068 <udd_ep_alloc+0x6c>
   83026:	2d03      	cmp	r5, #3
   83028:	f040 80d6 	bne.w	831d8 <udd_ep_alloc+0x1dc>
		bank = UOTGHS_DEVEPTCFG_EPBK_1_BANK >>
   8302c:	f04f 0e00 	mov.w	lr, #0
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
   83030:	4e6c      	ldr	r6, [pc, #432]	; (831e4 <udd_ep_alloc+0x1e8>)
   83032:	eb06 0584 	add.w	r5, r6, r4, lsl #2
   83036:	f856 7024 	ldr.w	r7, [r6, r4, lsl #2]
   8303a:	f427 57cb 	bic.w	r7, r7, #6496	; 0x1960
   8303e:	f027 071c 	bic.w	r7, r7, #28
   83042:	02c9      	lsls	r1, r1, #11
   83044:	f401 51c0 	and.w	r1, r1, #6144	; 0x1800
   83048:	b240      	sxtb	r0, r0
   8304a:	2800      	cmp	r0, #0
   8304c:	bfb8      	it	lt
   8304e:	f44f 7380 	movlt.w	r3, #256	; 0x100
   83052:	f5a2 6080 	sub.w	r0, r2, #1024	; 0x400
   83056:	b280      	uxth	r0, r0
   83058:	f5b0 4f7c 	cmp.w	r0, #64512	; 0xfc00
   8305c:	d307      	bcc.n	8306e <udd_ep_alloc+0x72>
   8305e:	2a08      	cmp	r2, #8
   83060:	d924      	bls.n	830ac <udd_ep_alloc+0xb0>
   83062:	0052      	lsls	r2, r2, #1
   83064:	3a01      	subs	r2, #1
   83066:	e004      	b.n	83072 <udd_ep_alloc+0x76>
		bank = UOTGHS_DEVEPTCFG_EPBK_2_BANK >>
   83068:	f04f 0e01 	mov.w	lr, #1
   8306c:	e7e0      	b.n	83030 <udd_ep_alloc+0x34>
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
   8306e:	f240 72ff 	movw	r2, #2047	; 0x7ff
   83072:	fab2 f282 	clz	r2, r2
   83076:	ea41 018e 	orr.w	r1, r1, lr, lsl #2
   8307a:	4319      	orrs	r1, r3
   8307c:	f1c2 031c 	rsb	r3, r2, #28
   83080:	ea41 1303 	orr.w	r3, r1, r3, lsl #4
   83084:	f423 63d0 	bic.w	r3, r3, #1664	; 0x680
   83088:	f023 0303 	bic.w	r3, r3, #3
   8308c:	04db      	lsls	r3, r3, #19
   8308e:	0cdb      	lsrs	r3, r3, #19
   83090:	433b      	orrs	r3, r7
   83092:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
	ep_allocated = 1 << ep;
   83096:	2701      	movs	r7, #1
   83098:	40a7      	lsls	r7, r4
   8309a:	b2bf      	uxth	r7, r7
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
   8309c:	2c02      	cmp	r4, #2
   8309e:	d81c      	bhi.n	830da <udd_ep_alloc+0xde>
   830a0:	4a51      	ldr	r2, [pc, #324]	; (831e8 <udd_ep_alloc+0x1ec>)
   830a2:	2303      	movs	r3, #3
		if (Is_udd_endpoint_enabled(i)) {
   830a4:	484e      	ldr	r0, [pc, #312]	; (831e0 <udd_ep_alloc+0x1e4>)
   830a6:	f04f 0e01 	mov.w	lr, #1
   830aa:	e006      	b.n	830ba <udd_ep_alloc+0xbe>
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
   830ac:	220f      	movs	r2, #15
   830ae:	e7e0      	b.n	83072 <udd_ep_alloc+0x76>
   830b0:	3b01      	subs	r3, #1
   830b2:	3a04      	subs	r2, #4
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
   830b4:	b2d9      	uxtb	r1, r3
   830b6:	428c      	cmp	r4, r1
   830b8:	d20f      	bcs.n	830da <udd_ep_alloc+0xde>
		if (Is_udd_endpoint_enabled(i)) {
   830ba:	69c6      	ldr	r6, [r0, #28]
   830bc:	fa0e f103 	lsl.w	r1, lr, r3
   830c0:	420e      	tst	r6, r1
   830c2:	d0f5      	beq.n	830b0 <udd_ep_alloc+0xb4>
			ep_allocated |= 1 << i;
   830c4:	430f      	orrs	r7, r1
   830c6:	b2bf      	uxth	r7, r7
			udd_disable_endpoint(i);
   830c8:	69c6      	ldr	r6, [r0, #28]
   830ca:	ea26 0101 	bic.w	r1, r6, r1
   830ce:	61c1      	str	r1, [r0, #28]
			udd_unallocate_memory(i);
   830d0:	6811      	ldr	r1, [r2, #0]
   830d2:	f021 0102 	bic.w	r1, r1, #2
   830d6:	6011      	str	r1, [r2, #0]
   830d8:	e7ea      	b.n	830b0 <udd_ep_alloc+0xb4>
   830da:	eb04 0344 	add.w	r3, r4, r4, lsl #1
   830de:	4e43      	ldr	r6, [pc, #268]	; (831ec <udd_ep_alloc+0x1f0>)
   830e0:	eb06 06c3 	add.w	r6, r6, r3, lsl #3
			bool b_restart = ptr_job->busy;
   830e4:	f8df 9104 	ldr.w	r9, [pc, #260]	; 831ec <udd_ep_alloc+0x1f0>
			udd_enable_endpoint(i);
   830e8:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 831e0 <udd_ep_alloc+0x1e4>
				b_restart = udd_ep_run(Is_udd_endpoint_in(i) ?
   830ec:	f8df a100 	ldr.w	sl, [pc, #256]	; 831f0 <udd_ep_alloc+0x1f4>
   830f0:	e01d      	b.n	8312e <udd_ep_alloc+0x132>
				if (NULL == ptr_job->call_trans) {
   830f2:	eb01 0341 	add.w	r3, r1, r1, lsl #1
   830f6:	4a3d      	ldr	r2, [pc, #244]	; (831ec <udd_ep_alloc+0x1f0>)
   830f8:	f852 4033 	ldr.w	r4, [r2, r3, lsl #3]
   830fc:	2c00      	cmp	r4, #0
   830fe:	d06d      	beq.n	831dc <udd_ep_alloc+0x1e0>
				if (Is_udd_endpoint_in(i)) {
   83100:	682b      	ldr	r3, [r5, #0]
   83102:	f413 7f80 	tst.w	r3, #256	; 0x100
					i |= USB_EP_DIR_IN;
   83106:	bf18      	it	ne
   83108:	f040 0080 	orrne.w	r0, r0, #128	; 0x80
				ptr_job->call_trans(UDD_EP_TRANSFER_ABORT,
   8310c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   83110:	4b36      	ldr	r3, [pc, #216]	; (831ec <udd_ep_alloc+0x1f0>)
   83112:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
   83116:	4602      	mov	r2, r0
   83118:	68c9      	ldr	r1, [r1, #12]
   8311a:	2001      	movs	r0, #1
   8311c:	47a0      	blx	r4
				return false;
   8311e:	2300      	movs	r3, #0
   83120:	e054      	b.n	831cc <udd_ep_alloc+0x1d0>
   83122:	3401      	adds	r4, #1
   83124:	3504      	adds	r5, #4
   83126:	3618      	adds	r6, #24
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
   83128:	b2e3      	uxtb	r3, r4
   8312a:	2b03      	cmp	r3, #3
   8312c:	d84b      	bhi.n	831c6 <udd_ep_alloc+0x1ca>
   8312e:	b2e0      	uxtb	r0, r4
		if (ep_allocated & (1 << i)) {
   83130:	fa47 f304 	asr.w	r3, r7, r4
   83134:	f013 0f01 	tst.w	r3, #1
   83138:	d0f3      	beq.n	83122 <udd_ep_alloc+0x126>
   8313a:	1e61      	subs	r1, r4, #1
			bool b_restart = ptr_job->busy;
   8313c:	eb01 0341 	add.w	r3, r1, r1, lsl #1
   83140:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
   83144:	f893 e014 	ldrb.w	lr, [r3, #20]
   83148:	f00e 0201 	and.w	r2, lr, #1
			ptr_job->busy = false;
   8314c:	f36f 0e00 	bfc	lr, #0, #1
   83150:	f883 e014 	strb.w	lr, [r3, #20]
			udd_allocate_memory(i);
   83154:	682b      	ldr	r3, [r5, #0]
   83156:	f043 0302 	orr.w	r3, r3, #2
   8315a:	602b      	str	r3, [r5, #0]
			udd_enable_endpoint(i);
   8315c:	f8d8 e01c 	ldr.w	lr, [r8, #28]
   83160:	2301      	movs	r3, #1
   83162:	40a3      	lsls	r3, r4
   83164:	ea43 030e 	orr.w	r3, r3, lr
   83168:	f8c8 301c 	str.w	r3, [r8, #28]
			if (!Is_udd_endpoint_configured(i)) {
   8316c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
   8316e:	f413 2f80 	tst.w	r3, #262144	; 0x40000
   83172:	d0be      	beq.n	830f2 <udd_ep_alloc+0xf6>
			udd_enable_endpoint_bank_autoswitch(i);
   83174:	682b      	ldr	r3, [r5, #0]
   83176:	f443 7300 	orr.w	r3, r3, #512	; 0x200
   8317a:	602b      	str	r3, [r5, #0]
			if (b_restart) {
   8317c:	2a00      	cmp	r2, #0
   8317e:	d0d0      	beq.n	83122 <udd_ep_alloc+0x126>
				ptr_job->buf_cnt -= ptr_job->buf_load;
   83180:	f856 3c0c 	ldr.w	r3, [r6, #-12]
   83184:	f856 2c08 	ldr.w	r2, [r6, #-8]
   83188:	1a9a      	subs	r2, r3, r2
   8318a:	f846 2c0c 	str.w	r2, [r6, #-12]
				b_restart = udd_ep_run(Is_udd_endpoint_in(i) ?
   8318e:	682b      	ldr	r3, [r5, #0]
   83190:	f413 7f80 	tst.w	r3, #256	; 0x100
   83194:	bf18      	it	ne
   83196:	f040 0080 	orrne.w	r0, r0, #128	; 0x80
   8319a:	f856 bc10 	ldr.w	fp, [r6, #-16]
   8319e:	f856 cc14 	ldr.w	ip, [r6, #-20]
						ptr_job->b_shortpacket,
   831a2:	eb01 0141 	add.w	r1, r1, r1, lsl #1
   831a6:	eb09 01c1 	add.w	r1, r9, r1, lsl #3
   831aa:	7d09      	ldrb	r1, [r1, #20]
				b_restart = udd_ep_run(Is_udd_endpoint_in(i) ?
   831ac:	f856 3c18 	ldr.w	r3, [r6, #-24]
   831b0:	9300      	str	r3, [sp, #0]
   831b2:	ebab 0302 	sub.w	r3, fp, r2
   831b6:	4462      	add	r2, ip
   831b8:	f3c1 0140 	ubfx	r1, r1, #1, #1
   831bc:	47d0      	blx	sl
				if (!b_restart) {
   831be:	4603      	mov	r3, r0
   831c0:	2800      	cmp	r0, #0
   831c2:	d1ae      	bne.n	83122 <udd_ep_alloc+0x126>
   831c4:	e002      	b.n	831cc <udd_ep_alloc+0x1d0>
	return true;
   831c6:	2301      	movs	r3, #1
   831c8:	e000      	b.n	831cc <udd_ep_alloc+0x1d0>
		return false;
   831ca:	2300      	movs	r3, #0
}
   831cc:	4618      	mov	r0, r3
   831ce:	b003      	add	sp, #12
   831d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return false;
   831d4:	2300      	movs	r3, #0
   831d6:	e7f9      	b.n	831cc <udd_ep_alloc+0x1d0>
		return false;
   831d8:	2300      	movs	r3, #0
   831da:	e7f7      	b.n	831cc <udd_ep_alloc+0x1d0>
					return false;
   831dc:	2300      	movs	r3, #0
   831de:	e7f5      	b.n	831cc <udd_ep_alloc+0x1d0>
   831e0:	400ac000 	.word	0x400ac000
   831e4:	400ac100 	.word	0x400ac100
   831e8:	400ac10c 	.word	0x400ac10c
   831ec:	200710c0 	.word	0x200710c0
   831f0:	00082f01 	.word	0x00082f01

000831f4 <udd_ep_abort>:
{
   831f4:	b570      	push	{r4, r5, r6, lr}
	uint8_t ep_index = ep & USB_EP_ADDR_MASK;
   831f6:	f000 020f 	and.w	r2, r0, #15
		udd_disable_endpoint_dma_interrupt(ep_index);
   831fa:	1e54      	subs	r4, r2, #1
   831fc:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
   83200:	40a3      	lsls	r3, r4
   83202:	4916      	ldr	r1, [pc, #88]	; (8325c <udd_ep_abort+0x68>)
   83204:	614b      	str	r3, [r1, #20]
		udd_endpoint_dma_set_control(ep_index, 0);
   83206:	4b16      	ldr	r3, [pc, #88]	; (83260 <udd_ep_abort+0x6c>)
   83208:	eb03 1302 	add.w	r3, r3, r2, lsl #4
   8320c:	2500      	movs	r5, #0
   8320e:	609d      	str	r5, [r3, #8]
	udd_disable_endpoint_interrupt(ep_index);
   83210:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   83214:	4093      	lsls	r3, r2
   83216:	614b      	str	r3, [r1, #20]
	if (ep & USB_EP_DIR_IN) {
   83218:	f010 0f80 	tst.w	r0, #128	; 0x80
   8321c:	d108      	bne.n	83230 <udd_ep_abort+0x3c>
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
   8321e:	eb04 0444 	add.w	r4, r4, r4, lsl #1
   83222:	2101      	movs	r1, #1
   83224:	480f      	ldr	r0, [pc, #60]	; (83264 <udd_ep_abort+0x70>)
   83226:	eb00 00c4 	add.w	r0, r0, r4, lsl #3
   8322a:	4b0f      	ldr	r3, [pc, #60]	; (83268 <udd_ep_abort+0x74>)
   8322c:	4798      	blx	r3
   8322e:	bd70      	pop	{r4, r5, r6, pc}
		while(udd_nb_busy_bank(ep_index)) {
   83230:	0093      	lsls	r3, r2, #2
   83232:	480e      	ldr	r0, [pc, #56]	; (8326c <udd_ep_abort+0x78>)
   83234:	4418      	add	r0, r3
			udd_kill_last_in_bank(ep_index);
   83236:	4d0e      	ldr	r5, [pc, #56]	; (83270 <udd_ep_abort+0x7c>)
   83238:	441d      	add	r5, r3
   8323a:	f44f 5600 	mov.w	r6, #8192	; 0x2000
			while(Is_udd_kill_last(ep_index));
   8323e:	f501 71e0 	add.w	r1, r1, #448	; 0x1c0
   83242:	4419      	add	r1, r3
   83244:	e004      	b.n	83250 <udd_ep_abort+0x5c>
			udd_kill_last_in_bank(ep_index);
   83246:	602e      	str	r6, [r5, #0]
			while(Is_udd_kill_last(ep_index));
   83248:	680b      	ldr	r3, [r1, #0]
   8324a:	f413 5f00 	tst.w	r3, #8192	; 0x2000
   8324e:	d1fb      	bne.n	83248 <udd_ep_abort+0x54>
		while(udd_nb_busy_bank(ep_index)) {
   83250:	6803      	ldr	r3, [r0, #0]
   83252:	f413 5f40 	tst.w	r3, #12288	; 0x3000
   83256:	d1f6      	bne.n	83246 <udd_ep_abort+0x52>
   83258:	e7e1      	b.n	8321e <udd_ep_abort+0x2a>
   8325a:	bf00      	nop
   8325c:	400ac000 	.word	0x400ac000
   83260:	400ac300 	.word	0x400ac300
   83264:	200710c0 	.word	0x200710c0
   83268:	000822cd 	.word	0x000822cd
   8326c:	400ac130 	.word	0x400ac130
   83270:	400ac1f0 	.word	0x400ac1f0

00083274 <udd_test_mode_j>:
	udd_enable_hs_test_mode();
   83274:	4a05      	ldr	r2, [pc, #20]	; (8328c <udd_test_mode_j+0x18>)
   83276:	6813      	ldr	r3, [r2, #0]
   83278:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
   8327c:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   83280:	6013      	str	r3, [r2, #0]
	udd_enable_hs_test_mode_j();
   83282:	6813      	ldr	r3, [r2, #0]
   83284:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
   83288:	6013      	str	r3, [r2, #0]
   8328a:	4770      	bx	lr
   8328c:	400ac000 	.word	0x400ac000

00083290 <udd_test_mode_k>:
	udd_enable_hs_test_mode();
   83290:	4a05      	ldr	r2, [pc, #20]	; (832a8 <udd_test_mode_k+0x18>)
   83292:	6813      	ldr	r3, [r2, #0]
   83294:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
   83298:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   8329c:	6013      	str	r3, [r2, #0]
	udd_enable_hs_test_mode_k();
   8329e:	6813      	ldr	r3, [r2, #0]
   832a0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
   832a4:	6013      	str	r3, [r2, #0]
   832a6:	4770      	bx	lr
   832a8:	400ac000 	.word	0x400ac000

000832ac <udd_test_mode_se0_nak>:
	udd_enable_hs_test_mode();
   832ac:	4a03      	ldr	r2, [pc, #12]	; (832bc <udd_test_mode_se0_nak+0x10>)
   832ae:	6813      	ldr	r3, [r2, #0]
   832b0:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
   832b4:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   832b8:	6013      	str	r3, [r2, #0]
   832ba:	4770      	bx	lr
   832bc:	400ac000 	.word	0x400ac000

000832c0 <udd_test_mode_packet>:
{
   832c0:	b430      	push	{r4, r5}
   832c2:	b08e      	sub	sp, #56	; 0x38
	const uint8_t test_packet[] = {
   832c4:	466c      	mov	r4, sp
   832c6:	4d1f      	ldr	r5, [pc, #124]	; (83344 <udd_test_mode_packet+0x84>)
   832c8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   832ca:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   832cc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   832ce:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   832d0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   832d2:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   832d4:	e895 0003 	ldmia.w	r5, {r0, r1}
   832d8:	f844 0b04 	str.w	r0, [r4], #4
   832dc:	7021      	strb	r1, [r4, #0]
	udd_disable_endpoint(0);
   832de:	4a1a      	ldr	r2, [pc, #104]	; (83348 <udd_test_mode_packet+0x88>)
   832e0:	69d3      	ldr	r3, [r2, #28]
   832e2:	f023 0301 	bic.w	r3, r3, #1
   832e6:	61d3      	str	r3, [r2, #28]
	udd_configure_endpoint(0, USB_EP_TYPE_BULK, 1,
   832e8:	4918      	ldr	r1, [pc, #96]	; (8334c <udd_test_mode_packet+0x8c>)
   832ea:	680b      	ldr	r3, [r1, #0]
   832ec:	f423 53cb 	bic.w	r3, r3, #6496	; 0x1960
   832f0:	f023 031c 	bic.w	r3, r3, #28
   832f4:	f443 5389 	orr.w	r3, r3, #4384	; 0x1120
   832f8:	f043 0310 	orr.w	r3, r3, #16
   832fc:	600b      	str	r3, [r1, #0]
	udd_allocate_memory(0);
   832fe:	680b      	ldr	r3, [r1, #0]
   83300:	f043 0302 	orr.w	r3, r3, #2
   83304:	600b      	str	r3, [r1, #0]
	udd_enable_endpoint(0);
   83306:	69d3      	ldr	r3, [r2, #28]
   83308:	f043 0301 	orr.w	r3, r3, #1
   8330c:	61d3      	str	r3, [r2, #28]
	udd_enable_hs_test_mode();
   8330e:	6813      	ldr	r3, [r2, #0]
   83310:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
   83314:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
   83318:	6013      	str	r3, [r2, #0]
	udd_enable_hs_test_mode_packet();
   8331a:	6813      	ldr	r3, [r2, #0]
   8331c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
   83320:	6013      	str	r3, [r2, #0]
   83322:	4a0b      	ldr	r2, [pc, #44]	; (83350 <udd_test_mode_packet+0x90>)
	ptr_src = test_packet;
   83324:	466b      	mov	r3, sp
	for (i = 0; i < sizeof(test_packet); i++) {
   83326:	f10d 0035 	add.w	r0, sp, #53	; 0x35
		*ptr_dest++ = *ptr_src++;
   8332a:	f813 1b01 	ldrb.w	r1, [r3], #1
   8332e:	f802 1f01 	strb.w	r1, [r2, #1]!
	for (i = 0; i < sizeof(test_packet); i++) {
   83332:	4283      	cmp	r3, r0
   83334:	d1f9      	bne.n	8332a <udd_test_mode_packet+0x6a>
	udd_ack_fifocon(0);
   83336:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   8333a:	4b06      	ldr	r3, [pc, #24]	; (83354 <udd_test_mode_packet+0x94>)
   8333c:	601a      	str	r2, [r3, #0]
}
   8333e:	b00e      	add	sp, #56	; 0x38
   83340:	bc30      	pop	{r4, r5}
   83342:	4770      	bx	lr
   83344:	00085fa8 	.word	0x00085fa8
   83348:	400ac000 	.word	0x400ac000
   8334c:	400ac100 	.word	0x400ac100
   83350:	2017ffff 	.word	0x2017ffff
   83354:	400ac220 	.word	0x400ac220

00083358 <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
   83358:	b410      	push	{r4}
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
   8335a:	010b      	lsls	r3, r1, #4
   8335c:	4293      	cmp	r3, r2
   8335e:	d914      	bls.n	8338a <usart_set_async_baudrate+0x32>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
   83360:	00c9      	lsls	r1, r1, #3
   83362:	084b      	lsrs	r3, r1, #1
   83364:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
   83368:	fbb2 f2f1 	udiv	r2, r2, r1
	cd = cd_fp >> 3;
   8336c:	08d3      	lsrs	r3, r2, #3
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
   8336e:	1e5c      	subs	r4, r3, #1
   83370:	f64f 71fe 	movw	r1, #65534	; 0xfffe
   83374:	428c      	cmp	r4, r1
   83376:	d901      	bls.n	8337c <usart_set_async_baudrate+0x24>
		return 1;
   83378:	2001      	movs	r0, #1
   8337a:	e017      	b.n	833ac <usart_set_async_baudrate+0x54>
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
		p_usart->US_MR |= US_MR_OVER;
   8337c:	6841      	ldr	r1, [r0, #4]
   8337e:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
   83382:	6041      	str	r1, [r0, #4]
   83384:	e00c      	b.n	833a0 <usart_set_async_baudrate+0x48>
		return 1;
   83386:	2001      	movs	r0, #1
   83388:	e010      	b.n	833ac <usart_set_async_baudrate+0x54>
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
   8338a:	0859      	lsrs	r1, r3, #1
   8338c:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
   83390:	fbb2 f2f3 	udiv	r2, r2, r3
	cd = cd_fp >> 3;
   83394:	08d3      	lsrs	r3, r2, #3
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
   83396:	1e5c      	subs	r4, r3, #1
   83398:	f64f 71fe 	movw	r1, #65534	; 0xfffe
   8339c:	428c      	cmp	r4, r1
   8339e:	d8f2      	bhi.n	83386 <usart_set_async_baudrate+0x2e>
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
   833a0:	0412      	lsls	r2, r2, #16
   833a2:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
   833a6:	431a      	orrs	r2, r3
   833a8:	6202      	str	r2, [r0, #32]

	return 0;
   833aa:	2000      	movs	r0, #0
}
   833ac:	bc10      	pop	{r4}
   833ae:	4770      	bx	lr

000833b0 <usart_reset>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
   833b0:	4b08      	ldr	r3, [pc, #32]	; (833d4 <usart_reset+0x24>)
   833b2:	f8c0 30e4 	str.w	r3, [r0, #228]	; 0xe4
	p_usart->US_MR = 0;
   833b6:	2300      	movs	r3, #0
   833b8:	6043      	str	r3, [r0, #4]
	p_usart->US_RTOR = 0;
   833ba:	6243      	str	r3, [r0, #36]	; 0x24
	p_usart->US_TTGR = 0;
   833bc:	6283      	str	r3, [r0, #40]	; 0x28
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
   833be:	2388      	movs	r3, #136	; 0x88
   833c0:	6003      	str	r3, [r0, #0]
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
   833c2:	2324      	movs	r3, #36	; 0x24
   833c4:	6003      	str	r3, [r0, #0]
	p_usart->US_CR = US_CR_RSTSTA;
   833c6:	f44f 7380 	mov.w	r3, #256	; 0x100
   833ca:	6003      	str	r3, [r0, #0]
	p_usart->US_CR = US_CR_RTSDIS;
   833cc:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   833d0:	6003      	str	r3, [r0, #0]
   833d2:	4770      	bx	lr
   833d4:	55534100 	.word	0x55534100

000833d8 <usart_init_rs232>:
{
   833d8:	b570      	push	{r4, r5, r6, lr}
   833da:	4605      	mov	r5, r0
   833dc:	460c      	mov	r4, r1
   833de:	4616      	mov	r6, r2
	usart_reset(p_usart);
   833e0:	4b0f      	ldr	r3, [pc, #60]	; (83420 <usart_init_rs232+0x48>)
   833e2:	4798      	blx	r3
	ul_reg_val = 0;
   833e4:	2200      	movs	r2, #0
   833e6:	4b0f      	ldr	r3, [pc, #60]	; (83424 <usart_init_rs232+0x4c>)
   833e8:	601a      	str	r2, [r3, #0]
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
   833ea:	b1a4      	cbz	r4, 83416 <usart_init_rs232+0x3e>
   833ec:	4632      	mov	r2, r6
   833ee:	6821      	ldr	r1, [r4, #0]
   833f0:	4628      	mov	r0, r5
   833f2:	4b0d      	ldr	r3, [pc, #52]	; (83428 <usart_init_rs232+0x50>)
   833f4:	4798      	blx	r3
   833f6:	4602      	mov	r2, r0
   833f8:	b978      	cbnz	r0, 8341a <usart_init_rs232+0x42>
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
   833fa:	6863      	ldr	r3, [r4, #4]
   833fc:	68a1      	ldr	r1, [r4, #8]
   833fe:	430b      	orrs	r3, r1
   83400:	6921      	ldr	r1, [r4, #16]
   83402:	430b      	orrs	r3, r1
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
   83404:	68e1      	ldr	r1, [r4, #12]
   83406:	430b      	orrs	r3, r1
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
   83408:	4906      	ldr	r1, [pc, #24]	; (83424 <usart_init_rs232+0x4c>)
   8340a:	600b      	str	r3, [r1, #0]
	p_usart->US_MR |= ul_reg_val;
   8340c:	6869      	ldr	r1, [r5, #4]
   8340e:	430b      	orrs	r3, r1
   83410:	606b      	str	r3, [r5, #4]
}
   83412:	4610      	mov	r0, r2
   83414:	bd70      	pop	{r4, r5, r6, pc}
		return 1;
   83416:	2201      	movs	r2, #1
   83418:	e7fb      	b.n	83412 <usart_init_rs232+0x3a>
   8341a:	2201      	movs	r2, #1
   8341c:	e7f9      	b.n	83412 <usart_init_rs232+0x3a>
   8341e:	bf00      	nop
   83420:	000833b1 	.word	0x000833b1
   83424:	20071108 	.word	0x20071108
   83428:	00083359 	.word	0x00083359

0008342c <usart_enable_tx>:
	p_usart->US_CR = US_CR_TXEN;
   8342c:	2340      	movs	r3, #64	; 0x40
   8342e:	6003      	str	r3, [r0, #0]
   83430:	4770      	bx	lr

00083432 <usart_disable_tx>:
	p_usart->US_CR = US_CR_TXDIS;
   83432:	2380      	movs	r3, #128	; 0x80
   83434:	6003      	str	r3, [r0, #0]
   83436:	4770      	bx	lr

00083438 <usart_enable_rx>:
	p_usart->US_CR = US_CR_RXEN;
   83438:	2310      	movs	r3, #16
   8343a:	6003      	str	r3, [r0, #0]
   8343c:	4770      	bx	lr

0008343e <usart_disable_rx>:
	p_usart->US_CR = US_CR_RXDIS;
   8343e:	2320      	movs	r3, #32
   83440:	6003      	str	r3, [r0, #0]
   83442:	4770      	bx	lr

00083444 <usart_set_rx_timeout>:
	p_usart->US_RTOR = timeout;
   83444:	6241      	str	r1, [r0, #36]	; 0x24
   83446:	4770      	bx	lr

00083448 <usart_enable_interrupt>:
	p_usart->US_IER = ul_sources;
   83448:	6081      	str	r1, [r0, #8]
   8344a:	4770      	bx	lr

0008344c <usart_disable_interrupt>:
	p_usart->US_IDR = ul_sources;
   8344c:	60c1      	str	r1, [r0, #12]
   8344e:	4770      	bx	lr

00083450 <usart_get_interrupt_mask>:
	return p_usart->US_IMR;
   83450:	6900      	ldr	r0, [r0, #16]
}
   83452:	4770      	bx	lr

00083454 <usart_get_status>:
	return p_usart->US_CSR;
   83454:	6940      	ldr	r0, [r0, #20]
}
   83456:	4770      	bx	lr

00083458 <usart_reset_status>:
	p_usart->US_CR = US_CR_RSTSTA;
   83458:	f44f 7380 	mov.w	r3, #256	; 0x100
   8345c:	6003      	str	r3, [r0, #0]
   8345e:	4770      	bx	lr

00083460 <usart_start_rx_timeout>:
	p_usart->US_CR = US_CR_STTTO;
   83460:	f44f 6300 	mov.w	r3, #2048	; 0x800
   83464:	6003      	str	r3, [r0, #0]
   83466:	4770      	bx	lr

00083468 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
   83468:	e7fe      	b.n	83468 <Dummy_Handler>
	...

0008346c <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   8346c:	b508      	push	{r3, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
   8346e:	4b1c      	ldr	r3, [pc, #112]	; (834e0 <Reset_Handler+0x74>)
   83470:	4a1c      	ldr	r2, [pc, #112]	; (834e4 <Reset_Handler+0x78>)
   83472:	429a      	cmp	r2, r3
   83474:	d010      	beq.n	83498 <Reset_Handler+0x2c>
		for (; pDest < &_erelocate;) {
   83476:	4b1c      	ldr	r3, [pc, #112]	; (834e8 <Reset_Handler+0x7c>)
   83478:	4a19      	ldr	r2, [pc, #100]	; (834e0 <Reset_Handler+0x74>)
   8347a:	429a      	cmp	r2, r3
   8347c:	d20c      	bcs.n	83498 <Reset_Handler+0x2c>
   8347e:	3b01      	subs	r3, #1
   83480:	1a9b      	subs	r3, r3, r2
   83482:	f023 0303 	bic.w	r3, r3, #3
   83486:	3304      	adds	r3, #4
   83488:	4413      	add	r3, r2
   8348a:	4916      	ldr	r1, [pc, #88]	; (834e4 <Reset_Handler+0x78>)
			*pDest++ = *pSrc++;
   8348c:	f851 0b04 	ldr.w	r0, [r1], #4
   83490:	f842 0b04 	str.w	r0, [r2], #4
		for (; pDest < &_erelocate;) {
   83494:	429a      	cmp	r2, r3
   83496:	d1f9      	bne.n	8348c <Reset_Handler+0x20>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   83498:	4b14      	ldr	r3, [pc, #80]	; (834ec <Reset_Handler+0x80>)
   8349a:	4a15      	ldr	r2, [pc, #84]	; (834f0 <Reset_Handler+0x84>)
   8349c:	429a      	cmp	r2, r3
   8349e:	d20a      	bcs.n	834b6 <Reset_Handler+0x4a>
   834a0:	3b01      	subs	r3, #1
   834a2:	1a9b      	subs	r3, r3, r2
   834a4:	f023 0303 	bic.w	r3, r3, #3
   834a8:	3304      	adds	r3, #4
   834aa:	4413      	add	r3, r2
		*pDest++ = 0;
   834ac:	2100      	movs	r1, #0
   834ae:	f842 1b04 	str.w	r1, [r2], #4
	for (pDest = &_szero; pDest < &_ezero;) {
   834b2:	4293      	cmp	r3, r2
   834b4:	d1fb      	bne.n	834ae <Reset_Handler+0x42>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   834b6:	4b0f      	ldr	r3, [pc, #60]	; (834f4 <Reset_Handler+0x88>)
   834b8:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
   834bc:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
   834c0:	490d      	ldr	r1, [pc, #52]	; (834f8 <Reset_Handler+0x8c>)
   834c2:	608a      	str	r2, [r1, #8]

	if (((uint32_t) pSrc >= IRAM0_ADDR) && ((uint32_t) pSrc < NFC_RAM_ADDR)) {
   834c4:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
   834c8:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   834cc:	d203      	bcs.n	834d6 <Reset_Handler+0x6a>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
   834ce:	688b      	ldr	r3, [r1, #8]
   834d0:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
   834d4:	608b      	str	r3, [r1, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
   834d6:	4b09      	ldr	r3, [pc, #36]	; (834fc <Reset_Handler+0x90>)
   834d8:	4798      	blx	r3

	/* Branch to main function */
	main();
   834da:	4b09      	ldr	r3, [pc, #36]	; (83500 <Reset_Handler+0x94>)
   834dc:	4798      	blx	r3
   834de:	e7fe      	b.n	834de <Reset_Handler+0x72>
   834e0:	20070000 	.word	0x20070000
   834e4:	000862bc 	.word	0x000862bc
   834e8:	200706ec 	.word	0x200706ec
   834ec:	200753e0 	.word	0x200753e0
   834f0:	200706ec 	.word	0x200706ec
   834f4:	00080000 	.word	0x00080000
   834f8:	e000ed00 	.word	0xe000ed00
   834fc:	00085a61 	.word	0x00085a61
   83500:	000857c9 	.word	0x000857c9

00083504 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate(void)
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) {
   83504:	4b3d      	ldr	r3, [pc, #244]	; (835fc <SystemCoreClockUpdate+0xf8>)
   83506:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   83508:	f003 0303 	and.w	r3, r3, #3
   8350c:	2b03      	cmp	r3, #3
   8350e:	d80e      	bhi.n	8352e <SystemCoreClockUpdate+0x2a>
   83510:	e8df f003 	tbb	[pc, r3]
   83514:	38381c02 	.word	0x38381c02
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
   83518:	4b39      	ldr	r3, [pc, #228]	; (83600 <SystemCoreClockUpdate+0xfc>)
   8351a:	695b      	ldr	r3, [r3, #20]
   8351c:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
   83520:	bf14      	ite	ne
   83522:	f44f 4200 	movne.w	r2, #32768	; 0x8000
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
   83526:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
   8352a:	4b36      	ldr	r3, [pc, #216]	; (83604 <SystemCoreClockUpdate+0x100>)
   8352c:	601a      	str	r2, [r3, #0]
			SystemCoreClock = SYS_UTMIPLL / 2U;
		}
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
   8352e:	4b33      	ldr	r3, [pc, #204]	; (835fc <SystemCoreClockUpdate+0xf8>)
   83530:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   83532:	f003 0370 	and.w	r3, r3, #112	; 0x70
   83536:	2b70      	cmp	r3, #112	; 0x70
   83538:	d057      	beq.n	835ea <SystemCoreClockUpdate+0xe6>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> 
   8353a:	4b30      	ldr	r3, [pc, #192]	; (835fc <SystemCoreClockUpdate+0xf8>)
   8353c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   8353e:	4931      	ldr	r1, [pc, #196]	; (83604 <SystemCoreClockUpdate+0x100>)
   83540:	f3c2 1202 	ubfx	r2, r2, #4, #3
   83544:	680b      	ldr	r3, [r1, #0]
   83546:	40d3      	lsrs	r3, r2
   83548:	600b      	str	r3, [r1, #0]
   8354a:	4770      	bx	lr
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
   8354c:	4b2b      	ldr	r3, [pc, #172]	; (835fc <SystemCoreClockUpdate+0xf8>)
   8354e:	6a1b      	ldr	r3, [r3, #32]
   83550:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   83554:	d003      	beq.n	8355e <SystemCoreClockUpdate+0x5a>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
   83556:	4a2c      	ldr	r2, [pc, #176]	; (83608 <SystemCoreClockUpdate+0x104>)
   83558:	4b2a      	ldr	r3, [pc, #168]	; (83604 <SystemCoreClockUpdate+0x100>)
   8355a:	601a      	str	r2, [r3, #0]
   8355c:	e7e7      	b.n	8352e <SystemCoreClockUpdate+0x2a>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   8355e:	4a2b      	ldr	r2, [pc, #172]	; (8360c <SystemCoreClockUpdate+0x108>)
   83560:	4b28      	ldr	r3, [pc, #160]	; (83604 <SystemCoreClockUpdate+0x100>)
   83562:	601a      	str	r2, [r3, #0]
			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
   83564:	4b25      	ldr	r3, [pc, #148]	; (835fc <SystemCoreClockUpdate+0xf8>)
   83566:	6a1b      	ldr	r3, [r3, #32]
   83568:	f003 0370 	and.w	r3, r3, #112	; 0x70
   8356c:	2b10      	cmp	r3, #16
   8356e:	d005      	beq.n	8357c <SystemCoreClockUpdate+0x78>
   83570:	2b20      	cmp	r3, #32
   83572:	d1dc      	bne.n	8352e <SystemCoreClockUpdate+0x2a>
				SystemCoreClock *= 3U;
   83574:	4a24      	ldr	r2, [pc, #144]	; (83608 <SystemCoreClockUpdate+0x104>)
   83576:	4b23      	ldr	r3, [pc, #140]	; (83604 <SystemCoreClockUpdate+0x100>)
   83578:	601a      	str	r2, [r3, #0]
				break;
   8357a:	e7d8      	b.n	8352e <SystemCoreClockUpdate+0x2a>
				SystemCoreClock *= 2U;
   8357c:	4a24      	ldr	r2, [pc, #144]	; (83610 <SystemCoreClockUpdate+0x10c>)
   8357e:	4b21      	ldr	r3, [pc, #132]	; (83604 <SystemCoreClockUpdate+0x100>)
   83580:	601a      	str	r2, [r3, #0]
				break;
   83582:	e7d4      	b.n	8352e <SystemCoreClockUpdate+0x2a>
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
   83584:	4b1d      	ldr	r3, [pc, #116]	; (835fc <SystemCoreClockUpdate+0xf8>)
   83586:	6a1b      	ldr	r3, [r3, #32]
   83588:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
   8358c:	d00c      	beq.n	835a8 <SystemCoreClockUpdate+0xa4>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
   8358e:	4a1e      	ldr	r2, [pc, #120]	; (83608 <SystemCoreClockUpdate+0x104>)
   83590:	4b1c      	ldr	r3, [pc, #112]	; (83604 <SystemCoreClockUpdate+0x100>)
   83592:	601a      	str	r2, [r3, #0]
		if ((PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
   83594:	4b19      	ldr	r3, [pc, #100]	; (835fc <SystemCoreClockUpdate+0xf8>)
   83596:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   83598:	f003 0303 	and.w	r3, r3, #3
   8359c:	2b02      	cmp	r3, #2
   8359e:	d016      	beq.n	835ce <SystemCoreClockUpdate+0xca>
			SystemCoreClock = SYS_UTMIPLL / 2U;
   835a0:	4a1c      	ldr	r2, [pc, #112]	; (83614 <SystemCoreClockUpdate+0x110>)
   835a2:	4b18      	ldr	r3, [pc, #96]	; (83604 <SystemCoreClockUpdate+0x100>)
   835a4:	601a      	str	r2, [r3, #0]
   835a6:	e7c2      	b.n	8352e <SystemCoreClockUpdate+0x2a>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   835a8:	4a18      	ldr	r2, [pc, #96]	; (8360c <SystemCoreClockUpdate+0x108>)
   835aa:	4b16      	ldr	r3, [pc, #88]	; (83604 <SystemCoreClockUpdate+0x100>)
   835ac:	601a      	str	r2, [r3, #0]
			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
   835ae:	4b13      	ldr	r3, [pc, #76]	; (835fc <SystemCoreClockUpdate+0xf8>)
   835b0:	6a1b      	ldr	r3, [r3, #32]
   835b2:	f003 0370 	and.w	r3, r3, #112	; 0x70
   835b6:	2b10      	cmp	r3, #16
   835b8:	d005      	beq.n	835c6 <SystemCoreClockUpdate+0xc2>
   835ba:	2b20      	cmp	r3, #32
   835bc:	d1ea      	bne.n	83594 <SystemCoreClockUpdate+0x90>
				SystemCoreClock *= 3U;
   835be:	4a12      	ldr	r2, [pc, #72]	; (83608 <SystemCoreClockUpdate+0x104>)
   835c0:	4b10      	ldr	r3, [pc, #64]	; (83604 <SystemCoreClockUpdate+0x100>)
   835c2:	601a      	str	r2, [r3, #0]
				break;
   835c4:	e7e6      	b.n	83594 <SystemCoreClockUpdate+0x90>
				SystemCoreClock *= 2U;
   835c6:	4a12      	ldr	r2, [pc, #72]	; (83610 <SystemCoreClockUpdate+0x10c>)
   835c8:	4b0e      	ldr	r3, [pc, #56]	; (83604 <SystemCoreClockUpdate+0x100>)
   835ca:	601a      	str	r2, [r3, #0]
				break;
   835cc:	e7e2      	b.n	83594 <SystemCoreClockUpdate+0x90>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
   835ce:	4a0b      	ldr	r2, [pc, #44]	; (835fc <SystemCoreClockUpdate+0xf8>)
   835d0:	6a91      	ldr	r1, [r2, #40]	; 0x28
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
   835d2:	6a92      	ldr	r2, [r2, #40]	; 0x28
   835d4:	480b      	ldr	r0, [pc, #44]	; (83604 <SystemCoreClockUpdate+0x100>)
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
   835d6:	f3c1 410a 	ubfx	r1, r1, #16, #11
   835da:	6803      	ldr	r3, [r0, #0]
   835dc:	fb01 3303 	mla	r3, r1, r3, r3
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
   835e0:	b2d2      	uxtb	r2, r2
   835e2:	fbb3 f3f2 	udiv	r3, r3, r2
   835e6:	6003      	str	r3, [r0, #0]
   835e8:	e7a1      	b.n	8352e <SystemCoreClockUpdate+0x2a>
		SystemCoreClock /= 3U;
   835ea:	4a06      	ldr	r2, [pc, #24]	; (83604 <SystemCoreClockUpdate+0x100>)
   835ec:	6813      	ldr	r3, [r2, #0]
   835ee:	490a      	ldr	r1, [pc, #40]	; (83618 <SystemCoreClockUpdate+0x114>)
   835f0:	fba1 1303 	umull	r1, r3, r1, r3
   835f4:	085b      	lsrs	r3, r3, #1
   835f6:	6013      	str	r3, [r2, #0]
   835f8:	4770      	bx	lr
   835fa:	bf00      	nop
   835fc:	400e0600 	.word	0x400e0600
   83600:	400e1a10 	.word	0x400e1a10
   83604:	20070270 	.word	0x20070270
   83608:	00b71b00 	.word	0x00b71b00
   8360c:	003d0900 	.word	0x003d0900
   83610:	007a1200 	.word	0x007a1200
   83614:	0e4e1c00 	.word	0x0e4e1c00
   83618:	aaaaaaab 	.word	0xaaaaaaab

0008361c <usart_echo_rx_task>:
}

/*-----------------------------------------------------------*/

static void usart_echo_rx_task(void *pvParameters)
{
   8361c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8361e:	4607      	mov	r7, r0
	/* The (already open) USART port is passed in as the task parameter. */
	usart_port = (freertos_usart_if)pvParameters;
	uint8_t poot = 0;
	uint8_t local[RX_BUFFER_SIZE];
	for (;;) {
		memset(rx_buffer, 0x00, sizeof(rx_buffer));
   83620:	4c24      	ldr	r4, [pc, #144]	; (836b4 <usart_echo_rx_task+0x98>)
   83622:	4e25      	ldr	r6, [pc, #148]	; (836b8 <usart_echo_rx_task+0x9c>)

		received = freertos_usart_serial_read_packet(usart_port, rx_buffer,
   83624:	4d25      	ldr	r5, [pc, #148]	; (836bc <usart_echo_rx_task+0xa0>)
   83626:	e002      	b.n	8362e <usart_echo_rx_task+0x12>
		memcpy(local,rx_buffer,1);
		poot = local[0];
		switch(poot)
		{
			case 'b':
				SmState = STATE_MOVING_REVERSE;
   83628:	2205      	movs	r2, #5
   8362a:	4b25      	ldr	r3, [pc, #148]	; (836c0 <usart_echo_rx_task+0xa4>)
   8362c:	701a      	strb	r2, [r3, #0]
		memset(rx_buffer, 0x00, sizeof(rx_buffer));
   8362e:	224f      	movs	r2, #79	; 0x4f
   83630:	2100      	movs	r1, #0
   83632:	4620      	mov	r0, r4
   83634:	47b0      	blx	r6
		received = freertos_usart_serial_read_packet(usart_port, rx_buffer,
   83636:	f04f 33ff 	mov.w	r3, #4294967295
   8363a:	2201      	movs	r2, #1
   8363c:	4621      	mov	r1, r4
   8363e:	4638      	mov	r0, r7
   83640:	47a8      	blx	r5
		switch(poot)
   83642:	7823      	ldrb	r3, [r4, #0]
   83644:	3b62      	subs	r3, #98	; 0x62
   83646:	2b10      	cmp	r3, #16
   83648:	d830      	bhi.n	836ac <usart_echo_rx_task+0x90>
   8364a:	a201      	add	r2, pc, #4	; (adr r2, 83650 <usart_echo_rx_task+0x34>)
   8364c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   83650:	00083629 	.word	0x00083629
   83654:	000836ad 	.word	0x000836ad
   83658:	000836ad 	.word	0x000836ad
   8365c:	000836ad 	.word	0x000836ad
   83660:	00083695 	.word	0x00083695
   83664:	000836ad 	.word	0x000836ad
   83668:	000836ad 	.word	0x000836ad
   8366c:	000836ad 	.word	0x000836ad
   83670:	000836ad 	.word	0x000836ad
   83674:	000836ad 	.word	0x000836ad
   83678:	0008369d 	.word	0x0008369d
   8367c:	000836ad 	.word	0x000836ad
   83680:	000836ad 	.word	0x000836ad
   83684:	000836ad 	.word	0x000836ad
   83688:	000836ad 	.word	0x000836ad
   8368c:	000836ad 	.word	0x000836ad
   83690:	000836a5 	.word	0x000836a5
				break;
			case 'f':
				SmState = STATE_MOVING_FORWARD;
   83694:	2202      	movs	r2, #2
   83696:	4b0a      	ldr	r3, [pc, #40]	; (836c0 <usart_echo_rx_task+0xa4>)
   83698:	701a      	strb	r2, [r3, #0]
				break;
   8369a:	e7c8      	b.n	8362e <usart_echo_rx_task+0x12>
			case 'l':
				SmState = STATE_TURNING_LEFT;
   8369c:	2203      	movs	r2, #3
   8369e:	4b08      	ldr	r3, [pc, #32]	; (836c0 <usart_echo_rx_task+0xa4>)
   836a0:	701a      	strb	r2, [r3, #0]
				break;
   836a2:	e7c4      	b.n	8362e <usart_echo_rx_task+0x12>
			case 'r':
				SmState = STATE_TURNING_RIGHT;
   836a4:	2204      	movs	r2, #4
   836a6:	4b06      	ldr	r3, [pc, #24]	; (836c0 <usart_echo_rx_task+0xa4>)
   836a8:	701a      	strb	r2, [r3, #0]
				break;
   836aa:	e7c0      	b.n	8362e <usart_echo_rx_task+0x12>
			default:
				SmState = STATE_STANDBY;
   836ac:	2201      	movs	r2, #1
   836ae:	4b04      	ldr	r3, [pc, #16]	; (836c0 <usart_echo_rx_task+0xa4>)
   836b0:	701a      	strb	r2, [r3, #0]
				break;
   836b2:	e7bc      	b.n	8362e <usart_echo_rx_task+0x12>
   836b4:	200711ac 	.word	0x200711ac
   836b8:	00085b9d 	.word	0x00085b9d
   836bc:	00080de9 	.word	0x00080de9
   836c0:	20075354 	.word	0x20075354

000836c4 <usart_echo_tx_task>:
{
   836c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   836c8:	b083      	sub	sp, #12
   836ca:	4607      	mov	r7, r0
	vSemaphoreCreateBinary(notification_semaphore);
   836cc:	2203      	movs	r2, #3
   836ce:	2100      	movs	r1, #0
   836d0:	2001      	movs	r0, #1
   836d2:	4b1c      	ldr	r3, [pc, #112]	; (83744 <usart_echo_tx_task+0x80>)
   836d4:	4798      	blx	r3
   836d6:	4605      	mov	r5, r0
   836d8:	2800      	cmp	r0, #0
   836da:	d02e      	beq.n	8373a <usart_echo_tx_task+0x76>
   836dc:	2300      	movs	r3, #0
   836de:	461a      	mov	r2, r3
   836e0:	4619      	mov	r1, r3
   836e2:	4c19      	ldr	r4, [pc, #100]	; (83748 <usart_echo_tx_task+0x84>)
   836e4:	47a0      	blx	r4
	xSemaphoreTake(notification_semaphore, 0);
   836e6:	2100      	movs	r1, #0
   836e8:	4628      	mov	r0, r5
   836ea:	4b18      	ldr	r3, [pc, #96]	; (8374c <usart_echo_tx_task+0x88>)
   836ec:	4798      	blx	r3
		strcpy((char *) local_buffer,
   836ee:	f8df 907c 	ldr.w	r9, [pc, #124]	; 8376c <usart_echo_tx_task+0xa8>
   836f2:	f8df 807c 	ldr.w	r8, [pc, #124]	; 83770 <usart_echo_tx_task+0xac>
   836f6:	4c16      	ldr	r4, [pc, #88]	; (83750 <usart_echo_tx_task+0x8c>)
   836f8:	e007      	b.n	8370a <usart_echo_tx_task+0x46>
		xSemaphoreTake(notification_semaphore, time_out_definition * 2);
   836fa:	21c8      	movs	r1, #200	; 0xc8
   836fc:	4628      	mov	r0, r5
   836fe:	4b13      	ldr	r3, [pc, #76]	; (8374c <usart_echo_tx_task+0x88>)
   83700:	4798      	blx	r3
		vTaskDelay(500);
   83702:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
   83706:	4b13      	ldr	r3, [pc, #76]	; (83754 <usart_echo_tx_task+0x90>)
   83708:	4798      	blx	r3
		strcpy((char *) local_buffer,
   8370a:	f898 3000 	ldrb.w	r3, [r8]
   8370e:	f859 1023 	ldr.w	r1, [r9, r3, lsl #2]
   83712:	4620      	mov	r0, r4
   83714:	4b10      	ldr	r3, [pc, #64]	; (83758 <usart_echo_tx_task+0x94>)
   83716:	4798      	blx	r3
		returned_status = freertos_usart_write_packet_async(usart_port,
   83718:	4620      	mov	r0, r4
   8371a:	4b10      	ldr	r3, [pc, #64]	; (8375c <usart_echo_tx_task+0x98>)
   8371c:	4798      	blx	r3
   8371e:	9500      	str	r5, [sp, #0]
   83720:	2364      	movs	r3, #100	; 0x64
   83722:	4602      	mov	r2, r0
   83724:	4621      	mov	r1, r4
   83726:	4638      	mov	r0, r7
   83728:	4e0d      	ldr	r6, [pc, #52]	; (83760 <usart_echo_tx_task+0x9c>)
   8372a:	47b0      	blx	r6
		configASSERT(returned_status == STATUS_OK);
   8372c:	2800      	cmp	r0, #0
   8372e:	d0e4      	beq.n	836fa <usart_echo_tx_task+0x36>
   83730:	21a2      	movs	r1, #162	; 0xa2
   83732:	480c      	ldr	r0, [pc, #48]	; (83764 <usart_echo_tx_task+0xa0>)
   83734:	4b0c      	ldr	r3, [pc, #48]	; (83768 <usart_echo_tx_task+0xa4>)
   83736:	4798      	blx	r3
   83738:	e7df      	b.n	836fa <usart_echo_tx_task+0x36>
	configASSERT(notification_semaphore);
   8373a:	2191      	movs	r1, #145	; 0x91
   8373c:	4809      	ldr	r0, [pc, #36]	; (83764 <usart_echo_tx_task+0xa0>)
   8373e:	4b0a      	ldr	r3, [pc, #40]	; (83768 <usart_echo_tx_task+0xa4>)
   83740:	4798      	blx	r3
   83742:	e7d0      	b.n	836e6 <usart_echo_tx_task+0x22>
   83744:	00083e99 	.word	0x00083e99
   83748:	00083f31 	.word	0x00083f31
   8374c:	00084411 	.word	0x00084411
   83750:	2007110c 	.word	0x2007110c
   83754:	00084ce1 	.word	0x00084ce1
   83758:	00085c39 	.word	0x00085c39
   8375c:	00085cf5 	.word	0x00085cf5
   83760:	00080d5d 	.word	0x00080d5d
   83764:	00086040 	.word	0x00086040
   83768:	00085861 	.word	0x00085861
   8376c:	20070274 	.word	0x20070274
   83770:	20075354 	.word	0x20075354

00083774 <create_usart_echo_test_tasks>:
{
   83774:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   83778:	b08c      	sub	sp, #48	; 0x30
   8377a:	4686      	mov	lr, r0
   8377c:	4688      	mov	r8, r1
   8377e:	4617      	mov	r7, r2
	freertos_peripheral_options_t driver_options = {
   83780:	4c16      	ldr	r4, [pc, #88]	; (837dc <create_usart_echo_test_tasks+0x68>)
   83782:	ae08      	add	r6, sp, #32
   83784:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
   83788:	e886 000f 	stmia.w	r6, {r0, r1, r2, r3}
	const sam_usart_opt_t usart_settings = {
   8378c:	ad02      	add	r5, sp, #8
   8378e:	3410      	adds	r4, #16
   83790:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
   83792:	c50f      	stmia	r5!, {r0, r1, r2, r3}
   83794:	e894 0003 	ldmia.w	r4, {r0, r1}
   83798:	e885 0003 	stmia.w	r5, {r0, r1}
	freertos_usart = freertos_usart_serial_init(usart_base,
   8379c:	4632      	mov	r2, r6
   8379e:	a902      	add	r1, sp, #8
   837a0:	4670      	mov	r0, lr
   837a2:	4b0f      	ldr	r3, [pc, #60]	; (837e0 <create_usart_echo_test_tasks+0x6c>)
   837a4:	4798      	blx	r3
	configASSERT(freertos_usart);
   837a6:	4605      	mov	r5, r0
   837a8:	b198      	cbz	r0, 837d2 <create_usart_echo_test_tasks+0x5e>
	xTaskCreate(usart_echo_tx_task, (const signed char *const) "Tx",
   837aa:	2600      	movs	r6, #0
   837ac:	9601      	str	r6, [sp, #4]
   837ae:	9700      	str	r7, [sp, #0]
   837b0:	462b      	mov	r3, r5
   837b2:	4642      	mov	r2, r8
   837b4:	490b      	ldr	r1, [pc, #44]	; (837e4 <create_usart_echo_test_tasks+0x70>)
   837b6:	480c      	ldr	r0, [pc, #48]	; (837e8 <create_usart_echo_test_tasks+0x74>)
   837b8:	4c0c      	ldr	r4, [pc, #48]	; (837ec <create_usart_echo_test_tasks+0x78>)
   837ba:	47a0      	blx	r4
	xTaskCreate(usart_echo_rx_task, (const signed char *const) "Rx",
   837bc:	9601      	str	r6, [sp, #4]
   837be:	3701      	adds	r7, #1
   837c0:	9700      	str	r7, [sp, #0]
   837c2:	462b      	mov	r3, r5
   837c4:	4642      	mov	r2, r8
   837c6:	490a      	ldr	r1, [pc, #40]	; (837f0 <create_usart_echo_test_tasks+0x7c>)
   837c8:	480a      	ldr	r0, [pc, #40]	; (837f4 <create_usart_echo_test_tasks+0x80>)
   837ca:	47a0      	blx	r4
}
   837cc:	b00c      	add	sp, #48	; 0x30
   837ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	configASSERT(freertos_usart);
   837d2:	2176      	movs	r1, #118	; 0x76
   837d4:	4808      	ldr	r0, [pc, #32]	; (837f8 <create_usart_echo_test_tasks+0x84>)
   837d6:	4b09      	ldr	r3, [pc, #36]	; (837fc <create_usart_echo_test_tasks+0x88>)
   837d8:	4798      	blx	r3
   837da:	e7e6      	b.n	837aa <create_usart_echo_test_tasks+0x36>
   837dc:	00085fe0 	.word	0x00085fe0
   837e0:	00080b69 	.word	0x00080b69
   837e4:	00086008 	.word	0x00086008
   837e8:	000836c5 	.word	0x000836c5
   837ec:	000847cd 	.word	0x000847cd
   837f0:	0008600c 	.word	0x0008600c
   837f4:	0008361d 	.word	0x0008361d
   837f8:	00086040 	.word	0x00086040
   837fc:	00085861 	.word	0x00085861

00083800 <cli_vbus_event>:
/*-----------------------------------------------------------*/

#endif

void cli_vbus_event(bool b_vbus_high)
{
   83800:	b508      	push	{r3, lr}
	if (b_vbus_high == true) {
   83802:	b910      	cbnz	r0, 8380a <cli_vbus_event+0xa>
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
	udd_detach();
   83804:	4b02      	ldr	r3, [pc, #8]	; (83810 <cli_vbus_event+0x10>)
   83806:	4798      	blx	r3
   83808:	bd08      	pop	{r3, pc}
	udd_attach();
   8380a:	4b02      	ldr	r3, [pc, #8]	; (83814 <cli_vbus_event+0x14>)
   8380c:	4798      	blx	r3
   8380e:	bd08      	pop	{r3, pc}
   83810:	000825dd 	.word	0x000825dd
   83814:	00082551 	.word	0x00082551

00083818 <cli_cdc_enable>:

bool cli_cdc_enable(uint8_t port)
{
	(void) port;

	cdc_connected = true;
   83818:	2001      	movs	r0, #1
   8381a:	4b01      	ldr	r3, [pc, #4]	; (83820 <cli_cdc_enable+0x8>)
   8381c:	7018      	strb	r0, [r3, #0]
	return true;
}
   8381e:	4770      	bx	lr
   83820:	200711fb 	.word	0x200711fb

00083824 <cli_cdc_rx_notify>:

/*-----------------------------------------------------------*/

void cli_cdc_rx_notify(uint8_t port)
{
   83824:	b500      	push	{lr}
   83826:	b083      	sub	sp, #12
	portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
   83828:	2300      	movs	r3, #0
   8382a:	9301      	str	r3, [sp, #4]

	(void) port;

	/* Sanity check the event semaphore before giving it to indicate to the
	 * task that data is available. */
	configASSERT(cdc_new_data_semaphore);
   8382c:	4b0d      	ldr	r3, [pc, #52]	; (83864 <cli_cdc_rx_notify+0x40>)
   8382e:	681b      	ldr	r3, [r3, #0]
   83830:	b18b      	cbz	r3, 83856 <cli_cdc_rx_notify+0x32>
	xSemaphoreGiveFromISR(cdc_new_data_semaphore,
   83832:	a901      	add	r1, sp, #4
   83834:	4b0b      	ldr	r3, [pc, #44]	; (83864 <cli_cdc_rx_notify+0x40>)
   83836:	6818      	ldr	r0, [r3, #0]
   83838:	4b0b      	ldr	r3, [pc, #44]	; (83868 <cli_cdc_rx_notify+0x44>)
   8383a:	4798      	blx	r3
			&xHigherPriorityTaskWoken);
	portEND_SWITCHING_ISR(xHigherPriorityTaskWoken);
   8383c:	9b01      	ldr	r3, [sp, #4]
   8383e:	b13b      	cbz	r3, 83850 <cli_cdc_rx_notify+0x2c>
   83840:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   83844:	4b09      	ldr	r3, [pc, #36]	; (8386c <cli_cdc_rx_notify+0x48>)
   83846:	601a      	str	r2, [r3, #0]
   83848:	f3bf 8f4f 	dsb	sy
   8384c:	f3bf 8f6f 	isb	sy
}
   83850:	b003      	add	sp, #12
   83852:	f85d fb04 	ldr.w	pc, [sp], #4
	configASSERT(cdc_new_data_semaphore);
   83856:	f240 1117 	movw	r1, #279	; 0x117
   8385a:	4805      	ldr	r0, [pc, #20]	; (83870 <cli_cdc_rx_notify+0x4c>)
   8385c:	4b05      	ldr	r3, [pc, #20]	; (83874 <cli_cdc_rx_notify+0x50>)
   8385e:	4798      	blx	r3
   83860:	e7e7      	b.n	83832 <cli_cdc_rx_notify+0xe>
   83862:	bf00      	nop
   83864:	200711fc 	.word	0x200711fc
   83868:	000841d9 	.word	0x000841d9
   8386c:	e000ed04 	.word	0xe000ed04
   83870:	00086098 	.word	0x00086098
   83874:	00085861 	.word	0x00085861

00083878 <cli_cdc_disable>:

void cli_cdc_disable(uint8_t port)
{
	(void) port;

	cdc_connected = false;
   83878:	2200      	movs	r2, #0
   8387a:	4b01      	ldr	r3, [pc, #4]	; (83880 <cli_cdc_disable+0x8>)
   8387c:	701a      	strb	r2, [r3, #0]
   8387e:	4770      	bx	lr
   83880:	200711fb 	.word	0x200711fb

00083884 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   83884:	f100 0308 	add.w	r3, r0, #8
   83888:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   8388a:	f04f 32ff 	mov.w	r2, #4294967295
   8388e:	6082      	str	r2, [r0, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   83890:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   83892:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   83894:	2300      	movs	r3, #0
   83896:	6003      	str	r3, [r0, #0]
   83898:	4770      	bx	lr

0008389a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   8389a:	2300      	movs	r3, #0
   8389c:	6103      	str	r3, [r0, #16]
   8389e:	4770      	bx	lr

000838a0 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
   838a0:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   838a2:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   838a4:	689a      	ldr	r2, [r3, #8]
   838a6:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
   838a8:	689a      	ldr	r2, [r3, #8]
   838aa:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
   838ac:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   838ae:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   838b0:	6803      	ldr	r3, [r0, #0]
   838b2:	3301      	adds	r3, #1
   838b4:	6003      	str	r3, [r0, #0]
   838b6:	4770      	bx	lr

000838b8 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   838b8:	b430      	push	{r4, r5}
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   838ba:	680d      	ldr	r5, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   838bc:	f1b5 3fff 	cmp.w	r5, #4294967295
   838c0:	d002      	beq.n	838c8 <vListInsert+0x10>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   838c2:	f100 0208 	add.w	r2, r0, #8
   838c6:	e002      	b.n	838ce <vListInsert+0x16>
		pxIterator = pxList->xListEnd.pxPrevious;
   838c8:	6902      	ldr	r2, [r0, #16]
   838ca:	e004      	b.n	838d6 <vListInsert+0x1e>
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   838cc:	461a      	mov	r2, r3
   838ce:	6853      	ldr	r3, [r2, #4]
   838d0:	681c      	ldr	r4, [r3, #0]
   838d2:	42a5      	cmp	r5, r4
   838d4:	d2fa      	bcs.n	838cc <vListInsert+0x14>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   838d6:	6853      	ldr	r3, [r2, #4]
   838d8:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   838da:	6099      	str	r1, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   838dc:	608a      	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
   838de:	6051      	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   838e0:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
   838e2:	6803      	ldr	r3, [r0, #0]
   838e4:	3301      	adds	r3, #1
   838e6:	6003      	str	r3, [r0, #0]
}
   838e8:	bc30      	pop	{r4, r5}
   838ea:	4770      	bx	lr

000838ec <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   838ec:	6903      	ldr	r3, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   838ee:	6842      	ldr	r2, [r0, #4]
   838f0:	6881      	ldr	r1, [r0, #8]
   838f2:	6091      	str	r1, [r2, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   838f4:	6882      	ldr	r2, [r0, #8]
   838f6:	6841      	ldr	r1, [r0, #4]
   838f8:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   838fa:	685a      	ldr	r2, [r3, #4]
   838fc:	4290      	cmp	r0, r2
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   838fe:	bf04      	itt	eq
   83900:	6882      	ldreq	r2, [r0, #8]
   83902:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   83904:	2200      	movs	r2, #0
   83906:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
   83908:	681a      	ldr	r2, [r3, #0]
   8390a:	3a01      	subs	r2, #1
   8390c:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   8390e:	6818      	ldr	r0, [r3, #0]
}
   83910:	4770      	bx	lr
	...

00083914 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
   83914:	4806      	ldr	r0, [pc, #24]	; (83930 <prvPortStartFirstTask+0x1c>)
   83916:	6800      	ldr	r0, [r0, #0]
   83918:	6800      	ldr	r0, [r0, #0]
   8391a:	f380 8808 	msr	MSP, r0
   8391e:	b662      	cpsie	i
   83920:	b661      	cpsie	f
   83922:	f3bf 8f4f 	dsb	sy
   83926:	f3bf 8f6f 	isb	sy
   8392a:	df00      	svc	0
   8392c:	bf00      	nop
   8392e:	0000      	.short	0x0000
   83930:	e000ed08 	.word	0xe000ed08

00083934 <prvTaskExitError>:
{
   83934:	b500      	push	{lr}
   83936:	b083      	sub	sp, #12
volatile uint32_t ulDummy = 0UL;
   83938:	2300      	movs	r3, #0
   8393a:	9301      	str	r3, [sp, #4]
	configASSERT( uxCriticalNesting == ~0UL );
   8393c:	4b0b      	ldr	r3, [pc, #44]	; (8396c <prvTaskExitError+0x38>)
   8393e:	681b      	ldr	r3, [r3, #0]
   83940:	f1b3 3fff 	cmp.w	r3, #4294967295
   83944:	d003      	beq.n	8394e <prvTaskExitError+0x1a>
   83946:	21cb      	movs	r1, #203	; 0xcb
   83948:	4809      	ldr	r0, [pc, #36]	; (83970 <prvTaskExitError+0x3c>)
   8394a:	4b0a      	ldr	r3, [pc, #40]	; (83974 <prvTaskExitError+0x40>)
   8394c:	4798      	blx	r3

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
   8394e:	f04f 03a0 	mov.w	r3, #160	; 0xa0
   83952:	f383 8811 	msr	BASEPRI, r3
   83956:	f3bf 8f6f 	isb	sy
   8395a:	f3bf 8f4f 	dsb	sy
	while( ulDummy == 0 )
   8395e:	9b01      	ldr	r3, [sp, #4]
   83960:	2b00      	cmp	r3, #0
   83962:	d0fc      	beq.n	8395e <prvTaskExitError+0x2a>
}
   83964:	b003      	add	sp, #12
   83966:	f85d fb04 	ldr.w	pc, [sp], #4
   8396a:	bf00      	nop
   8396c:	2007028c 	.word	0x2007028c
   83970:	000860f8 	.word	0x000860f8
   83974:	00085861 	.word	0x00085861

00083978 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   83978:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
   8397c:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
   83980:	f021 0101 	bic.w	r1, r1, #1
   83984:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   83988:	4b03      	ldr	r3, [pc, #12]	; (83998 <pxPortInitialiseStack+0x20>)
   8398a:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   8398e:	f840 2c20 	str.w	r2, [r0, #-32]
}
   83992:	3840      	subs	r0, #64	; 0x40
   83994:	4770      	bx	lr
   83996:	bf00      	nop
   83998:	00083935 	.word	0x00083935
   8399c:	00000000 	.word	0x00000000

000839a0 <SVC_Handler>:
	__asm volatile (
   839a0:	4b07      	ldr	r3, [pc, #28]	; (839c0 <pxCurrentTCBConst2>)
   839a2:	6819      	ldr	r1, [r3, #0]
   839a4:	6808      	ldr	r0, [r1, #0]
   839a6:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   839aa:	f380 8809 	msr	PSP, r0
   839ae:	f3bf 8f6f 	isb	sy
   839b2:	f04f 0000 	mov.w	r0, #0
   839b6:	f380 8811 	msr	BASEPRI, r0
   839ba:	f04e 0e0d 	orr.w	lr, lr, #13
   839be:	4770      	bx	lr

000839c0 <pxCurrentTCBConst2>:
   839c0:	20075210 	.word	0x20075210

000839c4 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   839c4:	b508      	push	{r3, lr}
   839c6:	f04f 03a0 	mov.w	r3, #160	; 0xa0
   839ca:	f383 8811 	msr	BASEPRI, r3
   839ce:	f3bf 8f6f 	isb	sy
   839d2:	f3bf 8f4f 	dsb	sy
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
   839d6:	4a09      	ldr	r2, [pc, #36]	; (839fc <vPortEnterCritical+0x38>)
   839d8:	6813      	ldr	r3, [r2, #0]
   839da:	3301      	adds	r3, #1
   839dc:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
   839de:	2b01      	cmp	r3, #1
   839e0:	d000      	beq.n	839e4 <vPortEnterCritical+0x20>
   839e2:	bd08      	pop	{r3, pc}
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
   839e4:	4b06      	ldr	r3, [pc, #24]	; (83a00 <vPortEnterCritical+0x3c>)
   839e6:	681b      	ldr	r3, [r3, #0]
   839e8:	f013 0fff 	tst.w	r3, #255	; 0xff
   839ec:	d0f9      	beq.n	839e2 <vPortEnterCritical+0x1e>
   839ee:	f44f 71bb 	mov.w	r1, #374	; 0x176
   839f2:	4804      	ldr	r0, [pc, #16]	; (83a04 <vPortEnterCritical+0x40>)
   839f4:	4b04      	ldr	r3, [pc, #16]	; (83a08 <vPortEnterCritical+0x44>)
   839f6:	4798      	blx	r3
	}
}
   839f8:	e7f3      	b.n	839e2 <vPortEnterCritical+0x1e>
   839fa:	bf00      	nop
   839fc:	2007028c 	.word	0x2007028c
   83a00:	e000ed04 	.word	0xe000ed04
   83a04:	000860f8 	.word	0x000860f8
   83a08:	00085861 	.word	0x00085861

00083a0c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   83a0c:	b508      	push	{r3, lr}
	configASSERT( uxCriticalNesting );
   83a0e:	4b08      	ldr	r3, [pc, #32]	; (83a30 <vPortExitCritical+0x24>)
   83a10:	681b      	ldr	r3, [r3, #0]
   83a12:	b13b      	cbz	r3, 83a24 <vPortExitCritical+0x18>
	uxCriticalNesting--;
   83a14:	4a06      	ldr	r2, [pc, #24]	; (83a30 <vPortExitCritical+0x24>)
   83a16:	6813      	ldr	r3, [r2, #0]
   83a18:	3b01      	subs	r3, #1
   83a1a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
   83a1c:	b90b      	cbnz	r3, 83a22 <vPortExitCritical+0x16>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
   83a1e:	f383 8811 	msr	BASEPRI, r3
   83a22:	bd08      	pop	{r3, pc}
	configASSERT( uxCriticalNesting );
   83a24:	f240 117d 	movw	r1, #381	; 0x17d
   83a28:	4802      	ldr	r0, [pc, #8]	; (83a34 <vPortExitCritical+0x28>)
   83a2a:	4b03      	ldr	r3, [pc, #12]	; (83a38 <vPortExitCritical+0x2c>)
   83a2c:	4798      	blx	r3
   83a2e:	e7f1      	b.n	83a14 <vPortExitCritical+0x8>
   83a30:	2007028c 	.word	0x2007028c
   83a34:	000860f8 	.word	0x000860f8
   83a38:	00085861 	.word	0x00085861
   83a3c:	00000000 	.word	0x00000000

00083a40 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   83a40:	f3ef 8009 	mrs	r0, PSP
   83a44:	f3bf 8f6f 	isb	sy
   83a48:	4b0d      	ldr	r3, [pc, #52]	; (83a80 <pxCurrentTCBConst>)
   83a4a:	681a      	ldr	r2, [r3, #0]
   83a4c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   83a50:	6010      	str	r0, [r2, #0]
   83a52:	e92d 4008 	stmdb	sp!, {r3, lr}
   83a56:	f04f 00a0 	mov.w	r0, #160	; 0xa0
   83a5a:	f380 8811 	msr	BASEPRI, r0
   83a5e:	f001 f96b 	bl	84d38 <vTaskSwitchContext>
   83a62:	f04f 0000 	mov.w	r0, #0
   83a66:	f380 8811 	msr	BASEPRI, r0
   83a6a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   83a6e:	6819      	ldr	r1, [r3, #0]
   83a70:	6808      	ldr	r0, [r1, #0]
   83a72:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   83a76:	f380 8809 	msr	PSP, r0
   83a7a:	f3bf 8f6f 	isb	sy
   83a7e:	4770      	bx	lr

00083a80 <pxCurrentTCBConst>:
   83a80:	20075210 	.word	0x20075210

00083a84 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
   83a84:	b508      	push	{r3, lr}
	__asm volatile
   83a86:	f04f 03a0 	mov.w	r3, #160	; 0xa0
   83a8a:	f383 8811 	msr	BASEPRI, r3
   83a8e:	f3bf 8f6f 	isb	sy
   83a92:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
   83a96:	4b05      	ldr	r3, [pc, #20]	; (83aac <SysTick_Handler+0x28>)
   83a98:	4798      	blx	r3
   83a9a:	b118      	cbz	r0, 83aa4 <SysTick_Handler+0x20>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   83a9c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   83aa0:	4b03      	ldr	r3, [pc, #12]	; (83ab0 <SysTick_Handler+0x2c>)
   83aa2:	601a      	str	r2, [r3, #0]
	__asm volatile
   83aa4:	2300      	movs	r3, #0
   83aa6:	f383 8811 	msr	BASEPRI, r3
   83aaa:	bd08      	pop	{r3, pc}
   83aac:	00084a89 	.word	0x00084a89
   83ab0:	e000ed04 	.word	0xe000ed04

00083ab4 <vPortSetupTimerInterrupt>:
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
   83ab4:	4b05      	ldr	r3, [pc, #20]	; (83acc <vPortSetupTimerInterrupt+0x18>)
   83ab6:	2200      	movs	r2, #0
   83ab8:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
   83aba:	4905      	ldr	r1, [pc, #20]	; (83ad0 <vPortSetupTimerInterrupt+0x1c>)
   83abc:	600a      	str	r2, [r1, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   83abe:	4905      	ldr	r1, [pc, #20]	; (83ad4 <vPortSetupTimerInterrupt+0x20>)
   83ac0:	4a05      	ldr	r2, [pc, #20]	; (83ad8 <vPortSetupTimerInterrupt+0x24>)
   83ac2:	6011      	str	r1, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   83ac4:	2207      	movs	r2, #7
   83ac6:	601a      	str	r2, [r3, #0]
   83ac8:	4770      	bx	lr
   83aca:	bf00      	nop
   83acc:	e000e010 	.word	0xe000e010
   83ad0:	e000e018 	.word	0xe000e018
   83ad4:	0001481f 	.word	0x0001481f
   83ad8:	e000e014 	.word	0xe000e014

00083adc <xPortStartScheduler>:
{
   83adc:	b510      	push	{r4, lr}
   83ade:	b082      	sub	sp, #8
		ulOriginalPriority = *pucFirstUserPriorityRegister;
   83ae0:	4b2c      	ldr	r3, [pc, #176]	; (83b94 <xPortStartScheduler+0xb8>)
   83ae2:	781a      	ldrb	r2, [r3, #0]
   83ae4:	b2d2      	uxtb	r2, r2
   83ae6:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
   83ae8:	22ff      	movs	r2, #255	; 0xff
   83aea:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
   83aec:	781b      	ldrb	r3, [r3, #0]
   83aee:	b2db      	uxtb	r3, r3
   83af0:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
   83af4:	f89d 3003 	ldrb.w	r3, [sp, #3]
   83af8:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
   83afc:	4a26      	ldr	r2, [pc, #152]	; (83b98 <xPortStartScheduler+0xbc>)
   83afe:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
   83b00:	2207      	movs	r2, #7
   83b02:	4b26      	ldr	r3, [pc, #152]	; (83b9c <xPortStartScheduler+0xc0>)
   83b04:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   83b06:	f89d 3003 	ldrb.w	r3, [sp, #3]
   83b0a:	f013 0f80 	tst.w	r3, #128	; 0x80
   83b0e:	d012      	beq.n	83b36 <xPortStartScheduler+0x5a>
   83b10:	2206      	movs	r2, #6
   83b12:	e000      	b.n	83b16 <xPortStartScheduler+0x3a>
   83b14:	460a      	mov	r2, r1
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
   83b16:	f89d 3003 	ldrb.w	r3, [sp, #3]
   83b1a:	005b      	lsls	r3, r3, #1
   83b1c:	b2db      	uxtb	r3, r3
   83b1e:	f88d 3003 	strb.w	r3, [sp, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   83b22:	f89d 3003 	ldrb.w	r3, [sp, #3]
   83b26:	1e51      	subs	r1, r2, #1
   83b28:	f013 0f80 	tst.w	r3, #128	; 0x80
   83b2c:	d1f2      	bne.n	83b14 <xPortStartScheduler+0x38>
   83b2e:	4b1b      	ldr	r3, [pc, #108]	; (83b9c <xPortStartScheduler+0xc0>)
   83b30:	601a      	str	r2, [r3, #0]
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == __NVIC_PRIO_BITS );
   83b32:	2a03      	cmp	r2, #3
   83b34:	d00d      	beq.n	83b52 <xPortStartScheduler+0x76>
   83b36:	f44f 7197 	mov.w	r1, #302	; 0x12e
   83b3a:	4819      	ldr	r0, [pc, #100]	; (83ba0 <xPortStartScheduler+0xc4>)
   83b3c:	4b19      	ldr	r3, [pc, #100]	; (83ba4 <xPortStartScheduler+0xc8>)
   83b3e:	4798      	blx	r3
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
   83b40:	4b16      	ldr	r3, [pc, #88]	; (83b9c <xPortStartScheduler+0xc0>)
   83b42:	681b      	ldr	r3, [r3, #0]
   83b44:	2b03      	cmp	r3, #3
   83b46:	d004      	beq.n	83b52 <xPortStartScheduler+0x76>
   83b48:	f240 1137 	movw	r1, #311	; 0x137
   83b4c:	4814      	ldr	r0, [pc, #80]	; (83ba0 <xPortStartScheduler+0xc4>)
   83b4e:	4b15      	ldr	r3, [pc, #84]	; (83ba4 <xPortStartScheduler+0xc8>)
   83b50:	4798      	blx	r3
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
   83b52:	4a12      	ldr	r2, [pc, #72]	; (83b9c <xPortStartScheduler+0xc0>)
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
   83b54:	6813      	ldr	r3, [r2, #0]
   83b56:	021b      	lsls	r3, r3, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
   83b58:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
   83b5c:	6013      	str	r3, [r2, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
   83b5e:	9b01      	ldr	r3, [sp, #4]
   83b60:	b2db      	uxtb	r3, r3
   83b62:	4a0c      	ldr	r2, [pc, #48]	; (83b94 <xPortStartScheduler+0xb8>)
   83b64:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   83b66:	4b10      	ldr	r3, [pc, #64]	; (83ba8 <xPortStartScheduler+0xcc>)
   83b68:	681a      	ldr	r2, [r3, #0]
   83b6a:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   83b6e:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   83b70:	681a      	ldr	r2, [r3, #0]
   83b72:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
   83b76:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
   83b78:	4b0c      	ldr	r3, [pc, #48]	; (83bac <xPortStartScheduler+0xd0>)
   83b7a:	4798      	blx	r3
	uxCriticalNesting = 0;
   83b7c:	2400      	movs	r4, #0
   83b7e:	4b0c      	ldr	r3, [pc, #48]	; (83bb0 <xPortStartScheduler+0xd4>)
   83b80:	601c      	str	r4, [r3, #0]
	prvPortStartFirstTask();
   83b82:	4b0c      	ldr	r3, [pc, #48]	; (83bb4 <xPortStartScheduler+0xd8>)
   83b84:	4798      	blx	r3
	vTaskSwitchContext();
   83b86:	4b0c      	ldr	r3, [pc, #48]	; (83bb8 <xPortStartScheduler+0xdc>)
   83b88:	4798      	blx	r3
	prvTaskExitError();
   83b8a:	4b0c      	ldr	r3, [pc, #48]	; (83bbc <xPortStartScheduler+0xe0>)
   83b8c:	4798      	blx	r3
}
   83b8e:	4620      	mov	r0, r4
   83b90:	b002      	add	sp, #8
   83b92:	bd10      	pop	{r4, pc}
   83b94:	e000e400 	.word	0xe000e400
   83b98:	20071200 	.word	0x20071200
   83b9c:	20071204 	.word	0x20071204
   83ba0:	000860f8 	.word	0x000860f8
   83ba4:	00085861 	.word	0x00085861
   83ba8:	e000ed20 	.word	0xe000ed20
   83bac:	00083ab5 	.word	0x00083ab5
   83bb0:	2007028c 	.word	0x2007028c
   83bb4:	00083915 	.word	0x00083915
   83bb8:	00084d39 	.word	0x00084d39
   83bbc:	00083935 	.word	0x00083935

00083bc0 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
   83bc0:	b508      	push	{r3, lr}
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
   83bc2:	f3ef 8305 	mrs	r3, IPSR

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
   83bc6:	2b0f      	cmp	r3, #15
   83bc8:	d906      	bls.n	83bd8 <vPortValidateInterruptPriority+0x18>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
   83bca:	4a0e      	ldr	r2, [pc, #56]	; (83c04 <vPortValidateInterruptPriority+0x44>)
   83bcc:	5c9b      	ldrb	r3, [r3, r2]
   83bce:	b2db      	uxtb	r3, r3
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
   83bd0:	4a0d      	ldr	r2, [pc, #52]	; (83c08 <vPortValidateInterruptPriority+0x48>)
   83bd2:	7812      	ldrb	r2, [r2, #0]
   83bd4:	429a      	cmp	r2, r3
   83bd6:	d808      	bhi.n	83bea <vPortValidateInterruptPriority+0x2a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
   83bd8:	4b0c      	ldr	r3, [pc, #48]	; (83c0c <vPortValidateInterruptPriority+0x4c>)
   83bda:	681b      	ldr	r3, [r3, #0]
   83bdc:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
   83be0:	4a0b      	ldr	r2, [pc, #44]	; (83c10 <vPortValidateInterruptPriority+0x50>)
   83be2:	6812      	ldr	r2, [r2, #0]
   83be4:	4293      	cmp	r3, r2
   83be6:	d806      	bhi.n	83bf6 <vPortValidateInterruptPriority+0x36>
   83be8:	bd08      	pop	{r3, pc}
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
   83bea:	f240 21a6 	movw	r1, #678	; 0x2a6
   83bee:	4809      	ldr	r0, [pc, #36]	; (83c14 <vPortValidateInterruptPriority+0x54>)
   83bf0:	4b09      	ldr	r3, [pc, #36]	; (83c18 <vPortValidateInterruptPriority+0x58>)
   83bf2:	4798      	blx	r3
   83bf4:	e7f0      	b.n	83bd8 <vPortValidateInterruptPriority+0x18>
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
   83bf6:	f240 21b6 	movw	r1, #694	; 0x2b6
   83bfa:	4806      	ldr	r0, [pc, #24]	; (83c14 <vPortValidateInterruptPriority+0x54>)
   83bfc:	4b06      	ldr	r3, [pc, #24]	; (83c18 <vPortValidateInterruptPriority+0x58>)
   83bfe:	4798      	blx	r3
	}
   83c00:	e7f2      	b.n	83be8 <vPortValidateInterruptPriority+0x28>
   83c02:	bf00      	nop
   83c04:	e000e3f0 	.word	0xe000e3f0
   83c08:	20071200 	.word	0x20071200
   83c0c:	e000ed0c 	.word	0xe000ed0c
   83c10:	20071204 	.word	0x20071204
   83c14:	000860f8 	.word	0x000860f8
   83c18:	00085861 	.word	0x00085861

00083c1c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   83c1c:	b538      	push	{r3, r4, r5, lr}
   83c1e:	4604      	mov	r4, r0
static uint8_t *pucAlignedHeap = NULL;

	/* Ensure that blocks are always aligned to the required number of bytes. */
	#if( portBYTE_ALIGNMENT != 1 )
	{
		if( xWantedSize & portBYTE_ALIGNMENT_MASK )
   83c20:	f010 0f07 	tst.w	r0, #7
		{
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   83c24:	bf1c      	itt	ne
   83c26:	f020 0407 	bicne.w	r4, r0, #7
   83c2a:	3408      	addne	r4, #8
		}
	}
	#endif

	vTaskSuspendAll();
   83c2c:	4b11      	ldr	r3, [pc, #68]	; (83c74 <pvPortMalloc+0x58>)
   83c2e:	4798      	blx	r3
	{
		if( pucAlignedHeap == NULL )
   83c30:	4b11      	ldr	r3, [pc, #68]	; (83c78 <pvPortMalloc+0x5c>)
   83c32:	681b      	ldr	r3, [r3, #0]
   83c34:	b193      	cbz	r3, 83c5c <pvPortMalloc+0x40>
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
   83c36:	4b11      	ldr	r3, [pc, #68]	; (83c7c <pvPortMalloc+0x60>)
   83c38:	681b      	ldr	r3, [r3, #0]
   83c3a:	441c      	add	r4, r3
   83c3c:	f643 72f7 	movw	r2, #16375	; 0x3ff7
   83c40:	4294      	cmp	r4, r2
   83c42:	d811      	bhi.n	83c68 <pvPortMalloc+0x4c>
   83c44:	42a3      	cmp	r3, r4
   83c46:	d20f      	bcs.n	83c68 <pvPortMalloc+0x4c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
   83c48:	4a0b      	ldr	r2, [pc, #44]	; (83c78 <pvPortMalloc+0x5c>)
   83c4a:	6815      	ldr	r5, [r2, #0]
   83c4c:	441d      	add	r5, r3
			xNextFreeByte += xWantedSize;
   83c4e:	4b0b      	ldr	r3, [pc, #44]	; (83c7c <pvPortMalloc+0x60>)
   83c50:	601c      	str	r4, [r3, #0]
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   83c52:	4b0b      	ldr	r3, [pc, #44]	; (83c80 <pvPortMalloc+0x64>)
   83c54:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
   83c56:	b14d      	cbz	r5, 83c6c <pvPortMalloc+0x50>
		}
	}
	#endif

	return pvReturn;
}
   83c58:	4628      	mov	r0, r5
   83c5a:	bd38      	pop	{r3, r4, r5, pc}
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
   83c5c:	4b09      	ldr	r3, [pc, #36]	; (83c84 <pvPortMalloc+0x68>)
   83c5e:	f023 0307 	bic.w	r3, r3, #7
   83c62:	4a05      	ldr	r2, [pc, #20]	; (83c78 <pvPortMalloc+0x5c>)
   83c64:	6013      	str	r3, [r2, #0]
   83c66:	e7e6      	b.n	83c36 <pvPortMalloc+0x1a>
	( void ) xTaskResumeAll();
   83c68:	4b05      	ldr	r3, [pc, #20]	; (83c80 <pvPortMalloc+0x64>)
   83c6a:	4798      	blx	r3
			vApplicationMallocFailedHook();
   83c6c:	4b06      	ldr	r3, [pc, #24]	; (83c88 <pvPortMalloc+0x6c>)
   83c6e:	4798      	blx	r3
   83c70:	2500      	movs	r5, #0
	return pvReturn;
   83c72:	e7f1      	b.n	83c58 <pvPortMalloc+0x3c>
   83c74:	00084a59 	.word	0x00084a59
   83c78:	20071208 	.word	0x20071208
   83c7c:	2007520c 	.word	0x2007520c
   83c80:	00084bc5 	.word	0x00084bc5
   83c84:	20071214 	.word	0x20071214
   83c88:	0008583d 	.word	0x0008583d

00083c8c <vPortFree>:
	heap_4.c for alternative implementations, and the memory management pages of
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
   83c8c:	b128      	cbz	r0, 83c9a <vPortFree+0xe>
{
   83c8e:	b508      	push	{r3, lr}
	configASSERT( pv == NULL );
   83c90:	2183      	movs	r1, #131	; 0x83
   83c92:	4802      	ldr	r0, [pc, #8]	; (83c9c <vPortFree+0x10>)
   83c94:	4b02      	ldr	r3, [pc, #8]	; (83ca0 <vPortFree+0x14>)
   83c96:	4798      	blx	r3
   83c98:	bd08      	pop	{r3, pc}
   83c9a:	4770      	bx	lr
   83c9c:	0008614c 	.word	0x0008614c
   83ca0:	00085861 	.word	0x00085861

00083ca4 <prvIsQueueEmpty>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   83ca4:	b510      	push	{r4, lr}
   83ca6:	4604      	mov	r4, r0
BaseType_t xReturn;

	taskENTER_CRITICAL();
   83ca8:	4b04      	ldr	r3, [pc, #16]	; (83cbc <prvIsQueueEmpty+0x18>)
   83caa:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   83cac:	6ba4      	ldr	r4, [r4, #56]	; 0x38
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
   83cae:	4b04      	ldr	r3, [pc, #16]	; (83cc0 <prvIsQueueEmpty+0x1c>)
   83cb0:	4798      	blx	r3

	return xReturn;
}
   83cb2:	fab4 f084 	clz	r0, r4
   83cb6:	0940      	lsrs	r0, r0, #5
   83cb8:	bd10      	pop	{r4, pc}
   83cba:	bf00      	nop
   83cbc:	000839c5 	.word	0x000839c5
   83cc0:	00083a0d 	.word	0x00083a0d

00083cc4 <prvCopyDataToQueue>:
{
   83cc4:	b570      	push	{r4, r5, r6, lr}
   83cc6:	4604      	mov	r4, r0
   83cc8:	4616      	mov	r6, r2
	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   83cca:	6b85      	ldr	r5, [r0, #56]	; 0x38
	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   83ccc:	6c02      	ldr	r2, [r0, #64]	; 0x40
   83cce:	b95a      	cbnz	r2, 83ce8 <prvCopyDataToQueue+0x24>
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   83cd0:	6803      	ldr	r3, [r0, #0]
BaseType_t xReturn = pdFALSE;
   83cd2:	2000      	movs	r0, #0
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   83cd4:	b113      	cbz	r3, 83cdc <prvCopyDataToQueue+0x18>
	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   83cd6:	3501      	adds	r5, #1
   83cd8:	63a5      	str	r5, [r4, #56]	; 0x38
}
   83cda:	bd70      	pop	{r4, r5, r6, pc}
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   83cdc:	6860      	ldr	r0, [r4, #4]
   83cde:	4b17      	ldr	r3, [pc, #92]	; (83d3c <prvCopyDataToQueue+0x78>)
   83ce0:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
   83ce2:	2300      	movs	r3, #0
   83ce4:	6063      	str	r3, [r4, #4]
   83ce6:	e7f6      	b.n	83cd6 <prvCopyDataToQueue+0x12>
	else if( xPosition == queueSEND_TO_BACK )
   83ce8:	b96e      	cbnz	r6, 83d06 <prvCopyDataToQueue+0x42>
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   83cea:	6880      	ldr	r0, [r0, #8]
   83cec:	4b14      	ldr	r3, [pc, #80]	; (83d40 <prvCopyDataToQueue+0x7c>)
   83cee:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   83cf0:	68a3      	ldr	r3, [r4, #8]
   83cf2:	6c22      	ldr	r2, [r4, #64]	; 0x40
   83cf4:	4413      	add	r3, r2
   83cf6:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   83cf8:	6862      	ldr	r2, [r4, #4]
   83cfa:	4293      	cmp	r3, r2
   83cfc:	d319      	bcc.n	83d32 <prvCopyDataToQueue+0x6e>
			pxQueue->pcWriteTo = pxQueue->pcHead;
   83cfe:	6823      	ldr	r3, [r4, #0]
   83d00:	60a3      	str	r3, [r4, #8]
BaseType_t xReturn = pdFALSE;
   83d02:	2000      	movs	r0, #0
   83d04:	e7e7      	b.n	83cd6 <prvCopyDataToQueue+0x12>
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   83d06:	68c0      	ldr	r0, [r0, #12]
   83d08:	4b0d      	ldr	r3, [pc, #52]	; (83d40 <prvCopyDataToQueue+0x7c>)
   83d0a:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   83d0c:	6c22      	ldr	r2, [r4, #64]	; 0x40
   83d0e:	4252      	negs	r2, r2
   83d10:	68e3      	ldr	r3, [r4, #12]
   83d12:	4413      	add	r3, r2
   83d14:	60e3      	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   83d16:	6821      	ldr	r1, [r4, #0]
   83d18:	428b      	cmp	r3, r1
   83d1a:	d202      	bcs.n	83d22 <prvCopyDataToQueue+0x5e>
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   83d1c:	6863      	ldr	r3, [r4, #4]
   83d1e:	441a      	add	r2, r3
   83d20:	60e2      	str	r2, [r4, #12]
		if( xPosition == queueOVERWRITE )
   83d22:	2e02      	cmp	r6, #2
   83d24:	d001      	beq.n	83d2a <prvCopyDataToQueue+0x66>
BaseType_t xReturn = pdFALSE;
   83d26:	2000      	movs	r0, #0
   83d28:	e7d5      	b.n	83cd6 <prvCopyDataToQueue+0x12>
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   83d2a:	b125      	cbz	r5, 83d36 <prvCopyDataToQueue+0x72>
				--uxMessagesWaiting;
   83d2c:	3d01      	subs	r5, #1
BaseType_t xReturn = pdFALSE;
   83d2e:	2000      	movs	r0, #0
   83d30:	e7d1      	b.n	83cd6 <prvCopyDataToQueue+0x12>
   83d32:	2000      	movs	r0, #0
   83d34:	e7cf      	b.n	83cd6 <prvCopyDataToQueue+0x12>
   83d36:	2000      	movs	r0, #0
   83d38:	e7cd      	b.n	83cd6 <prvCopyDataToQueue+0x12>
   83d3a:	bf00      	nop
   83d3c:	00085111 	.word	0x00085111
   83d40:	00085ab1 	.word	0x00085ab1

00083d44 <prvCopyDataFromQueue>:
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   83d44:	6c02      	ldr	r2, [r0, #64]	; 0x40
   83d46:	b172      	cbz	r2, 83d66 <prvCopyDataFromQueue+0x22>
{
   83d48:	b510      	push	{r4, lr}
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   83d4a:	68c3      	ldr	r3, [r0, #12]
   83d4c:	4413      	add	r3, r2
   83d4e:	60c3      	str	r3, [r0, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   83d50:	6844      	ldr	r4, [r0, #4]
   83d52:	42a3      	cmp	r3, r4
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   83d54:	bf24      	itt	cs
   83d56:	6803      	ldrcs	r3, [r0, #0]
   83d58:	60c3      	strcs	r3, [r0, #12]
   83d5a:	460c      	mov	r4, r1
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   83d5c:	68c1      	ldr	r1, [r0, #12]
   83d5e:	4620      	mov	r0, r4
   83d60:	4b01      	ldr	r3, [pc, #4]	; (83d68 <prvCopyDataFromQueue+0x24>)
   83d62:	4798      	blx	r3
   83d64:	bd10      	pop	{r4, pc}
   83d66:	4770      	bx	lr
   83d68:	00085ab1 	.word	0x00085ab1

00083d6c <prvUnlockQueue>:
{
   83d6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   83d70:	4605      	mov	r5, r0
	taskENTER_CRITICAL();
   83d72:	4b20      	ldr	r3, [pc, #128]	; (83df4 <prvUnlockQueue+0x88>)
   83d74:	4798      	blx	r3
		int8_t cTxLock = pxQueue->cTxLock;
   83d76:	f895 4045 	ldrb.w	r4, [r5, #69]	; 0x45
   83d7a:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
   83d7c:	2c00      	cmp	r4, #0
   83d7e:	dd12      	ble.n	83da6 <prvUnlockQueue+0x3a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   83d80:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   83d82:	b183      	cbz	r3, 83da6 <prvUnlockQueue+0x3a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   83d84:	f105 0724 	add.w	r7, r5, #36	; 0x24
   83d88:	4e1b      	ldr	r6, [pc, #108]	; (83df8 <prvUnlockQueue+0x8c>)
						vTaskMissedYield();
   83d8a:	f8df 8074 	ldr.w	r8, [pc, #116]	; 83e00 <prvUnlockQueue+0x94>
   83d8e:	e004      	b.n	83d9a <prvUnlockQueue+0x2e>
   83d90:	3c01      	subs	r4, #1
   83d92:	b264      	sxtb	r4, r4
		while( cTxLock > queueLOCKED_UNMODIFIED )
   83d94:	b13c      	cbz	r4, 83da6 <prvUnlockQueue+0x3a>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   83d96:	6a6b      	ldr	r3, [r5, #36]	; 0x24
   83d98:	b12b      	cbz	r3, 83da6 <prvUnlockQueue+0x3a>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   83d9a:	4638      	mov	r0, r7
   83d9c:	47b0      	blx	r6
   83d9e:	2800      	cmp	r0, #0
   83da0:	d0f6      	beq.n	83d90 <prvUnlockQueue+0x24>
						vTaskMissedYield();
   83da2:	47c0      	blx	r8
   83da4:	e7f4      	b.n	83d90 <prvUnlockQueue+0x24>
		pxQueue->cTxLock = queueUNLOCKED;
   83da6:	23ff      	movs	r3, #255	; 0xff
   83da8:	f885 3045 	strb.w	r3, [r5, #69]	; 0x45
	taskEXIT_CRITICAL();
   83dac:	4b13      	ldr	r3, [pc, #76]	; (83dfc <prvUnlockQueue+0x90>)
   83dae:	4798      	blx	r3
	taskENTER_CRITICAL();
   83db0:	4b10      	ldr	r3, [pc, #64]	; (83df4 <prvUnlockQueue+0x88>)
   83db2:	4798      	blx	r3
		int8_t cRxLock = pxQueue->cRxLock;
   83db4:	f895 4044 	ldrb.w	r4, [r5, #68]	; 0x44
   83db8:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
   83dba:	2c00      	cmp	r4, #0
   83dbc:	dd12      	ble.n	83de4 <prvUnlockQueue+0x78>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   83dbe:	692b      	ldr	r3, [r5, #16]
   83dc0:	b183      	cbz	r3, 83de4 <prvUnlockQueue+0x78>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   83dc2:	f105 0710 	add.w	r7, r5, #16
   83dc6:	4e0c      	ldr	r6, [pc, #48]	; (83df8 <prvUnlockQueue+0x8c>)
					vTaskMissedYield();
   83dc8:	f8df 8034 	ldr.w	r8, [pc, #52]	; 83e00 <prvUnlockQueue+0x94>
   83dcc:	e004      	b.n	83dd8 <prvUnlockQueue+0x6c>
   83dce:	3c01      	subs	r4, #1
   83dd0:	b264      	sxtb	r4, r4
		while( cRxLock > queueLOCKED_UNMODIFIED )
   83dd2:	b13c      	cbz	r4, 83de4 <prvUnlockQueue+0x78>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   83dd4:	692b      	ldr	r3, [r5, #16]
   83dd6:	b12b      	cbz	r3, 83de4 <prvUnlockQueue+0x78>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   83dd8:	4638      	mov	r0, r7
   83dda:	47b0      	blx	r6
   83ddc:	2800      	cmp	r0, #0
   83dde:	d0f6      	beq.n	83dce <prvUnlockQueue+0x62>
					vTaskMissedYield();
   83de0:	47c0      	blx	r8
   83de2:	e7f4      	b.n	83dce <prvUnlockQueue+0x62>
		pxQueue->cRxLock = queueUNLOCKED;
   83de4:	23ff      	movs	r3, #255	; 0xff
   83de6:	f885 3044 	strb.w	r3, [r5, #68]	; 0x44
	taskEXIT_CRITICAL();
   83dea:	4b04      	ldr	r3, [pc, #16]	; (83dfc <prvUnlockQueue+0x90>)
   83dec:	4798      	blx	r3
   83dee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   83df2:	bf00      	nop
   83df4:	000839c5 	.word	0x000839c5
   83df8:	00084eb1 	.word	0x00084eb1
   83dfc:	00083a0d 	.word	0x00083a0d
   83e00:	00085025 	.word	0x00085025

00083e04 <xQueueGenericReset>:
{
   83e04:	b538      	push	{r3, r4, r5, lr}
   83e06:	460d      	mov	r5, r1
	configASSERT( pxQueue );
   83e08:	4604      	mov	r4, r0
   83e0a:	b1d0      	cbz	r0, 83e42 <xQueueGenericReset+0x3e>
	taskENTER_CRITICAL();
   83e0c:	4b1b      	ldr	r3, [pc, #108]	; (83e7c <xQueueGenericReset+0x78>)
   83e0e:	4798      	blx	r3
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   83e10:	6822      	ldr	r2, [r4, #0]
   83e12:	6c21      	ldr	r1, [r4, #64]	; 0x40
   83e14:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   83e16:	fb03 f301 	mul.w	r3, r3, r1
   83e1a:	18d0      	adds	r0, r2, r3
   83e1c:	6060      	str	r0, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   83e1e:	2000      	movs	r0, #0
   83e20:	63a0      	str	r0, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   83e22:	60a2      	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   83e24:	1a5b      	subs	r3, r3, r1
   83e26:	4413      	add	r3, r2
   83e28:	60e3      	str	r3, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
   83e2a:	23ff      	movs	r3, #255	; 0xff
   83e2c:	f884 3044 	strb.w	r3, [r4, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
   83e30:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
		if( xNewQueue == pdFALSE )
   83e34:	b9cd      	cbnz	r5, 83e6a <xQueueGenericReset+0x66>
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   83e36:	6923      	ldr	r3, [r4, #16]
   83e38:	b943      	cbnz	r3, 83e4c <xQueueGenericReset+0x48>
	taskEXIT_CRITICAL();
   83e3a:	4b11      	ldr	r3, [pc, #68]	; (83e80 <xQueueGenericReset+0x7c>)
   83e3c:	4798      	blx	r3
}
   83e3e:	2001      	movs	r0, #1
   83e40:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxQueue );
   83e42:	21fc      	movs	r1, #252	; 0xfc
   83e44:	480f      	ldr	r0, [pc, #60]	; (83e84 <xQueueGenericReset+0x80>)
   83e46:	4b10      	ldr	r3, [pc, #64]	; (83e88 <xQueueGenericReset+0x84>)
   83e48:	4798      	blx	r3
   83e4a:	e7df      	b.n	83e0c <xQueueGenericReset+0x8>
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   83e4c:	f104 0010 	add.w	r0, r4, #16
   83e50:	4b0e      	ldr	r3, [pc, #56]	; (83e8c <xQueueGenericReset+0x88>)
   83e52:	4798      	blx	r3
   83e54:	2800      	cmp	r0, #0
   83e56:	d0f0      	beq.n	83e3a <xQueueGenericReset+0x36>
					queueYIELD_IF_USING_PREEMPTION();
   83e58:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   83e5c:	4b0c      	ldr	r3, [pc, #48]	; (83e90 <xQueueGenericReset+0x8c>)
   83e5e:	601a      	str	r2, [r3, #0]
   83e60:	f3bf 8f4f 	dsb	sy
   83e64:	f3bf 8f6f 	isb	sy
   83e68:	e7e7      	b.n	83e3a <xQueueGenericReset+0x36>
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   83e6a:	f104 0010 	add.w	r0, r4, #16
   83e6e:	4d09      	ldr	r5, [pc, #36]	; (83e94 <xQueueGenericReset+0x90>)
   83e70:	47a8      	blx	r5
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   83e72:	f104 0024 	add.w	r0, r4, #36	; 0x24
   83e76:	47a8      	blx	r5
   83e78:	e7df      	b.n	83e3a <xQueueGenericReset+0x36>
   83e7a:	bf00      	nop
   83e7c:	000839c5 	.word	0x000839c5
   83e80:	00083a0d 	.word	0x00083a0d
   83e84:	0008619c 	.word	0x0008619c
   83e88:	00085861 	.word	0x00085861
   83e8c:	00084eb1 	.word	0x00084eb1
   83e90:	e000ed04 	.word	0xe000ed04
   83e94:	00083885 	.word	0x00083885

00083e98 <xQueueGenericCreate>:
	{
   83e98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   83e9a:	460d      	mov	r5, r1
   83e9c:	4617      	mov	r7, r2
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   83e9e:	4606      	mov	r6, r0
   83ea0:	b1a0      	cbz	r0, 83ecc <xQueueGenericCreate+0x34>
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   83ea2:	fb05 f006 	mul.w	r0, r5, r6
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   83ea6:	3050      	adds	r0, #80	; 0x50
   83ea8:	4b0c      	ldr	r3, [pc, #48]	; (83edc <xQueueGenericCreate+0x44>)
   83eaa:	4798      	blx	r3
		if( pxNewQueue != NULL )
   83eac:	4604      	mov	r4, r0
   83eae:	b158      	cbz	r0, 83ec8 <xQueueGenericCreate+0x30>
	if( uxItemSize == ( UBaseType_t ) 0 )
   83eb0:	b195      	cbz	r5, 83ed8 <xQueueGenericCreate+0x40>
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
   83eb2:	f100 0350 	add.w	r3, r0, #80	; 0x50
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
   83eb6:	6003      	str	r3, [r0, #0]
	pxNewQueue->uxLength = uxQueueLength;
   83eb8:	63e6      	str	r6, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
   83eba:	6425      	str	r5, [r4, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   83ebc:	2101      	movs	r1, #1
   83ebe:	4620      	mov	r0, r4
   83ec0:	4b07      	ldr	r3, [pc, #28]	; (83ee0 <xQueueGenericCreate+0x48>)
   83ec2:	4798      	blx	r3
		pxNewQueue->ucQueueType = ucQueueType;
   83ec4:	f884 704c 	strb.w	r7, [r4, #76]	; 0x4c
	}
   83ec8:	4620      	mov	r0, r4
   83eca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   83ecc:	f240 116d 	movw	r1, #365	; 0x16d
   83ed0:	4804      	ldr	r0, [pc, #16]	; (83ee4 <xQueueGenericCreate+0x4c>)
   83ed2:	4b05      	ldr	r3, [pc, #20]	; (83ee8 <xQueueGenericCreate+0x50>)
   83ed4:	4798      	blx	r3
   83ed6:	e7e4      	b.n	83ea2 <xQueueGenericCreate+0xa>
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   83ed8:	6020      	str	r0, [r4, #0]
   83eda:	e7ed      	b.n	83eb8 <xQueueGenericCreate+0x20>
   83edc:	00083c1d 	.word	0x00083c1d
   83ee0:	00083e05 	.word	0x00083e05
   83ee4:	0008619c 	.word	0x0008619c
   83ee8:	00085861 	.word	0x00085861

00083eec <xQueueCreateCountingSemaphore>:
	{
   83eec:	b538      	push	{r3, r4, r5, lr}
   83eee:	460d      	mov	r5, r1
		configASSERT( uxMaxCount != 0 );
   83ef0:	4604      	mov	r4, r0
   83ef2:	b158      	cbz	r0, 83f0c <xQueueCreateCountingSemaphore+0x20>
		configASSERT( uxInitialCount <= uxMaxCount );
   83ef4:	42ac      	cmp	r4, r5
   83ef6:	d30f      	bcc.n	83f18 <xQueueCreateCountingSemaphore+0x2c>
		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
   83ef8:	2202      	movs	r2, #2
   83efa:	2100      	movs	r1, #0
   83efc:	4620      	mov	r0, r4
   83efe:	4b09      	ldr	r3, [pc, #36]	; (83f24 <xQueueCreateCountingSemaphore+0x38>)
   83f00:	4798      	blx	r3
		if( xHandle != NULL )
   83f02:	4603      	mov	r3, r0
   83f04:	b100      	cbz	r0, 83f08 <xQueueCreateCountingSemaphore+0x1c>
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
   83f06:	6385      	str	r5, [r0, #56]	; 0x38
	}
   83f08:	4618      	mov	r0, r3
   83f0a:	bd38      	pop	{r3, r4, r5, pc}
		configASSERT( uxMaxCount != 0 );
   83f0c:	f44f 7130 	mov.w	r1, #704	; 0x2c0
   83f10:	4805      	ldr	r0, [pc, #20]	; (83f28 <xQueueCreateCountingSemaphore+0x3c>)
   83f12:	4b06      	ldr	r3, [pc, #24]	; (83f2c <xQueueCreateCountingSemaphore+0x40>)
   83f14:	4798      	blx	r3
   83f16:	e7ed      	b.n	83ef4 <xQueueCreateCountingSemaphore+0x8>
		configASSERT( uxInitialCount <= uxMaxCount );
   83f18:	f240 21c1 	movw	r1, #705	; 0x2c1
   83f1c:	4802      	ldr	r0, [pc, #8]	; (83f28 <xQueueCreateCountingSemaphore+0x3c>)
   83f1e:	4b03      	ldr	r3, [pc, #12]	; (83f2c <xQueueCreateCountingSemaphore+0x40>)
   83f20:	4798      	blx	r3
   83f22:	e7e9      	b.n	83ef8 <xQueueCreateCountingSemaphore+0xc>
   83f24:	00083e99 	.word	0x00083e99
   83f28:	0008619c 	.word	0x0008619c
   83f2c:	00085861 	.word	0x00085861

00083f30 <xQueueGenericSend>:
{
   83f30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   83f34:	b085      	sub	sp, #20
   83f36:	4689      	mov	r9, r1
   83f38:	9201      	str	r2, [sp, #4]
   83f3a:	461e      	mov	r6, r3
	configASSERT( pxQueue );
   83f3c:	4604      	mov	r4, r0
   83f3e:	b1a8      	cbz	r0, 83f6c <xQueueGenericSend+0x3c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   83f40:	f1b9 0f00 	cmp.w	r9, #0
   83f44:	d018      	beq.n	83f78 <xQueueGenericSend+0x48>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   83f46:	2e02      	cmp	r6, #2
   83f48:	d01f      	beq.n	83f8a <xQueueGenericSend+0x5a>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   83f4a:	4b56      	ldr	r3, [pc, #344]	; (840a4 <xQueueGenericSend+0x174>)
   83f4c:	4798      	blx	r3
   83f4e:	b930      	cbnz	r0, 83f5e <xQueueGenericSend+0x2e>
   83f50:	9b01      	ldr	r3, [sp, #4]
   83f52:	b123      	cbz	r3, 83f5e <xQueueGenericSend+0x2e>
   83f54:	f240 21e1 	movw	r1, #737	; 0x2e1
   83f58:	4853      	ldr	r0, [pc, #332]	; (840a8 <xQueueGenericSend+0x178>)
   83f5a:	4b54      	ldr	r3, [pc, #336]	; (840ac <xQueueGenericSend+0x17c>)
   83f5c:	4798      	blx	r3
{
   83f5e:	f04f 0a00 	mov.w	sl, #0
		taskENTER_CRITICAL();
   83f62:	4d53      	ldr	r5, [pc, #332]	; (840b0 <xQueueGenericSend+0x180>)
					vTaskInternalSetTimeOutState( &xTimeOut );
   83f64:	4f53      	ldr	r7, [pc, #332]	; (840b4 <xQueueGenericSend+0x184>)
					portYIELD_WITHIN_API();
   83f66:	f8df 8154 	ldr.w	r8, [pc, #340]	; 840bc <xQueueGenericSend+0x18c>
   83f6a:	e04a      	b.n	84002 <xQueueGenericSend+0xd2>
	configASSERT( pxQueue );
   83f6c:	f44f 7137 	mov.w	r1, #732	; 0x2dc
   83f70:	484d      	ldr	r0, [pc, #308]	; (840a8 <xQueueGenericSend+0x178>)
   83f72:	4b4e      	ldr	r3, [pc, #312]	; (840ac <xQueueGenericSend+0x17c>)
   83f74:	4798      	blx	r3
   83f76:	e7e3      	b.n	83f40 <xQueueGenericSend+0x10>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   83f78:	6c23      	ldr	r3, [r4, #64]	; 0x40
   83f7a:	2b00      	cmp	r3, #0
   83f7c:	d0e3      	beq.n	83f46 <xQueueGenericSend+0x16>
   83f7e:	f240 21dd 	movw	r1, #733	; 0x2dd
   83f82:	4849      	ldr	r0, [pc, #292]	; (840a8 <xQueueGenericSend+0x178>)
   83f84:	4b49      	ldr	r3, [pc, #292]	; (840ac <xQueueGenericSend+0x17c>)
   83f86:	4798      	blx	r3
   83f88:	e7dd      	b.n	83f46 <xQueueGenericSend+0x16>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   83f8a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   83f8c:	2b01      	cmp	r3, #1
   83f8e:	d0dc      	beq.n	83f4a <xQueueGenericSend+0x1a>
   83f90:	f240 21de 	movw	r1, #734	; 0x2de
   83f94:	4844      	ldr	r0, [pc, #272]	; (840a8 <xQueueGenericSend+0x178>)
   83f96:	4b45      	ldr	r3, [pc, #276]	; (840ac <xQueueGenericSend+0x17c>)
   83f98:	4798      	blx	r3
   83f9a:	e7d6      	b.n	83f4a <xQueueGenericSend+0x1a>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   83f9c:	4632      	mov	r2, r6
   83f9e:	4649      	mov	r1, r9
   83fa0:	4620      	mov	r0, r4
   83fa2:	4b45      	ldr	r3, [pc, #276]	; (840b8 <xQueueGenericSend+0x188>)
   83fa4:	4798      	blx	r3
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   83fa6:	6a63      	ldr	r3, [r4, #36]	; 0x24
   83fa8:	b973      	cbnz	r3, 83fc8 <xQueueGenericSend+0x98>
					else if( xYieldRequired != pdFALSE )
   83faa:	b138      	cbz	r0, 83fbc <xQueueGenericSend+0x8c>
						queueYIELD_IF_USING_PREEMPTION();
   83fac:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   83fb0:	4b42      	ldr	r3, [pc, #264]	; (840bc <xQueueGenericSend+0x18c>)
   83fb2:	601a      	str	r2, [r3, #0]
   83fb4:	f3bf 8f4f 	dsb	sy
   83fb8:	f3bf 8f6f 	isb	sy
				taskEXIT_CRITICAL();
   83fbc:	4b40      	ldr	r3, [pc, #256]	; (840c0 <xQueueGenericSend+0x190>)
   83fbe:	4798      	blx	r3
				return pdPASS;
   83fc0:	2001      	movs	r0, #1
}
   83fc2:	b005      	add	sp, #20
   83fc4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   83fc8:	f104 0024 	add.w	r0, r4, #36	; 0x24
   83fcc:	4b3d      	ldr	r3, [pc, #244]	; (840c4 <xQueueGenericSend+0x194>)
   83fce:	4798      	blx	r3
   83fd0:	2800      	cmp	r0, #0
   83fd2:	d0f3      	beq.n	83fbc <xQueueGenericSend+0x8c>
							queueYIELD_IF_USING_PREEMPTION();
   83fd4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   83fd8:	4b38      	ldr	r3, [pc, #224]	; (840bc <xQueueGenericSend+0x18c>)
   83fda:	601a      	str	r2, [r3, #0]
   83fdc:	f3bf 8f4f 	dsb	sy
   83fe0:	f3bf 8f6f 	isb	sy
   83fe4:	e7ea      	b.n	83fbc <xQueueGenericSend+0x8c>
					taskEXIT_CRITICAL();
   83fe6:	4b36      	ldr	r3, [pc, #216]	; (840c0 <xQueueGenericSend+0x190>)
   83fe8:	4798      	blx	r3
					return errQUEUE_FULL;
   83fea:	2000      	movs	r0, #0
   83fec:	e7e9      	b.n	83fc2 <xQueueGenericSend+0x92>
					vTaskInternalSetTimeOutState( &xTimeOut );
   83fee:	a802      	add	r0, sp, #8
   83ff0:	47b8      	blx	r7
   83ff2:	e013      	b.n	8401c <xQueueGenericSend+0xec>
				prvUnlockQueue( pxQueue );
   83ff4:	4620      	mov	r0, r4
   83ff6:	4b34      	ldr	r3, [pc, #208]	; (840c8 <xQueueGenericSend+0x198>)
   83ff8:	4798      	blx	r3
				( void ) xTaskResumeAll();
   83ffa:	4b34      	ldr	r3, [pc, #208]	; (840cc <xQueueGenericSend+0x19c>)
   83ffc:	4798      	blx	r3
   83ffe:	f04f 0a01 	mov.w	sl, #1
		taskENTER_CRITICAL();
   84002:	47a8      	blx	r5
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   84004:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   84006:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   84008:	429a      	cmp	r2, r3
   8400a:	d3c7      	bcc.n	83f9c <xQueueGenericSend+0x6c>
   8400c:	2e02      	cmp	r6, #2
   8400e:	d0c5      	beq.n	83f9c <xQueueGenericSend+0x6c>
				if( xTicksToWait == ( TickType_t ) 0 )
   84010:	9b01      	ldr	r3, [sp, #4]
   84012:	2b00      	cmp	r3, #0
   84014:	d0e7      	beq.n	83fe6 <xQueueGenericSend+0xb6>
				else if( xEntryTimeSet == pdFALSE )
   84016:	f1ba 0f00 	cmp.w	sl, #0
   8401a:	d0e8      	beq.n	83fee <xQueueGenericSend+0xbe>
		taskEXIT_CRITICAL();
   8401c:	4b28      	ldr	r3, [pc, #160]	; (840c0 <xQueueGenericSend+0x190>)
   8401e:	4798      	blx	r3
		vTaskSuspendAll();
   84020:	4b2b      	ldr	r3, [pc, #172]	; (840d0 <xQueueGenericSend+0x1a0>)
   84022:	4798      	blx	r3
		prvLockQueue( pxQueue );
   84024:	47a8      	blx	r5
   84026:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   8402a:	b25b      	sxtb	r3, r3
   8402c:	f1b3 3fff 	cmp.w	r3, #4294967295
   84030:	bf04      	itt	eq
   84032:	2300      	moveq	r3, #0
   84034:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
   84038:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   8403c:	b25b      	sxtb	r3, r3
   8403e:	f1b3 3fff 	cmp.w	r3, #4294967295
   84042:	bf04      	itt	eq
   84044:	2300      	moveq	r3, #0
   84046:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
   8404a:	4b1d      	ldr	r3, [pc, #116]	; (840c0 <xQueueGenericSend+0x190>)
   8404c:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   8404e:	a901      	add	r1, sp, #4
   84050:	a802      	add	r0, sp, #8
   84052:	4b20      	ldr	r3, [pc, #128]	; (840d4 <xQueueGenericSend+0x1a4>)
   84054:	4798      	blx	r3
   84056:	b9e8      	cbnz	r0, 84094 <xQueueGenericSend+0x164>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
   84058:	47a8      	blx	r5
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   8405a:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
   8405e:	f8d4 a03c 	ldr.w	sl, [r4, #60]	; 0x3c
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
   84062:	4b17      	ldr	r3, [pc, #92]	; (840c0 <xQueueGenericSend+0x190>)
   84064:	4798      	blx	r3
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   84066:	45d3      	cmp	fp, sl
   84068:	d1c4      	bne.n	83ff4 <xQueueGenericSend+0xc4>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   8406a:	9901      	ldr	r1, [sp, #4]
   8406c:	f104 0010 	add.w	r0, r4, #16
   84070:	4b19      	ldr	r3, [pc, #100]	; (840d8 <xQueueGenericSend+0x1a8>)
   84072:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   84074:	4620      	mov	r0, r4
   84076:	4b14      	ldr	r3, [pc, #80]	; (840c8 <xQueueGenericSend+0x198>)
   84078:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   8407a:	4b14      	ldr	r3, [pc, #80]	; (840cc <xQueueGenericSend+0x19c>)
   8407c:	4798      	blx	r3
   8407e:	2800      	cmp	r0, #0
   84080:	d1bd      	bne.n	83ffe <xQueueGenericSend+0xce>
					portYIELD_WITHIN_API();
   84082:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   84086:	f8c8 3000 	str.w	r3, [r8]
   8408a:	f3bf 8f4f 	dsb	sy
   8408e:	f3bf 8f6f 	isb	sy
   84092:	e7b4      	b.n	83ffe <xQueueGenericSend+0xce>
			prvUnlockQueue( pxQueue );
   84094:	4620      	mov	r0, r4
   84096:	4b0c      	ldr	r3, [pc, #48]	; (840c8 <xQueueGenericSend+0x198>)
   84098:	4798      	blx	r3
			( void ) xTaskResumeAll();
   8409a:	4b0c      	ldr	r3, [pc, #48]	; (840cc <xQueueGenericSend+0x19c>)
   8409c:	4798      	blx	r3
			return errQUEUE_FULL;
   8409e:	2000      	movs	r0, #0
   840a0:	e78f      	b.n	83fc2 <xQueueGenericSend+0x92>
   840a2:	bf00      	nop
   840a4:	00085031 	.word	0x00085031
   840a8:	0008619c 	.word	0x0008619c
   840ac:	00085861 	.word	0x00085861
   840b0:	000839c5 	.word	0x000839c5
   840b4:	00084f85 	.word	0x00084f85
   840b8:	00083cc5 	.word	0x00083cc5
   840bc:	e000ed04 	.word	0xe000ed04
   840c0:	00083a0d 	.word	0x00083a0d
   840c4:	00084eb1 	.word	0x00084eb1
   840c8:	00083d6d 	.word	0x00083d6d
   840cc:	00084bc5 	.word	0x00084bc5
   840d0:	00084a59 	.word	0x00084a59
   840d4:	00084f9d 	.word	0x00084f9d
   840d8:	00084e29 	.word	0x00084e29

000840dc <xQueueCreateMutex>:
	{
   840dc:	b538      	push	{r3, r4, r5, lr}
		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
   840de:	4602      	mov	r2, r0
   840e0:	2100      	movs	r1, #0
   840e2:	2001      	movs	r0, #1
   840e4:	4b06      	ldr	r3, [pc, #24]	; (84100 <xQueueCreateMutex+0x24>)
   840e6:	4798      	blx	r3
		if( pxNewQueue != NULL )
   840e8:	4604      	mov	r4, r0
   840ea:	b138      	cbz	r0, 840fc <xQueueCreateMutex+0x20>
			pxNewQueue->pxMutexHolder = NULL;
   840ec:	2100      	movs	r1, #0
   840ee:	6041      	str	r1, [r0, #4]
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
   840f0:	6001      	str	r1, [r0, #0]
			pxNewQueue->u.uxRecursiveCallCount = 0;
   840f2:	60c1      	str	r1, [r0, #12]
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
   840f4:	460b      	mov	r3, r1
   840f6:	460a      	mov	r2, r1
   840f8:	4d02      	ldr	r5, [pc, #8]	; (84104 <xQueueCreateMutex+0x28>)
   840fa:	47a8      	blx	r5
	}
   840fc:	4620      	mov	r0, r4
   840fe:	bd38      	pop	{r3, r4, r5, pc}
   84100:	00083e99 	.word	0x00083e99
   84104:	00083f31 	.word	0x00083f31

00084108 <xQueueGenericSendFromISR>:
{
   84108:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   8410c:	460f      	mov	r7, r1
   8410e:	4691      	mov	r9, r2
   84110:	461e      	mov	r6, r3
	configASSERT( pxQueue );
   84112:	4604      	mov	r4, r0
   84114:	b1c8      	cbz	r0, 8414a <xQueueGenericSendFromISR+0x42>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   84116:	b1f7      	cbz	r7, 84156 <xQueueGenericSendFromISR+0x4e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   84118:	2e02      	cmp	r6, #2
   8411a:	d025      	beq.n	84168 <xQueueGenericSendFromISR+0x60>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   8411c:	4b29      	ldr	r3, [pc, #164]	; (841c4 <xQueueGenericSendFromISR+0xbc>)
   8411e:	4798      	blx	r3
	__asm volatile
   84120:	f3ef 8811 	mrs	r8, BASEPRI
   84124:	f04f 03a0 	mov.w	r3, #160	; 0xa0
   84128:	f383 8811 	msr	BASEPRI, r3
   8412c:	f3bf 8f6f 	isb	sy
   84130:	f3bf 8f4f 	dsb	sy
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   84134:	6ba2      	ldr	r2, [r4, #56]	; 0x38
   84136:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   84138:	429a      	cmp	r2, r3
   8413a:	d31e      	bcc.n	8417a <xQueueGenericSendFromISR+0x72>
   8413c:	2e02      	cmp	r6, #2
   8413e:	d01c      	beq.n	8417a <xQueueGenericSendFromISR+0x72>
			xReturn = errQUEUE_FULL;
   84140:	2000      	movs	r0, #0
	__asm volatile
   84142:	f388 8811 	msr	BASEPRI, r8
}
   84146:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	configASSERT( pxQueue );
   8414a:	f240 31a2 	movw	r1, #930	; 0x3a2
   8414e:	481e      	ldr	r0, [pc, #120]	; (841c8 <xQueueGenericSendFromISR+0xc0>)
   84150:	4b1e      	ldr	r3, [pc, #120]	; (841cc <xQueueGenericSendFromISR+0xc4>)
   84152:	4798      	blx	r3
   84154:	e7df      	b.n	84116 <xQueueGenericSendFromISR+0xe>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   84156:	6c23      	ldr	r3, [r4, #64]	; 0x40
   84158:	2b00      	cmp	r3, #0
   8415a:	d0dd      	beq.n	84118 <xQueueGenericSendFromISR+0x10>
   8415c:	f240 31a3 	movw	r1, #931	; 0x3a3
   84160:	4819      	ldr	r0, [pc, #100]	; (841c8 <xQueueGenericSendFromISR+0xc0>)
   84162:	4b1a      	ldr	r3, [pc, #104]	; (841cc <xQueueGenericSendFromISR+0xc4>)
   84164:	4798      	blx	r3
   84166:	e7d7      	b.n	84118 <xQueueGenericSendFromISR+0x10>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   84168:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   8416a:	2b01      	cmp	r3, #1
   8416c:	d0d6      	beq.n	8411c <xQueueGenericSendFromISR+0x14>
   8416e:	f44f 7169 	mov.w	r1, #932	; 0x3a4
   84172:	4815      	ldr	r0, [pc, #84]	; (841c8 <xQueueGenericSendFromISR+0xc0>)
   84174:	4b15      	ldr	r3, [pc, #84]	; (841cc <xQueueGenericSendFromISR+0xc4>)
   84176:	4798      	blx	r3
   84178:	e7d0      	b.n	8411c <xQueueGenericSendFromISR+0x14>
			const int8_t cTxLock = pxQueue->cTxLock;
   8417a:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
   8417e:	b26d      	sxtb	r5, r5
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   84180:	4632      	mov	r2, r6
   84182:	4639      	mov	r1, r7
   84184:	4620      	mov	r0, r4
   84186:	4b12      	ldr	r3, [pc, #72]	; (841d0 <xQueueGenericSendFromISR+0xc8>)
   84188:	4798      	blx	r3
			if( cTxLock == queueUNLOCKED )
   8418a:	f1b5 3fff 	cmp.w	r5, #4294967295
   8418e:	d005      	beq.n	8419c <xQueueGenericSendFromISR+0x94>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   84190:	3501      	adds	r5, #1
   84192:	b26d      	sxtb	r5, r5
   84194:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
			xReturn = pdPASS;
   84198:	2001      	movs	r0, #1
   8419a:	e7d2      	b.n	84142 <xQueueGenericSendFromISR+0x3a>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   8419c:	6a63      	ldr	r3, [r4, #36]	; 0x24
   8419e:	b90b      	cbnz	r3, 841a4 <xQueueGenericSendFromISR+0x9c>
			xReturn = pdPASS;
   841a0:	2001      	movs	r0, #1
   841a2:	e7ce      	b.n	84142 <xQueueGenericSendFromISR+0x3a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   841a4:	f104 0024 	add.w	r0, r4, #36	; 0x24
   841a8:	4b0a      	ldr	r3, [pc, #40]	; (841d4 <xQueueGenericSendFromISR+0xcc>)
   841aa:	4798      	blx	r3
   841ac:	b130      	cbz	r0, 841bc <xQueueGenericSendFromISR+0xb4>
							if( pxHigherPriorityTaskWoken != NULL )
   841ae:	f1b9 0f00 	cmp.w	r9, #0
   841b2:	d005      	beq.n	841c0 <xQueueGenericSendFromISR+0xb8>
								*pxHigherPriorityTaskWoken = pdTRUE;
   841b4:	2001      	movs	r0, #1
   841b6:	f8c9 0000 	str.w	r0, [r9]
   841ba:	e7c2      	b.n	84142 <xQueueGenericSendFromISR+0x3a>
			xReturn = pdPASS;
   841bc:	2001      	movs	r0, #1
   841be:	e7c0      	b.n	84142 <xQueueGenericSendFromISR+0x3a>
   841c0:	2001      	movs	r0, #1
   841c2:	e7be      	b.n	84142 <xQueueGenericSendFromISR+0x3a>
   841c4:	00083bc1 	.word	0x00083bc1
   841c8:	0008619c 	.word	0x0008619c
   841cc:	00085861 	.word	0x00085861
   841d0:	00083cc5 	.word	0x00083cc5
   841d4:	00084eb1 	.word	0x00084eb1

000841d8 <xQueueGiveFromISR>:
{
   841d8:	b570      	push	{r4, r5, r6, lr}
   841da:	460e      	mov	r6, r1
	configASSERT( pxQueue );
   841dc:	4604      	mov	r4, r0
   841de:	b318      	cbz	r0, 84228 <xQueueGiveFromISR+0x50>
	configASSERT( pxQueue->uxItemSize == 0 );
   841e0:	6c23      	ldr	r3, [r4, #64]	; 0x40
   841e2:	bb3b      	cbnz	r3, 84234 <xQueueGiveFromISR+0x5c>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
   841e4:	6823      	ldr	r3, [r4, #0]
   841e6:	b35b      	cbz	r3, 84240 <xQueueGiveFromISR+0x68>
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   841e8:	4b23      	ldr	r3, [pc, #140]	; (84278 <xQueueGiveFromISR+0xa0>)
   841ea:	4798      	blx	r3
	__asm volatile
   841ec:	f3ef 8511 	mrs	r5, BASEPRI
   841f0:	f04f 03a0 	mov.w	r3, #160	; 0xa0
   841f4:	f383 8811 	msr	BASEPRI, r3
   841f8:	f3bf 8f6f 	isb	sy
   841fc:	f3bf 8f4f 	dsb	sy
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   84200:	6ba2      	ldr	r2, [r4, #56]	; 0x38
		if( uxMessagesWaiting < pxQueue->uxLength )
   84202:	6be3      	ldr	r3, [r4, #60]	; 0x3c
   84204:	429a      	cmp	r2, r3
   84206:	d231      	bcs.n	8426c <xQueueGiveFromISR+0x94>
			const int8_t cTxLock = pxQueue->cTxLock;
   84208:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   8420c:	b25b      	sxtb	r3, r3
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
   8420e:	3201      	adds	r2, #1
   84210:	63a2      	str	r2, [r4, #56]	; 0x38
			if( cTxLock == queueUNLOCKED )
   84212:	f1b3 3fff 	cmp.w	r3, #4294967295
   84216:	d01c      	beq.n	84252 <xQueueGiveFromISR+0x7a>
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
   84218:	3301      	adds	r3, #1
   8421a:	b25b      	sxtb	r3, r3
   8421c:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
			xReturn = pdPASS;
   84220:	2001      	movs	r0, #1
	__asm volatile
   84222:	f385 8811 	msr	BASEPRI, r5
}
   84226:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxQueue );
   84228:	f240 413f 	movw	r1, #1087	; 0x43f
   8422c:	4813      	ldr	r0, [pc, #76]	; (8427c <xQueueGiveFromISR+0xa4>)
   8422e:	4b14      	ldr	r3, [pc, #80]	; (84280 <xQueueGiveFromISR+0xa8>)
   84230:	4798      	blx	r3
   84232:	e7d5      	b.n	841e0 <xQueueGiveFromISR+0x8>
	configASSERT( pxQueue->uxItemSize == 0 );
   84234:	f240 4143 	movw	r1, #1091	; 0x443
   84238:	4810      	ldr	r0, [pc, #64]	; (8427c <xQueueGiveFromISR+0xa4>)
   8423a:	4b11      	ldr	r3, [pc, #68]	; (84280 <xQueueGiveFromISR+0xa8>)
   8423c:	4798      	blx	r3
   8423e:	e7d1      	b.n	841e4 <xQueueGiveFromISR+0xc>
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
   84240:	6863      	ldr	r3, [r4, #4]
   84242:	2b00      	cmp	r3, #0
   84244:	d0d0      	beq.n	841e8 <xQueueGiveFromISR+0x10>
   84246:	f44f 6189 	mov.w	r1, #1096	; 0x448
   8424a:	480c      	ldr	r0, [pc, #48]	; (8427c <xQueueGiveFromISR+0xa4>)
   8424c:	4b0c      	ldr	r3, [pc, #48]	; (84280 <xQueueGiveFromISR+0xa8>)
   8424e:	4798      	blx	r3
   84250:	e7ca      	b.n	841e8 <xQueueGiveFromISR+0x10>
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   84252:	6a63      	ldr	r3, [r4, #36]	; 0x24
   84254:	b90b      	cbnz	r3, 8425a <xQueueGiveFromISR+0x82>
			xReturn = pdPASS;
   84256:	2001      	movs	r0, #1
   84258:	e7e3      	b.n	84222 <xQueueGiveFromISR+0x4a>
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   8425a:	f104 0024 	add.w	r0, r4, #36	; 0x24
   8425e:	4b09      	ldr	r3, [pc, #36]	; (84284 <xQueueGiveFromISR+0xac>)
   84260:	4798      	blx	r3
   84262:	b128      	cbz	r0, 84270 <xQueueGiveFromISR+0x98>
							if( pxHigherPriorityTaskWoken != NULL )
   84264:	b136      	cbz	r6, 84274 <xQueueGiveFromISR+0x9c>
								*pxHigherPriorityTaskWoken = pdTRUE;
   84266:	2001      	movs	r0, #1
   84268:	6030      	str	r0, [r6, #0]
   8426a:	e7da      	b.n	84222 <xQueueGiveFromISR+0x4a>
			xReturn = errQUEUE_FULL;
   8426c:	2000      	movs	r0, #0
   8426e:	e7d8      	b.n	84222 <xQueueGiveFromISR+0x4a>
			xReturn = pdPASS;
   84270:	2001      	movs	r0, #1
   84272:	e7d6      	b.n	84222 <xQueueGiveFromISR+0x4a>
   84274:	2001      	movs	r0, #1
   84276:	e7d4      	b.n	84222 <xQueueGiveFromISR+0x4a>
   84278:	00083bc1 	.word	0x00083bc1
   8427c:	0008619c 	.word	0x0008619c
   84280:	00085861 	.word	0x00085861
   84284:	00084eb1 	.word	0x00084eb1

00084288 <xQueueReceive>:
{
   84288:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   8428c:	b084      	sub	sp, #16
   8428e:	4688      	mov	r8, r1
   84290:	9201      	str	r2, [sp, #4]
	configASSERT( ( pxQueue ) );
   84292:	4604      	mov	r4, r0
   84294:	b198      	cbz	r0, 842be <xQueueReceive+0x36>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   84296:	f1b8 0f00 	cmp.w	r8, #0
   8429a:	d016      	beq.n	842ca <xQueueReceive+0x42>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   8429c:	4b4d      	ldr	r3, [pc, #308]	; (843d4 <xQueueReceive+0x14c>)
   8429e:	4798      	blx	r3
   842a0:	b930      	cbnz	r0, 842b0 <xQueueReceive+0x28>
   842a2:	9b01      	ldr	r3, [sp, #4]
   842a4:	b123      	cbz	r3, 842b0 <xQueueReceive+0x28>
   842a6:	f44f 619d 	mov.w	r1, #1256	; 0x4e8
   842aa:	484b      	ldr	r0, [pc, #300]	; (843d8 <xQueueReceive+0x150>)
   842ac:	4b4b      	ldr	r3, [pc, #300]	; (843dc <xQueueReceive+0x154>)
   842ae:	4798      	blx	r3
{
   842b0:	f04f 0a00 	mov.w	sl, #0
		taskENTER_CRITICAL();
   842b4:	4d4a      	ldr	r5, [pc, #296]	; (843e0 <xQueueReceive+0x158>)
					vTaskInternalSetTimeOutState( &xTimeOut );
   842b6:	4e4b      	ldr	r6, [pc, #300]	; (843e4 <xQueueReceive+0x15c>)
					portYIELD_WITHIN_API();
   842b8:	f8df 9138 	ldr.w	r9, [pc, #312]	; 843f4 <xQueueReceive+0x16c>
   842bc:	e044      	b.n	84348 <xQueueReceive+0xc0>
	configASSERT( ( pxQueue ) );
   842be:	f240 41df 	movw	r1, #1247	; 0x4df
   842c2:	4845      	ldr	r0, [pc, #276]	; (843d8 <xQueueReceive+0x150>)
   842c4:	4b45      	ldr	r3, [pc, #276]	; (843dc <xQueueReceive+0x154>)
   842c6:	4798      	blx	r3
   842c8:	e7e5      	b.n	84296 <xQueueReceive+0xe>
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
   842ca:	6c23      	ldr	r3, [r4, #64]	; 0x40
   842cc:	2b00      	cmp	r3, #0
   842ce:	d0e5      	beq.n	8429c <xQueueReceive+0x14>
   842d0:	f240 41e3 	movw	r1, #1251	; 0x4e3
   842d4:	4840      	ldr	r0, [pc, #256]	; (843d8 <xQueueReceive+0x150>)
   842d6:	4b41      	ldr	r3, [pc, #260]	; (843dc <xQueueReceive+0x154>)
   842d8:	4798      	blx	r3
   842da:	e7df      	b.n	8429c <xQueueReceive+0x14>
				prvCopyDataFromQueue( pxQueue, pvBuffer );
   842dc:	4641      	mov	r1, r8
   842de:	4620      	mov	r0, r4
   842e0:	4b41      	ldr	r3, [pc, #260]	; (843e8 <xQueueReceive+0x160>)
   842e2:	4798      	blx	r3
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
   842e4:	1e7b      	subs	r3, r7, #1
   842e6:	63a3      	str	r3, [r4, #56]	; 0x38
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   842e8:	6923      	ldr	r3, [r4, #16]
   842ea:	b92b      	cbnz	r3, 842f8 <xQueueReceive+0x70>
				taskEXIT_CRITICAL();
   842ec:	4b3f      	ldr	r3, [pc, #252]	; (843ec <xQueueReceive+0x164>)
   842ee:	4798      	blx	r3
				return pdPASS;
   842f0:	2001      	movs	r0, #1
}
   842f2:	b004      	add	sp, #16
   842f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   842f8:	f104 0010 	add.w	r0, r4, #16
   842fc:	4b3c      	ldr	r3, [pc, #240]	; (843f0 <xQueueReceive+0x168>)
   842fe:	4798      	blx	r3
   84300:	2800      	cmp	r0, #0
   84302:	d0f3      	beq.n	842ec <xQueueReceive+0x64>
						queueYIELD_IF_USING_PREEMPTION();
   84304:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   84308:	4b3a      	ldr	r3, [pc, #232]	; (843f4 <xQueueReceive+0x16c>)
   8430a:	601a      	str	r2, [r3, #0]
   8430c:	f3bf 8f4f 	dsb	sy
   84310:	f3bf 8f6f 	isb	sy
   84314:	e7ea      	b.n	842ec <xQueueReceive+0x64>
					taskEXIT_CRITICAL();
   84316:	4b35      	ldr	r3, [pc, #212]	; (843ec <xQueueReceive+0x164>)
   84318:	4798      	blx	r3
					return errQUEUE_EMPTY;
   8431a:	2000      	movs	r0, #0
   8431c:	e7e9      	b.n	842f2 <xQueueReceive+0x6a>
					vTaskInternalSetTimeOutState( &xTimeOut );
   8431e:	a802      	add	r0, sp, #8
   84320:	47b0      	blx	r6
   84322:	e01b      	b.n	8435c <xQueueReceive+0xd4>
				prvUnlockQueue( pxQueue );
   84324:	4620      	mov	r0, r4
   84326:	4b34      	ldr	r3, [pc, #208]	; (843f8 <xQueueReceive+0x170>)
   84328:	4798      	blx	r3
				( void ) xTaskResumeAll();
   8432a:	4b34      	ldr	r3, [pc, #208]	; (843fc <xQueueReceive+0x174>)
   8432c:	4798      	blx	r3
   8432e:	e009      	b.n	84344 <xQueueReceive+0xbc>
			prvUnlockQueue( pxQueue );
   84330:	4620      	mov	r0, r4
   84332:	4b31      	ldr	r3, [pc, #196]	; (843f8 <xQueueReceive+0x170>)
   84334:	4798      	blx	r3
			( void ) xTaskResumeAll();
   84336:	4b31      	ldr	r3, [pc, #196]	; (843fc <xQueueReceive+0x174>)
   84338:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   8433a:	4620      	mov	r0, r4
   8433c:	4b30      	ldr	r3, [pc, #192]	; (84400 <xQueueReceive+0x178>)
   8433e:	4798      	blx	r3
   84340:	2800      	cmp	r0, #0
   84342:	d144      	bne.n	843ce <xQueueReceive+0x146>
   84344:	f04f 0a01 	mov.w	sl, #1
		taskENTER_CRITICAL();
   84348:	47a8      	blx	r5
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
   8434a:	6ba7      	ldr	r7, [r4, #56]	; 0x38
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
   8434c:	2f00      	cmp	r7, #0
   8434e:	d1c5      	bne.n	842dc <xQueueReceive+0x54>
				if( xTicksToWait == ( TickType_t ) 0 )
   84350:	9b01      	ldr	r3, [sp, #4]
   84352:	2b00      	cmp	r3, #0
   84354:	d0df      	beq.n	84316 <xQueueReceive+0x8e>
				else if( xEntryTimeSet == pdFALSE )
   84356:	f1ba 0f00 	cmp.w	sl, #0
   8435a:	d0e0      	beq.n	8431e <xQueueReceive+0x96>
		taskEXIT_CRITICAL();
   8435c:	4b23      	ldr	r3, [pc, #140]	; (843ec <xQueueReceive+0x164>)
   8435e:	4798      	blx	r3
		vTaskSuspendAll();
   84360:	4b28      	ldr	r3, [pc, #160]	; (84404 <xQueueReceive+0x17c>)
   84362:	4798      	blx	r3
		prvLockQueue( pxQueue );
   84364:	47a8      	blx	r5
   84366:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   8436a:	b25b      	sxtb	r3, r3
   8436c:	f1b3 3fff 	cmp.w	r3, #4294967295
   84370:	bf04      	itt	eq
   84372:	2300      	moveq	r3, #0
   84374:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
   84378:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   8437c:	b25b      	sxtb	r3, r3
   8437e:	f1b3 3fff 	cmp.w	r3, #4294967295
   84382:	bf04      	itt	eq
   84384:	2300      	moveq	r3, #0
   84386:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
   8438a:	4b18      	ldr	r3, [pc, #96]	; (843ec <xQueueReceive+0x164>)
   8438c:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   8438e:	a901      	add	r1, sp, #4
   84390:	a802      	add	r0, sp, #8
   84392:	4b1d      	ldr	r3, [pc, #116]	; (84408 <xQueueReceive+0x180>)
   84394:	4798      	blx	r3
   84396:	2800      	cmp	r0, #0
   84398:	d1ca      	bne.n	84330 <xQueueReceive+0xa8>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   8439a:	4620      	mov	r0, r4
   8439c:	4b18      	ldr	r3, [pc, #96]	; (84400 <xQueueReceive+0x178>)
   8439e:	4798      	blx	r3
   843a0:	2800      	cmp	r0, #0
   843a2:	d0bf      	beq.n	84324 <xQueueReceive+0x9c>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   843a4:	9901      	ldr	r1, [sp, #4]
   843a6:	f104 0024 	add.w	r0, r4, #36	; 0x24
   843aa:	4b18      	ldr	r3, [pc, #96]	; (8440c <xQueueReceive+0x184>)
   843ac:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   843ae:	4620      	mov	r0, r4
   843b0:	4b11      	ldr	r3, [pc, #68]	; (843f8 <xQueueReceive+0x170>)
   843b2:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   843b4:	4b11      	ldr	r3, [pc, #68]	; (843fc <xQueueReceive+0x174>)
   843b6:	4798      	blx	r3
   843b8:	2800      	cmp	r0, #0
   843ba:	d1c3      	bne.n	84344 <xQueueReceive+0xbc>
					portYIELD_WITHIN_API();
   843bc:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   843c0:	f8c9 3000 	str.w	r3, [r9]
   843c4:	f3bf 8f4f 	dsb	sy
   843c8:	f3bf 8f6f 	isb	sy
   843cc:	e7ba      	b.n	84344 <xQueueReceive+0xbc>
				return errQUEUE_EMPTY;
   843ce:	2000      	movs	r0, #0
   843d0:	e78f      	b.n	842f2 <xQueueReceive+0x6a>
   843d2:	bf00      	nop
   843d4:	00085031 	.word	0x00085031
   843d8:	0008619c 	.word	0x0008619c
   843dc:	00085861 	.word	0x00085861
   843e0:	000839c5 	.word	0x000839c5
   843e4:	00084f85 	.word	0x00084f85
   843e8:	00083d45 	.word	0x00083d45
   843ec:	00083a0d 	.word	0x00083a0d
   843f0:	00084eb1 	.word	0x00084eb1
   843f4:	e000ed04 	.word	0xe000ed04
   843f8:	00083d6d 	.word	0x00083d6d
   843fc:	00084bc5 	.word	0x00084bc5
   84400:	00083ca5 	.word	0x00083ca5
   84404:	00084a59 	.word	0x00084a59
   84408:	00084f9d 	.word	0x00084f9d
   8440c:	00084e29 	.word	0x00084e29

00084410 <xQueueSemaphoreTake>:
{
   84410:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
   84414:	b085      	sub	sp, #20
   84416:	9101      	str	r1, [sp, #4]
	configASSERT( ( pxQueue ) );
   84418:	4604      	mov	r4, r0
   8441a:	b198      	cbz	r0, 84444 <xQueueSemaphoreTake+0x34>
	configASSERT( pxQueue->uxItemSize == 0 );
   8441c:	6c23      	ldr	r3, [r4, #64]	; 0x40
   8441e:	b9bb      	cbnz	r3, 84450 <xQueueSemaphoreTake+0x40>
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   84420:	4b61      	ldr	r3, [pc, #388]	; (845a8 <xQueueSemaphoreTake+0x198>)
   84422:	4798      	blx	r3
   84424:	b930      	cbnz	r0, 84434 <xQueueSemaphoreTake+0x24>
   84426:	9b01      	ldr	r3, [sp, #4]
   84428:	b123      	cbz	r3, 84434 <xQueueSemaphoreTake+0x24>
   8442a:	f240 517a 	movw	r1, #1402	; 0x57a
   8442e:	485f      	ldr	r0, [pc, #380]	; (845ac <xQueueSemaphoreTake+0x19c>)
   84430:	4b5f      	ldr	r3, [pc, #380]	; (845b0 <xQueueSemaphoreTake+0x1a0>)
   84432:	4798      	blx	r3
{
   84434:	f04f 0900 	mov.w	r9, #0
   84438:	464e      	mov	r6, r9
		taskENTER_CRITICAL();
   8443a:	4d5e      	ldr	r5, [pc, #376]	; (845b4 <xQueueSemaphoreTake+0x1a4>)
					vTaskInternalSetTimeOutState( &xTimeOut );
   8443c:	4f5e      	ldr	r7, [pc, #376]	; (845b8 <xQueueSemaphoreTake+0x1a8>)
					portYIELD_WITHIN_API();
   8443e:	f8df 8188 	ldr.w	r8, [pc, #392]	; 845c8 <xQueueSemaphoreTake+0x1b8>
   84442:	e056      	b.n	844f2 <xQueueSemaphoreTake+0xe2>
	configASSERT( ( pxQueue ) );
   84444:	f240 5171 	movw	r1, #1393	; 0x571
   84448:	4858      	ldr	r0, [pc, #352]	; (845ac <xQueueSemaphoreTake+0x19c>)
   8444a:	4b59      	ldr	r3, [pc, #356]	; (845b0 <xQueueSemaphoreTake+0x1a0>)
   8444c:	4798      	blx	r3
   8444e:	e7e5      	b.n	8441c <xQueueSemaphoreTake+0xc>
	configASSERT( pxQueue->uxItemSize == 0 );
   84450:	f240 5175 	movw	r1, #1397	; 0x575
   84454:	4855      	ldr	r0, [pc, #340]	; (845ac <xQueueSemaphoreTake+0x19c>)
   84456:	4b56      	ldr	r3, [pc, #344]	; (845b0 <xQueueSemaphoreTake+0x1a0>)
   84458:	4798      	blx	r3
   8445a:	e7e1      	b.n	84420 <xQueueSemaphoreTake+0x10>
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
   8445c:	3b01      	subs	r3, #1
   8445e:	63a3      	str	r3, [r4, #56]	; 0x38
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   84460:	6823      	ldr	r3, [r4, #0]
   84462:	b14b      	cbz	r3, 84478 <xQueueSemaphoreTake+0x68>
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   84464:	6923      	ldr	r3, [r4, #16]
   84466:	b95b      	cbnz	r3, 84480 <xQueueSemaphoreTake+0x70>
				taskEXIT_CRITICAL();
   84468:	4b54      	ldr	r3, [pc, #336]	; (845bc <xQueueSemaphoreTake+0x1ac>)
   8446a:	4798      	blx	r3
				return pdPASS;
   8446c:	f04f 0901 	mov.w	r9, #1
}
   84470:	4648      	mov	r0, r9
   84472:	b005      	add	sp, #20
   84474:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
   84478:	4b51      	ldr	r3, [pc, #324]	; (845c0 <xQueueSemaphoreTake+0x1b0>)
   8447a:	4798      	blx	r3
   8447c:	6060      	str	r0, [r4, #4]
   8447e:	e7f1      	b.n	84464 <xQueueSemaphoreTake+0x54>
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   84480:	f104 0010 	add.w	r0, r4, #16
   84484:	4b4f      	ldr	r3, [pc, #316]	; (845c4 <xQueueSemaphoreTake+0x1b4>)
   84486:	4798      	blx	r3
   84488:	2800      	cmp	r0, #0
   8448a:	d0ed      	beq.n	84468 <xQueueSemaphoreTake+0x58>
						queueYIELD_IF_USING_PREEMPTION();
   8448c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   84490:	4b4d      	ldr	r3, [pc, #308]	; (845c8 <xQueueSemaphoreTake+0x1b8>)
   84492:	601a      	str	r2, [r3, #0]
   84494:	f3bf 8f4f 	dsb	sy
   84498:	f3bf 8f6f 	isb	sy
   8449c:	e7e4      	b.n	84468 <xQueueSemaphoreTake+0x58>
						configASSERT( xInheritanceOccurred == pdFALSE );
   8449e:	f1b9 0f00 	cmp.w	r9, #0
   844a2:	d104      	bne.n	844ae <xQueueSemaphoreTake+0x9e>
					taskEXIT_CRITICAL();
   844a4:	4b45      	ldr	r3, [pc, #276]	; (845bc <xQueueSemaphoreTake+0x1ac>)
   844a6:	4798      	blx	r3
					return errQUEUE_EMPTY;
   844a8:	f04f 0900 	mov.w	r9, #0
   844ac:	e7e0      	b.n	84470 <xQueueSemaphoreTake+0x60>
						configASSERT( xInheritanceOccurred == pdFALSE );
   844ae:	f240 51c2 	movw	r1, #1474	; 0x5c2
   844b2:	483e      	ldr	r0, [pc, #248]	; (845ac <xQueueSemaphoreTake+0x19c>)
   844b4:	4b3e      	ldr	r3, [pc, #248]	; (845b0 <xQueueSemaphoreTake+0x1a0>)
   844b6:	4798      	blx	r3
   844b8:	e7f4      	b.n	844a4 <xQueueSemaphoreTake+0x94>
					vTaskInternalSetTimeOutState( &xTimeOut );
   844ba:	a802      	add	r0, sp, #8
   844bc:	47b8      	blx	r7
   844be:	e021      	b.n	84504 <xQueueSemaphoreTake+0xf4>
						taskENTER_CRITICAL();
   844c0:	47a8      	blx	r5
							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   844c2:	6860      	ldr	r0, [r4, #4]
   844c4:	4b41      	ldr	r3, [pc, #260]	; (845cc <xQueueSemaphoreTake+0x1bc>)
   844c6:	4798      	blx	r3
   844c8:	4681      	mov	r9, r0
						taskEXIT_CRITICAL();
   844ca:	4b3c      	ldr	r3, [pc, #240]	; (845bc <xQueueSemaphoreTake+0x1ac>)
   844cc:	4798      	blx	r3
   844ce:	e040      	b.n	84552 <xQueueSemaphoreTake+0x142>
				prvUnlockQueue( pxQueue );
   844d0:	4620      	mov	r0, r4
   844d2:	4b3f      	ldr	r3, [pc, #252]	; (845d0 <xQueueSemaphoreTake+0x1c0>)
   844d4:	4798      	blx	r3
				( void ) xTaskResumeAll();
   844d6:	4b3f      	ldr	r3, [pc, #252]	; (845d4 <xQueueSemaphoreTake+0x1c4>)
   844d8:	4798      	blx	r3
   844da:	e009      	b.n	844f0 <xQueueSemaphoreTake+0xe0>
			prvUnlockQueue( pxQueue );
   844dc:	4620      	mov	r0, r4
   844de:	4b3c      	ldr	r3, [pc, #240]	; (845d0 <xQueueSemaphoreTake+0x1c0>)
   844e0:	4798      	blx	r3
			( void ) xTaskResumeAll();
   844e2:	4b3c      	ldr	r3, [pc, #240]	; (845d4 <xQueueSemaphoreTake+0x1c4>)
   844e4:	4798      	blx	r3
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   844e6:	4620      	mov	r0, r4
   844e8:	4b3b      	ldr	r3, [pc, #236]	; (845d8 <xQueueSemaphoreTake+0x1c8>)
   844ea:	4798      	blx	r3
   844ec:	2800      	cmp	r0, #0
   844ee:	d145      	bne.n	8457c <xQueueSemaphoreTake+0x16c>
   844f0:	2601      	movs	r6, #1
		taskENTER_CRITICAL();
   844f2:	47a8      	blx	r5
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
   844f4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
   844f6:	2b00      	cmp	r3, #0
   844f8:	d1b0      	bne.n	8445c <xQueueSemaphoreTake+0x4c>
				if( xTicksToWait == ( TickType_t ) 0 )
   844fa:	9b01      	ldr	r3, [sp, #4]
   844fc:	2b00      	cmp	r3, #0
   844fe:	d0ce      	beq.n	8449e <xQueueSemaphoreTake+0x8e>
				else if( xEntryTimeSet == pdFALSE )
   84500:	2e00      	cmp	r6, #0
   84502:	d0da      	beq.n	844ba <xQueueSemaphoreTake+0xaa>
		taskEXIT_CRITICAL();
   84504:	4b2d      	ldr	r3, [pc, #180]	; (845bc <xQueueSemaphoreTake+0x1ac>)
   84506:	4798      	blx	r3
		vTaskSuspendAll();
   84508:	4b34      	ldr	r3, [pc, #208]	; (845dc <xQueueSemaphoreTake+0x1cc>)
   8450a:	4798      	blx	r3
		prvLockQueue( pxQueue );
   8450c:	47a8      	blx	r5
   8450e:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   84512:	b25b      	sxtb	r3, r3
   84514:	f1b3 3fff 	cmp.w	r3, #4294967295
   84518:	bf04      	itt	eq
   8451a:	2300      	moveq	r3, #0
   8451c:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
   84520:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   84524:	b25b      	sxtb	r3, r3
   84526:	f1b3 3fff 	cmp.w	r3, #4294967295
   8452a:	bf04      	itt	eq
   8452c:	2300      	moveq	r3, #0
   8452e:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
   84532:	4b22      	ldr	r3, [pc, #136]	; (845bc <xQueueSemaphoreTake+0x1ac>)
   84534:	4798      	blx	r3
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   84536:	a901      	add	r1, sp, #4
   84538:	a802      	add	r0, sp, #8
   8453a:	4b29      	ldr	r3, [pc, #164]	; (845e0 <xQueueSemaphoreTake+0x1d0>)
   8453c:	4798      	blx	r3
   8453e:	2800      	cmp	r0, #0
   84540:	d1cc      	bne.n	844dc <xQueueSemaphoreTake+0xcc>
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   84542:	4620      	mov	r0, r4
   84544:	4b24      	ldr	r3, [pc, #144]	; (845d8 <xQueueSemaphoreTake+0x1c8>)
   84546:	4798      	blx	r3
   84548:	2800      	cmp	r0, #0
   8454a:	d0c1      	beq.n	844d0 <xQueueSemaphoreTake+0xc0>
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   8454c:	6823      	ldr	r3, [r4, #0]
   8454e:	2b00      	cmp	r3, #0
   84550:	d0b6      	beq.n	844c0 <xQueueSemaphoreTake+0xb0>
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   84552:	9901      	ldr	r1, [sp, #4]
   84554:	f104 0024 	add.w	r0, r4, #36	; 0x24
   84558:	4b22      	ldr	r3, [pc, #136]	; (845e4 <xQueueSemaphoreTake+0x1d4>)
   8455a:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   8455c:	4620      	mov	r0, r4
   8455e:	4b1c      	ldr	r3, [pc, #112]	; (845d0 <xQueueSemaphoreTake+0x1c0>)
   84560:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   84562:	4b1c      	ldr	r3, [pc, #112]	; (845d4 <xQueueSemaphoreTake+0x1c4>)
   84564:	4798      	blx	r3
   84566:	2800      	cmp	r0, #0
   84568:	d1c2      	bne.n	844f0 <xQueueSemaphoreTake+0xe0>
					portYIELD_WITHIN_API();
   8456a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   8456e:	f8c8 3000 	str.w	r3, [r8]
   84572:	f3bf 8f4f 	dsb	sy
   84576:	f3bf 8f6f 	isb	sy
   8457a:	e7b9      	b.n	844f0 <xQueueSemaphoreTake+0xe0>
					if( xInheritanceOccurred != pdFALSE )
   8457c:	f1b9 0f00 	cmp.w	r9, #0
   84580:	f43f af76 	beq.w	84470 <xQueueSemaphoreTake+0x60>
						taskENTER_CRITICAL();
   84584:	4b0b      	ldr	r3, [pc, #44]	; (845b4 <xQueueSemaphoreTake+0x1a4>)
   84586:	4798      	blx	r3
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
   84588:	6a63      	ldr	r3, [r4, #36]	; 0x24
   8458a:	b15b      	cbz	r3, 845a4 <xQueueSemaphoreTake+0x194>
			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
   8458c:	6b23      	ldr	r3, [r4, #48]	; 0x30
   8458e:	6819      	ldr	r1, [r3, #0]
   84590:	f1c1 0105 	rsb	r1, r1, #5
							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
   84594:	6860      	ldr	r0, [r4, #4]
   84596:	4b14      	ldr	r3, [pc, #80]	; (845e8 <xQueueSemaphoreTake+0x1d8>)
   84598:	4798      	blx	r3
						taskEXIT_CRITICAL();
   8459a:	4b08      	ldr	r3, [pc, #32]	; (845bc <xQueueSemaphoreTake+0x1ac>)
   8459c:	4798      	blx	r3
				return errQUEUE_EMPTY;
   8459e:	f04f 0900 	mov.w	r9, #0
   845a2:	e765      	b.n	84470 <xQueueSemaphoreTake+0x60>
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
   845a4:	2100      	movs	r1, #0
   845a6:	e7f5      	b.n	84594 <xQueueSemaphoreTake+0x184>
   845a8:	00085031 	.word	0x00085031
   845ac:	0008619c 	.word	0x0008619c
   845b0:	00085861 	.word	0x00085861
   845b4:	000839c5 	.word	0x000839c5
   845b8:	00084f85 	.word	0x00084f85
   845bc:	00083a0d 	.word	0x00083a0d
   845c0:	00085295 	.word	0x00085295
   845c4:	00084eb1 	.word	0x00084eb1
   845c8:	e000ed04 	.word	0xe000ed04
   845cc:	00085051 	.word	0x00085051
   845d0:	00083d6d 	.word	0x00083d6d
   845d4:	00084bc5 	.word	0x00084bc5
   845d8:	00083ca5 	.word	0x00083ca5
   845dc:	00084a59 	.word	0x00084a59
   845e0:	00084f9d 	.word	0x00084f9d
   845e4:	00084e29 	.word	0x00084e29
   845e8:	000851c9 	.word	0x000851c9

000845ec <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
   845ec:	b410      	push	{r4}

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
   845ee:	4b0a      	ldr	r3, [pc, #40]	; (84618 <vQueueAddToRegistry+0x2c>)
   845f0:	681b      	ldr	r3, [r3, #0]
   845f2:	b14b      	cbz	r3, 84608 <vQueueAddToRegistry+0x1c>
   845f4:	2301      	movs	r3, #1
   845f6:	4c08      	ldr	r4, [pc, #32]	; (84618 <vQueueAddToRegistry+0x2c>)
   845f8:	f854 2033 	ldr.w	r2, [r4, r3, lsl #3]
   845fc:	b12a      	cbz	r2, 8460a <vQueueAddToRegistry+0x1e>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   845fe:	3301      	adds	r3, #1
   84600:	2b08      	cmp	r3, #8
   84602:	d1f9      	bne.n	845f8 <vQueueAddToRegistry+0xc>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
   84604:	bc10      	pop	{r4}
   84606:	4770      	bx	lr
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   84608:	2300      	movs	r3, #0
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
   8460a:	4a03      	ldr	r2, [pc, #12]	; (84618 <vQueueAddToRegistry+0x2c>)
   8460c:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
   84610:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   84614:	6058      	str	r0, [r3, #4]
				break;
   84616:	e7f5      	b.n	84604 <vQueueAddToRegistry+0x18>
   84618:	2007537c 	.word	0x2007537c

0008461c <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
   8461c:	b570      	push	{r4, r5, r6, lr}
   8461e:	4604      	mov	r4, r0
   84620:	460d      	mov	r5, r1
   84622:	4616      	mov	r6, r2
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
   84624:	4b11      	ldr	r3, [pc, #68]	; (8466c <vQueueWaitForMessageRestricted+0x50>)
   84626:	4798      	blx	r3
   84628:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
   8462c:	b25b      	sxtb	r3, r3
   8462e:	f1b3 3fff 	cmp.w	r3, #4294967295
   84632:	bf04      	itt	eq
   84634:	2300      	moveq	r3, #0
   84636:	f884 3044 	strbeq.w	r3, [r4, #68]	; 0x44
   8463a:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
   8463e:	b25b      	sxtb	r3, r3
   84640:	f1b3 3fff 	cmp.w	r3, #4294967295
   84644:	bf04      	itt	eq
   84646:	2300      	moveq	r3, #0
   84648:	f884 3045 	strbeq.w	r3, [r4, #69]	; 0x45
   8464c:	4b08      	ldr	r3, [pc, #32]	; (84670 <vQueueWaitForMessageRestricted+0x54>)
   8464e:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   84650:	6ba3      	ldr	r3, [r4, #56]	; 0x38
   84652:	b11b      	cbz	r3, 8465c <vQueueWaitForMessageRestricted+0x40>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
   84654:	4620      	mov	r0, r4
   84656:	4b07      	ldr	r3, [pc, #28]	; (84674 <vQueueWaitForMessageRestricted+0x58>)
   84658:	4798      	blx	r3
   8465a:	bd70      	pop	{r4, r5, r6, pc}
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
   8465c:	4632      	mov	r2, r6
   8465e:	4629      	mov	r1, r5
   84660:	f104 0024 	add.w	r0, r4, #36	; 0x24
   84664:	4b04      	ldr	r3, [pc, #16]	; (84678 <vQueueWaitForMessageRestricted+0x5c>)
   84666:	4798      	blx	r3
   84668:	e7f4      	b.n	84654 <vQueueWaitForMessageRestricted+0x38>
   8466a:	bf00      	nop
   8466c:	000839c5 	.word	0x000839c5
   84670:	00083a0d 	.word	0x00083a0d
   84674:	00083d6d 	.word	0x00083d6d
   84678:	00084e69 	.word	0x00084e69

0008467c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   8467c:	4b08      	ldr	r3, [pc, #32]	; (846a0 <prvResetNextTaskUnblockTime+0x24>)
   8467e:	681b      	ldr	r3, [r3, #0]
   84680:	681b      	ldr	r3, [r3, #0]
   84682:	b13b      	cbz	r3, 84694 <prvResetNextTaskUnblockTime+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   84684:	4b06      	ldr	r3, [pc, #24]	; (846a0 <prvResetNextTaskUnblockTime+0x24>)
   84686:	681b      	ldr	r3, [r3, #0]
   84688:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
   8468a:	68db      	ldr	r3, [r3, #12]
   8468c:	685a      	ldr	r2, [r3, #4]
   8468e:	4b05      	ldr	r3, [pc, #20]	; (846a4 <prvResetNextTaskUnblockTime+0x28>)
   84690:	601a      	str	r2, [r3, #0]
   84692:	4770      	bx	lr
		xNextTaskUnblockTime = portMAX_DELAY;
   84694:	f04f 32ff 	mov.w	r2, #4294967295
   84698:	4b02      	ldr	r3, [pc, #8]	; (846a4 <prvResetNextTaskUnblockTime+0x28>)
   8469a:	601a      	str	r2, [r3, #0]
   8469c:	4770      	bx	lr
   8469e:	bf00      	nop
   846a0:	20075214 	.word	0x20075214
   846a4:	200752c8 	.word	0x200752c8

000846a8 <prvIdleTask>:
{
   846a8:	b580      	push	{r7, lr}
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   846aa:	4d16      	ldr	r5, [pc, #88]	; (84704 <prvIdleTask+0x5c>)
			taskENTER_CRITICAL();
   846ac:	f8df 806c 	ldr.w	r8, [pc, #108]	; 8471c <prvIdleTask+0x74>
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   846b0:	4f15      	ldr	r7, [pc, #84]	; (84708 <prvIdleTask+0x60>)
				taskYIELD();
   846b2:	f8df 906c 	ldr.w	r9, [pc, #108]	; 84720 <prvIdleTask+0x78>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   846b6:	682b      	ldr	r3, [r5, #0]
   846b8:	b1bb      	cbz	r3, 846ea <prvIdleTask+0x42>
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   846ba:	4e14      	ldr	r6, [pc, #80]	; (8470c <prvIdleTask+0x64>)
			taskENTER_CRITICAL();
   846bc:	47c0      	blx	r8
				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   846be:	68fb      	ldr	r3, [r7, #12]
   846c0:	68dc      	ldr	r4, [r3, #12]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   846c2:	1d20      	adds	r0, r4, #4
   846c4:	47b0      	blx	r6
				--uxCurrentNumberOfTasks;
   846c6:	4a12      	ldr	r2, [pc, #72]	; (84710 <prvIdleTask+0x68>)
   846c8:	6813      	ldr	r3, [r2, #0]
   846ca:	3b01      	subs	r3, #1
   846cc:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
   846ce:	682b      	ldr	r3, [r5, #0]
   846d0:	3b01      	subs	r3, #1
   846d2:	602b      	str	r3, [r5, #0]
			taskEXIT_CRITICAL();
   846d4:	4b0f      	ldr	r3, [pc, #60]	; (84714 <prvIdleTask+0x6c>)
   846d6:	4798      	blx	r3
			vPortFree( pxTCB->pxStack );
   846d8:	6b20      	ldr	r0, [r4, #48]	; 0x30
   846da:	f8df a048 	ldr.w	sl, [pc, #72]	; 84724 <prvIdleTask+0x7c>
   846de:	47d0      	blx	sl
			vPortFree( pxTCB );
   846e0:	4620      	mov	r0, r4
   846e2:	47d0      	blx	sl
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
   846e4:	682b      	ldr	r3, [r5, #0]
   846e6:	2b00      	cmp	r3, #0
   846e8:	d1e8      	bne.n	846bc <prvIdleTask+0x14>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   846ea:	4b0b      	ldr	r3, [pc, #44]	; (84718 <prvIdleTask+0x70>)
   846ec:	681b      	ldr	r3, [r3, #0]
   846ee:	2b01      	cmp	r3, #1
   846f0:	d9e1      	bls.n	846b6 <prvIdleTask+0xe>
				taskYIELD();
   846f2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   846f6:	f8c9 3000 	str.w	r3, [r9]
   846fa:	f3bf 8f4f 	dsb	sy
   846fe:	f3bf 8f6f 	isb	sy
   84702:	e7d8      	b.n	846b6 <prvIdleTask+0xe>
   84704:	20075288 	.word	0x20075288
   84708:	200752fc 	.word	0x200752fc
   8470c:	000838ed 	.word	0x000838ed
   84710:	20075284 	.word	0x20075284
   84714:	00083a0d 	.word	0x00083a0d
   84718:	2007521c 	.word	0x2007521c
   8471c:	000839c5 	.word	0x000839c5
   84720:	e000ed04 	.word	0xe000ed04
   84724:	00083c8d 	.word	0x00083c8d

00084728 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
   84728:	b570      	push	{r4, r5, r6, lr}
   8472a:	4604      	mov	r4, r0
   8472c:	460e      	mov	r6, r1
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
   8472e:	4b1d      	ldr	r3, [pc, #116]	; (847a4 <prvAddCurrentTaskToDelayedList+0x7c>)
   84730:	681d      	ldr	r5, [r3, #0]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   84732:	4b1d      	ldr	r3, [pc, #116]	; (847a8 <prvAddCurrentTaskToDelayedList+0x80>)
   84734:	6818      	ldr	r0, [r3, #0]
   84736:	3004      	adds	r0, #4
   84738:	4b1c      	ldr	r3, [pc, #112]	; (847ac <prvAddCurrentTaskToDelayedList+0x84>)
   8473a:	4798      	blx	r3
   8473c:	b948      	cbnz	r0, 84752 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   8473e:	4b1a      	ldr	r3, [pc, #104]	; (847a8 <prvAddCurrentTaskToDelayedList+0x80>)
   84740:	681a      	ldr	r2, [r3, #0]
   84742:	491b      	ldr	r1, [pc, #108]	; (847b0 <prvAddCurrentTaskToDelayedList+0x88>)
   84744:	680b      	ldr	r3, [r1, #0]
   84746:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
   84748:	2201      	movs	r2, #1
   8474a:	4082      	lsls	r2, r0
   8474c:	ea23 0302 	bic.w	r3, r3, r2
   84750:	600b      	str	r3, [r1, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   84752:	f1b4 3fff 	cmp.w	r4, #4294967295
   84756:	d013      	beq.n	84780 <prvAddCurrentTaskToDelayedList+0x58>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
   84758:	442c      	add	r4, r5

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
   8475a:	4b13      	ldr	r3, [pc, #76]	; (847a8 <prvAddCurrentTaskToDelayedList+0x80>)
   8475c:	681b      	ldr	r3, [r3, #0]
   8475e:	605c      	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
   84760:	42a5      	cmp	r5, r4
   84762:	d816      	bhi.n	84792 <prvAddCurrentTaskToDelayedList+0x6a>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   84764:	4b13      	ldr	r3, [pc, #76]	; (847b4 <prvAddCurrentTaskToDelayedList+0x8c>)
   84766:	6818      	ldr	r0, [r3, #0]
   84768:	4b0f      	ldr	r3, [pc, #60]	; (847a8 <prvAddCurrentTaskToDelayedList+0x80>)
   8476a:	6819      	ldr	r1, [r3, #0]
   8476c:	3104      	adds	r1, #4
   8476e:	4b12      	ldr	r3, [pc, #72]	; (847b8 <prvAddCurrentTaskToDelayedList+0x90>)
   84770:	4798      	blx	r3

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
   84772:	4b12      	ldr	r3, [pc, #72]	; (847bc <prvAddCurrentTaskToDelayedList+0x94>)
   84774:	681b      	ldr	r3, [r3, #0]
   84776:	429c      	cmp	r4, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
   84778:	bf3c      	itt	cc
   8477a:	4b10      	ldrcc	r3, [pc, #64]	; (847bc <prvAddCurrentTaskToDelayedList+0x94>)
   8477c:	601c      	strcc	r4, [r3, #0]
   8477e:	bd70      	pop	{r4, r5, r6, pc}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
   84780:	2e00      	cmp	r6, #0
   84782:	d0e9      	beq.n	84758 <prvAddCurrentTaskToDelayedList+0x30>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
   84784:	4b08      	ldr	r3, [pc, #32]	; (847a8 <prvAddCurrentTaskToDelayedList+0x80>)
   84786:	6819      	ldr	r1, [r3, #0]
   84788:	3104      	adds	r1, #4
   8478a:	480d      	ldr	r0, [pc, #52]	; (847c0 <prvAddCurrentTaskToDelayedList+0x98>)
   8478c:	4b0d      	ldr	r3, [pc, #52]	; (847c4 <prvAddCurrentTaskToDelayedList+0x9c>)
   8478e:	4798      	blx	r3
   84790:	bd70      	pop	{r4, r5, r6, pc}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
   84792:	4b0d      	ldr	r3, [pc, #52]	; (847c8 <prvAddCurrentTaskToDelayedList+0xa0>)
   84794:	6818      	ldr	r0, [r3, #0]
   84796:	4b04      	ldr	r3, [pc, #16]	; (847a8 <prvAddCurrentTaskToDelayedList+0x80>)
   84798:	6819      	ldr	r1, [r3, #0]
   8479a:	3104      	adds	r1, #4
   8479c:	4b06      	ldr	r3, [pc, #24]	; (847b8 <prvAddCurrentTaskToDelayedList+0x90>)
   8479e:	4798      	blx	r3
   847a0:	bd70      	pop	{r4, r5, r6, pc}
   847a2:	bf00      	nop
   847a4:	20075310 	.word	0x20075310
   847a8:	20075210 	.word	0x20075210
   847ac:	000838ed 	.word	0x000838ed
   847b0:	20075298 	.word	0x20075298
   847b4:	20075214 	.word	0x20075214
   847b8:	000838b9 	.word	0x000838b9
   847bc:	200752c8 	.word	0x200752c8
   847c0:	200752e8 	.word	0x200752e8
   847c4:	000838a1 	.word	0x000838a1
   847c8:	20075218 	.word	0x20075218

000847cc <xTaskCreate>:
	{
   847cc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   847d0:	b083      	sub	sp, #12
   847d2:	4683      	mov	fp, r0
   847d4:	460d      	mov	r5, r1
   847d6:	9301      	str	r3, [sp, #4]
   847d8:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   847dc:	0096      	lsls	r6, r2, #2
   847de:	4630      	mov	r0, r6
   847e0:	4b60      	ldr	r3, [pc, #384]	; (84964 <xTaskCreate+0x198>)
   847e2:	4798      	blx	r3
			if( pxStack != NULL )
   847e4:	2800      	cmp	r0, #0
   847e6:	f000 808e 	beq.w	84906 <xTaskCreate+0x13a>
   847ea:	4607      	mov	r7, r0
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
   847ec:	205c      	movs	r0, #92	; 0x5c
   847ee:	4b5d      	ldr	r3, [pc, #372]	; (84964 <xTaskCreate+0x198>)
   847f0:	4798      	blx	r3
				if( pxNewTCB != NULL )
   847f2:	4604      	mov	r4, r0
   847f4:	2800      	cmp	r0, #0
   847f6:	f000 8083 	beq.w	84900 <xTaskCreate+0x134>
					pxNewTCB->pxStack = pxStack;
   847fa:	6307      	str	r7, [r0, #48]	; 0x30
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
   847fc:	4632      	mov	r2, r6
   847fe:	21a5      	movs	r1, #165	; 0xa5
   84800:	4638      	mov	r0, r7
   84802:	4b59      	ldr	r3, [pc, #356]	; (84968 <xTaskCreate+0x19c>)
   84804:	4798      	blx	r3
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
   84806:	3e04      	subs	r6, #4
   84808:	6b23      	ldr	r3, [r4, #48]	; 0x30
   8480a:	441e      	add	r6, r3
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   8480c:	f026 0607 	bic.w	r6, r6, #7
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   84810:	782b      	ldrb	r3, [r5, #0]
   84812:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
		if( pcName[ x ] == 0x00 )
   84816:	782b      	ldrb	r3, [r5, #0]
   84818:	b163      	cbz	r3, 84834 <xTaskCreate+0x68>
   8481a:	462b      	mov	r3, r5
   8481c:	f104 0234 	add.w	r2, r4, #52	; 0x34
   84820:	f105 0109 	add.w	r1, r5, #9
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
   84824:	7858      	ldrb	r0, [r3, #1]
   84826:	f802 0f01 	strb.w	r0, [r2, #1]!
		if( pcName[ x ] == 0x00 )
   8482a:	f813 0f01 	ldrb.w	r0, [r3, #1]!
   8482e:	b108      	cbz	r0, 84834 <xTaskCreate+0x68>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   84830:	428b      	cmp	r3, r1
   84832:	d1f7      	bne.n	84824 <xTaskCreate+0x58>
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   84834:	2700      	movs	r7, #0
   84836:	f884 703d 	strb.w	r7, [r4, #61]	; 0x3d
   8483a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
   8483c:	2d04      	cmp	r5, #4
   8483e:	bf28      	it	cs
   84840:	2504      	movcs	r5, #4
	pxNewTCB->uxPriority = uxPriority;
   84842:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
   84844:	64a5      	str	r5, [r4, #72]	; 0x48
		pxNewTCB->uxMutexesHeld = 0;
   84846:	64e7      	str	r7, [r4, #76]	; 0x4c
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
   84848:	f104 0804 	add.w	r8, r4, #4
   8484c:	4640      	mov	r0, r8
   8484e:	f8df 916c 	ldr.w	r9, [pc, #364]	; 849bc <xTaskCreate+0x1f0>
   84852:	47c8      	blx	r9
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
   84854:	f104 0018 	add.w	r0, r4, #24
   84858:	47c8      	blx	r9
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
   8485a:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8485c:	f1c5 0505 	rsb	r5, r5, #5
   84860:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
   84862:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ulRunTimeCounter = 0UL;
   84864:	6527      	str	r7, [r4, #80]	; 0x50
		pxNewTCB->ulNotifiedValue = 0;
   84866:	6567      	str	r7, [r4, #84]	; 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
   84868:	f884 7058 	strb.w	r7, [r4, #88]	; 0x58
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   8486c:	9a01      	ldr	r2, [sp, #4]
   8486e:	4659      	mov	r1, fp
   84870:	4630      	mov	r0, r6
   84872:	4b3e      	ldr	r3, [pc, #248]	; (8496c <xTaskCreate+0x1a0>)
   84874:	4798      	blx	r3
   84876:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
   84878:	f1ba 0f00 	cmp.w	sl, #0
   8487c:	d001      	beq.n	84882 <xTaskCreate+0xb6>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   8487e:	f8ca 4000 	str.w	r4, [sl]
	taskENTER_CRITICAL();
   84882:	4b3b      	ldr	r3, [pc, #236]	; (84970 <xTaskCreate+0x1a4>)
   84884:	4798      	blx	r3
		uxCurrentNumberOfTasks++;
   84886:	4a3b      	ldr	r2, [pc, #236]	; (84974 <xTaskCreate+0x1a8>)
   84888:	6813      	ldr	r3, [r2, #0]
   8488a:	3301      	adds	r3, #1
   8488c:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
   8488e:	4b3a      	ldr	r3, [pc, #232]	; (84978 <xTaskCreate+0x1ac>)
   84890:	681b      	ldr	r3, [r3, #0]
   84892:	2b00      	cmp	r3, #0
   84894:	d03a      	beq.n	8490c <xTaskCreate+0x140>
			if( xSchedulerRunning == pdFALSE )
   84896:	4b39      	ldr	r3, [pc, #228]	; (8497c <xTaskCreate+0x1b0>)
   84898:	681b      	ldr	r3, [r3, #0]
   8489a:	b93b      	cbnz	r3, 848ac <xTaskCreate+0xe0>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
   8489c:	4b36      	ldr	r3, [pc, #216]	; (84978 <xTaskCreate+0x1ac>)
   8489e:	681b      	ldr	r3, [r3, #0]
   848a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   848a2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   848a4:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
   848a6:	bf9c      	itt	ls
   848a8:	4b33      	ldrls	r3, [pc, #204]	; (84978 <xTaskCreate+0x1ac>)
   848aa:	601c      	strls	r4, [r3, #0]
		uxTaskNumber++;
   848ac:	4a34      	ldr	r2, [pc, #208]	; (84980 <xTaskCreate+0x1b4>)
   848ae:	6813      	ldr	r3, [r2, #0]
   848b0:	3301      	adds	r3, #1
   848b2:	6013      	str	r3, [r2, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
   848b4:	6423      	str	r3, [r4, #64]	; 0x40
		prvAddTaskToReadyList( pxNewTCB );
   848b6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   848b8:	4a32      	ldr	r2, [pc, #200]	; (84984 <xTaskCreate+0x1b8>)
   848ba:	6811      	ldr	r1, [r2, #0]
   848bc:	2301      	movs	r3, #1
   848be:	4083      	lsls	r3, r0
   848c0:	430b      	orrs	r3, r1
   848c2:	6013      	str	r3, [r2, #0]
   848c4:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   848c8:	4641      	mov	r1, r8
   848ca:	4b2f      	ldr	r3, [pc, #188]	; (84988 <xTaskCreate+0x1bc>)
   848cc:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   848d0:	4b2e      	ldr	r3, [pc, #184]	; (8498c <xTaskCreate+0x1c0>)
   848d2:	4798      	blx	r3
	taskEXIT_CRITICAL();
   848d4:	4b2e      	ldr	r3, [pc, #184]	; (84990 <xTaskCreate+0x1c4>)
   848d6:	4798      	blx	r3
	if( xSchedulerRunning != pdFALSE )
   848d8:	4b28      	ldr	r3, [pc, #160]	; (8497c <xTaskCreate+0x1b0>)
   848da:	681b      	ldr	r3, [r3, #0]
   848dc:	2b00      	cmp	r3, #0
   848de:	d03b      	beq.n	84958 <xTaskCreate+0x18c>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
   848e0:	4b25      	ldr	r3, [pc, #148]	; (84978 <xTaskCreate+0x1ac>)
   848e2:	681b      	ldr	r3, [r3, #0]
   848e4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   848e6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   848e8:	429a      	cmp	r2, r3
   848ea:	d239      	bcs.n	84960 <xTaskCreate+0x194>
			taskYIELD_IF_USING_PREEMPTION();
   848ec:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   848f0:	4b28      	ldr	r3, [pc, #160]	; (84994 <xTaskCreate+0x1c8>)
   848f2:	601a      	str	r2, [r3, #0]
   848f4:	f3bf 8f4f 	dsb	sy
   848f8:	f3bf 8f6f 	isb	sy
			xReturn = pdPASS;
   848fc:	2001      	movs	r0, #1
   848fe:	e02c      	b.n	8495a <xTaskCreate+0x18e>
					vPortFree( pxStack );
   84900:	4638      	mov	r0, r7
   84902:	4b25      	ldr	r3, [pc, #148]	; (84998 <xTaskCreate+0x1cc>)
   84904:	4798      	blx	r3
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   84906:	f04f 30ff 	mov.w	r0, #4294967295
   8490a:	e026      	b.n	8495a <xTaskCreate+0x18e>
			pxCurrentTCB = pxNewTCB;
   8490c:	4b1a      	ldr	r3, [pc, #104]	; (84978 <xTaskCreate+0x1ac>)
   8490e:	601c      	str	r4, [r3, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   84910:	6813      	ldr	r3, [r2, #0]
   84912:	2b01      	cmp	r3, #1
   84914:	d1ca      	bne.n	848ac <xTaskCreate+0xe0>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   84916:	4e1c      	ldr	r6, [pc, #112]	; (84988 <xTaskCreate+0x1bc>)
   84918:	4630      	mov	r0, r6
   8491a:	4d20      	ldr	r5, [pc, #128]	; (8499c <xTaskCreate+0x1d0>)
   8491c:	47a8      	blx	r5
   8491e:	f106 0014 	add.w	r0, r6, #20
   84922:	47a8      	blx	r5
   84924:	f106 0028 	add.w	r0, r6, #40	; 0x28
   84928:	47a8      	blx	r5
   8492a:	f106 003c 	add.w	r0, r6, #60	; 0x3c
   8492e:	47a8      	blx	r5
   84930:	f106 0050 	add.w	r0, r6, #80	; 0x50
   84934:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList1 );
   84936:	4f1a      	ldr	r7, [pc, #104]	; (849a0 <xTaskCreate+0x1d4>)
   84938:	4638      	mov	r0, r7
   8493a:	47a8      	blx	r5
	vListInitialise( &xDelayedTaskList2 );
   8493c:	4e19      	ldr	r6, [pc, #100]	; (849a4 <xTaskCreate+0x1d8>)
   8493e:	4630      	mov	r0, r6
   84940:	47a8      	blx	r5
	vListInitialise( &xPendingReadyList );
   84942:	4819      	ldr	r0, [pc, #100]	; (849a8 <xTaskCreate+0x1dc>)
   84944:	47a8      	blx	r5
		vListInitialise( &xTasksWaitingTermination );
   84946:	4819      	ldr	r0, [pc, #100]	; (849ac <xTaskCreate+0x1e0>)
   84948:	47a8      	blx	r5
		vListInitialise( &xSuspendedTaskList );
   8494a:	4819      	ldr	r0, [pc, #100]	; (849b0 <xTaskCreate+0x1e4>)
   8494c:	47a8      	blx	r5
	pxDelayedTaskList = &xDelayedTaskList1;
   8494e:	4b19      	ldr	r3, [pc, #100]	; (849b4 <xTaskCreate+0x1e8>)
   84950:	601f      	str	r7, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   84952:	4b19      	ldr	r3, [pc, #100]	; (849b8 <xTaskCreate+0x1ec>)
   84954:	601e      	str	r6, [r3, #0]
   84956:	e7a9      	b.n	848ac <xTaskCreate+0xe0>
			xReturn = pdPASS;
   84958:	2001      	movs	r0, #1
	}
   8495a:	b003      	add	sp, #12
   8495c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			xReturn = pdPASS;
   84960:	2001      	movs	r0, #1
		return xReturn;
   84962:	e7fa      	b.n	8495a <xTaskCreate+0x18e>
   84964:	00083c1d 	.word	0x00083c1d
   84968:	00085b9d 	.word	0x00085b9d
   8496c:	00083979 	.word	0x00083979
   84970:	000839c5 	.word	0x000839c5
   84974:	20075284 	.word	0x20075284
   84978:	20075210 	.word	0x20075210
   8497c:	200752e4 	.word	0x200752e4
   84980:	20075294 	.word	0x20075294
   84984:	20075298 	.word	0x20075298
   84988:	2007521c 	.word	0x2007521c
   8498c:	000838a1 	.word	0x000838a1
   84990:	00083a0d 	.word	0x00083a0d
   84994:	e000ed04 	.word	0xe000ed04
   84998:	00083c8d 	.word	0x00083c8d
   8499c:	00083885 	.word	0x00083885
   849a0:	2007529c 	.word	0x2007529c
   849a4:	200752b0 	.word	0x200752b0
   849a8:	200752d0 	.word	0x200752d0
   849ac:	200752fc 	.word	0x200752fc
   849b0:	200752e8 	.word	0x200752e8
   849b4:	20075214 	.word	0x20075214
   849b8:	20075218 	.word	0x20075218
   849bc:	0008389b 	.word	0x0008389b

000849c0 <vTaskStartScheduler>:
{
   849c0:	b510      	push	{r4, lr}
   849c2:	b082      	sub	sp, #8
		xReturn = xTaskCreate(	prvIdleTask,
   849c4:	4b18      	ldr	r3, [pc, #96]	; (84a28 <vTaskStartScheduler+0x68>)
   849c6:	9301      	str	r3, [sp, #4]
   849c8:	2300      	movs	r3, #0
   849ca:	9300      	str	r3, [sp, #0]
   849cc:	22a0      	movs	r2, #160	; 0xa0
   849ce:	4917      	ldr	r1, [pc, #92]	; (84a2c <vTaskStartScheduler+0x6c>)
   849d0:	4817      	ldr	r0, [pc, #92]	; (84a30 <vTaskStartScheduler+0x70>)
   849d2:	4c18      	ldr	r4, [pc, #96]	; (84a34 <vTaskStartScheduler+0x74>)
   849d4:	47a0      	blx	r4
		if( xReturn == pdPASS )
   849d6:	2801      	cmp	r0, #1
   849d8:	d004      	beq.n	849e4 <vTaskStartScheduler+0x24>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   849da:	f1b0 3fff 	cmp.w	r0, #4294967295
   849de:	d01c      	beq.n	84a1a <vTaskStartScheduler+0x5a>
}
   849e0:	b002      	add	sp, #8
   849e2:	bd10      	pop	{r4, pc}
			xReturn = xTimerCreateTimerTask();
   849e4:	4b14      	ldr	r3, [pc, #80]	; (84a38 <vTaskStartScheduler+0x78>)
   849e6:	4798      	blx	r3
	if( xReturn == pdPASS )
   849e8:	2801      	cmp	r0, #1
   849ea:	d1f6      	bne.n	849da <vTaskStartScheduler+0x1a>
	__asm volatile
   849ec:	f04f 03a0 	mov.w	r3, #160	; 0xa0
   849f0:	f383 8811 	msr	BASEPRI, r3
   849f4:	f3bf 8f6f 	isb	sy
   849f8:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
   849fc:	f04f 32ff 	mov.w	r2, #4294967295
   84a00:	4b0e      	ldr	r3, [pc, #56]	; (84a3c <vTaskStartScheduler+0x7c>)
   84a02:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
   84a04:	2201      	movs	r2, #1
   84a06:	4b0e      	ldr	r3, [pc, #56]	; (84a40 <vTaskStartScheduler+0x80>)
   84a08:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   84a0a:	2200      	movs	r2, #0
   84a0c:	4b0d      	ldr	r3, [pc, #52]	; (84a44 <vTaskStartScheduler+0x84>)
   84a0e:	601a      	str	r2, [r3, #0]
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   84a10:	4b0d      	ldr	r3, [pc, #52]	; (84a48 <vTaskStartScheduler+0x88>)
   84a12:	4798      	blx	r3
		if( xPortStartScheduler() != pdFALSE )
   84a14:	4b0d      	ldr	r3, [pc, #52]	; (84a4c <vTaskStartScheduler+0x8c>)
   84a16:	4798      	blx	r3
   84a18:	e7e2      	b.n	849e0 <vTaskStartScheduler+0x20>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
   84a1a:	f240 71dc 	movw	r1, #2012	; 0x7dc
   84a1e:	480c      	ldr	r0, [pc, #48]	; (84a50 <vTaskStartScheduler+0x90>)
   84a20:	4b0c      	ldr	r3, [pc, #48]	; (84a54 <vTaskStartScheduler+0x94>)
   84a22:	4798      	blx	r3
}
   84a24:	e7dc      	b.n	849e0 <vTaskStartScheduler+0x20>
   84a26:	bf00      	nop
   84a28:	200752c4 	.word	0x200752c4
   84a2c:	0008621c 	.word	0x0008621c
   84a30:	000846a9 	.word	0x000846a9
   84a34:	000847cd 	.word	0x000847cd
   84a38:	0008536d 	.word	0x0008536d
   84a3c:	200752c8 	.word	0x200752c8
   84a40:	200752e4 	.word	0x200752e4
   84a44:	20075310 	.word	0x20075310
   84a48:	000859f1 	.word	0x000859f1
   84a4c:	00083add 	.word	0x00083add
   84a50:	000861dc 	.word	0x000861dc
   84a54:	00085861 	.word	0x00085861

00084a58 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
   84a58:	4a02      	ldr	r2, [pc, #8]	; (84a64 <vTaskSuspendAll+0xc>)
   84a5a:	6813      	ldr	r3, [r2, #0]
   84a5c:	3301      	adds	r3, #1
   84a5e:	6013      	str	r3, [r2, #0]
   84a60:	4770      	bx	lr
   84a62:	bf00      	nop
   84a64:	20075290 	.word	0x20075290

00084a68 <xTaskGetTickCount>:
		xTicks = xTickCount;
   84a68:	4b01      	ldr	r3, [pc, #4]	; (84a70 <xTaskGetTickCount+0x8>)
   84a6a:	6818      	ldr	r0, [r3, #0]
}
   84a6c:	4770      	bx	lr
   84a6e:	bf00      	nop
   84a70:	20075310 	.word	0x20075310

00084a74 <xTaskGetTickCountFromISR>:
{
   84a74:	b508      	push	{r3, lr}
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   84a76:	4b02      	ldr	r3, [pc, #8]	; (84a80 <xTaskGetTickCountFromISR+0xc>)
   84a78:	4798      	blx	r3
		xReturn = xTickCount;
   84a7a:	4b02      	ldr	r3, [pc, #8]	; (84a84 <xTaskGetTickCountFromISR+0x10>)
   84a7c:	6818      	ldr	r0, [r3, #0]
}
   84a7e:	bd08      	pop	{r3, pc}
   84a80:	00083bc1 	.word	0x00083bc1
   84a84:	20075310 	.word	0x20075310

00084a88 <xTaskIncrementTick>:
{
   84a88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   84a8c:	4b3d      	ldr	r3, [pc, #244]	; (84b84 <xTaskIncrementTick+0xfc>)
   84a8e:	681b      	ldr	r3, [r3, #0]
   84a90:	2b00      	cmp	r3, #0
   84a92:	d170      	bne.n	84b76 <xTaskIncrementTick+0xee>
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
   84a94:	4b3c      	ldr	r3, [pc, #240]	; (84b88 <xTaskIncrementTick+0x100>)
   84a96:	681a      	ldr	r2, [r3, #0]
   84a98:	f102 0801 	add.w	r8, r2, #1
		xTickCount = xConstTickCount;
   84a9c:	f8c3 8000 	str.w	r8, [r3]
		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
   84aa0:	f1b8 0f00 	cmp.w	r8, #0
   84aa4:	d10f      	bne.n	84ac6 <xTaskIncrementTick+0x3e>
			taskSWITCH_DELAYED_LISTS();
   84aa6:	4b39      	ldr	r3, [pc, #228]	; (84b8c <xTaskIncrementTick+0x104>)
   84aa8:	681b      	ldr	r3, [r3, #0]
   84aaa:	681b      	ldr	r3, [r3, #0]
   84aac:	bb1b      	cbnz	r3, 84af6 <xTaskIncrementTick+0x6e>
   84aae:	4a37      	ldr	r2, [pc, #220]	; (84b8c <xTaskIncrementTick+0x104>)
   84ab0:	6811      	ldr	r1, [r2, #0]
   84ab2:	4b37      	ldr	r3, [pc, #220]	; (84b90 <xTaskIncrementTick+0x108>)
   84ab4:	6818      	ldr	r0, [r3, #0]
   84ab6:	6010      	str	r0, [r2, #0]
   84ab8:	6019      	str	r1, [r3, #0]
   84aba:	4a36      	ldr	r2, [pc, #216]	; (84b94 <xTaskIncrementTick+0x10c>)
   84abc:	6813      	ldr	r3, [r2, #0]
   84abe:	3301      	adds	r3, #1
   84ac0:	6013      	str	r3, [r2, #0]
   84ac2:	4b35      	ldr	r3, [pc, #212]	; (84b98 <xTaskIncrementTick+0x110>)
   84ac4:	4798      	blx	r3
		if( xConstTickCount >= xNextTaskUnblockTime )
   84ac6:	4b35      	ldr	r3, [pc, #212]	; (84b9c <xTaskIncrementTick+0x114>)
   84ac8:	681b      	ldr	r3, [r3, #0]
   84aca:	4598      	cmp	r8, r3
   84acc:	d219      	bcs.n	84b02 <xTaskIncrementTick+0x7a>
BaseType_t xSwitchRequired = pdFALSE;
   84ace:	2500      	movs	r5, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   84ad0:	4b33      	ldr	r3, [pc, #204]	; (84ba0 <xTaskIncrementTick+0x118>)
   84ad2:	681b      	ldr	r3, [r3, #0]
   84ad4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   84ad6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   84ada:	009b      	lsls	r3, r3, #2
   84adc:	4a31      	ldr	r2, [pc, #196]	; (84ba4 <xTaskIncrementTick+0x11c>)
   84ade:	58d3      	ldr	r3, [r2, r3]
				xSwitchRequired = pdTRUE;
   84ae0:	2b02      	cmp	r3, #2
   84ae2:	bf28      	it	cs
   84ae4:	2501      	movcs	r5, #1
		if( xYieldPending != pdFALSE )
   84ae6:	4b30      	ldr	r3, [pc, #192]	; (84ba8 <xTaskIncrementTick+0x120>)
   84ae8:	681b      	ldr	r3, [r3, #0]
			xSwitchRequired = pdTRUE;
   84aea:	2b00      	cmp	r3, #0
}
   84aec:	bf0c      	ite	eq
   84aee:	4628      	moveq	r0, r5
   84af0:	2001      	movne	r0, #1
   84af2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			taskSWITCH_DELAYED_LISTS();
   84af6:	f640 2133 	movw	r1, #2611	; 0xa33
   84afa:	482c      	ldr	r0, [pc, #176]	; (84bac <xTaskIncrementTick+0x124>)
   84afc:	4b2c      	ldr	r3, [pc, #176]	; (84bb0 <xTaskIncrementTick+0x128>)
   84afe:	4798      	blx	r3
   84b00:	e7d5      	b.n	84aae <xTaskIncrementTick+0x26>
   84b02:	2500      	movs	r5, #0
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   84b04:	4f21      	ldr	r7, [pc, #132]	; (84b8c <xTaskIncrementTick+0x104>)
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   84b06:	f8df a0b4 	ldr.w	sl, [pc, #180]	; 84bbc <xTaskIncrementTick+0x134>
					prvAddTaskToReadyList( pxTCB );
   84b0a:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 84bc0 <xTaskIncrementTick+0x138>
   84b0e:	e021      	b.n	84b54 <xTaskIncrementTick+0xcc>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   84b10:	f04f 32ff 	mov.w	r2, #4294967295
   84b14:	4b21      	ldr	r3, [pc, #132]	; (84b9c <xTaskIncrementTick+0x114>)
   84b16:	601a      	str	r2, [r3, #0]
					break;
   84b18:	e7da      	b.n	84ad0 <xTaskIncrementTick+0x48>
						xNextTaskUnblockTime = xItemValue;
   84b1a:	4a20      	ldr	r2, [pc, #128]	; (84b9c <xTaskIncrementTick+0x114>)
   84b1c:	6013      	str	r3, [r2, #0]
						break;
   84b1e:	e7d7      	b.n	84ad0 <xTaskIncrementTick+0x48>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   84b20:	f104 0018 	add.w	r0, r4, #24
   84b24:	47d0      	blx	sl
					prvAddTaskToReadyList( pxTCB );
   84b26:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   84b28:	f8d9 2000 	ldr.w	r2, [r9]
   84b2c:	2301      	movs	r3, #1
   84b2e:	4083      	lsls	r3, r0
   84b30:	4313      	orrs	r3, r2
   84b32:	f8c9 3000 	str.w	r3, [r9]
   84b36:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   84b3a:	4631      	mov	r1, r6
   84b3c:	4b19      	ldr	r3, [pc, #100]	; (84ba4 <xTaskIncrementTick+0x11c>)
   84b3e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   84b42:	4b1c      	ldr	r3, [pc, #112]	; (84bb4 <xTaskIncrementTick+0x12c>)
   84b44:	4798      	blx	r3
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   84b46:	4b16      	ldr	r3, [pc, #88]	; (84ba0 <xTaskIncrementTick+0x118>)
   84b48:	681b      	ldr	r3, [r3, #0]
   84b4a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   84b4c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
   84b4e:	429a      	cmp	r2, r3
   84b50:	bf28      	it	cs
   84b52:	2501      	movcs	r5, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   84b54:	683b      	ldr	r3, [r7, #0]
   84b56:	681b      	ldr	r3, [r3, #0]
   84b58:	2b00      	cmp	r3, #0
   84b5a:	d0d9      	beq.n	84b10 <xTaskIncrementTick+0x88>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   84b5c:	683b      	ldr	r3, [r7, #0]
   84b5e:	68db      	ldr	r3, [r3, #12]
   84b60:	68dc      	ldr	r4, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
   84b62:	6863      	ldr	r3, [r4, #4]
					if( xConstTickCount < xItemValue )
   84b64:	4598      	cmp	r8, r3
   84b66:	d3d8      	bcc.n	84b1a <xTaskIncrementTick+0x92>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   84b68:	1d26      	adds	r6, r4, #4
   84b6a:	4630      	mov	r0, r6
   84b6c:	47d0      	blx	sl
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   84b6e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
   84b70:	2b00      	cmp	r3, #0
   84b72:	d1d5      	bne.n	84b20 <xTaskIncrementTick+0x98>
   84b74:	e7d7      	b.n	84b26 <xTaskIncrementTick+0x9e>
		++uxPendedTicks;
   84b76:	4a10      	ldr	r2, [pc, #64]	; (84bb8 <xTaskIncrementTick+0x130>)
   84b78:	6813      	ldr	r3, [r2, #0]
   84b7a:	3301      	adds	r3, #1
   84b7c:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
   84b7e:	2500      	movs	r5, #0
   84b80:	e7b1      	b.n	84ae6 <xTaskIncrementTick+0x5e>
   84b82:	bf00      	nop
   84b84:	20075290 	.word	0x20075290
   84b88:	20075310 	.word	0x20075310
   84b8c:	20075214 	.word	0x20075214
   84b90:	20075218 	.word	0x20075218
   84b94:	200752cc 	.word	0x200752cc
   84b98:	0008467d 	.word	0x0008467d
   84b9c:	200752c8 	.word	0x200752c8
   84ba0:	20075210 	.word	0x20075210
   84ba4:	2007521c 	.word	0x2007521c
   84ba8:	20075314 	.word	0x20075314
   84bac:	000861dc 	.word	0x000861dc
   84bb0:	00085861 	.word	0x00085861
   84bb4:	000838a1 	.word	0x000838a1
   84bb8:	2007528c 	.word	0x2007528c
   84bbc:	000838ed 	.word	0x000838ed
   84bc0:	20075298 	.word	0x20075298

00084bc4 <xTaskResumeAll>:
{
   84bc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	configASSERT( uxSchedulerSuspended );
   84bc8:	4b34      	ldr	r3, [pc, #208]	; (84c9c <xTaskResumeAll+0xd8>)
   84bca:	681b      	ldr	r3, [r3, #0]
   84bcc:	2b00      	cmp	r3, #0
   84bce:	d033      	beq.n	84c38 <xTaskResumeAll+0x74>
	taskENTER_CRITICAL();
   84bd0:	4b33      	ldr	r3, [pc, #204]	; (84ca0 <xTaskResumeAll+0xdc>)
   84bd2:	4798      	blx	r3
		--uxSchedulerSuspended;
   84bd4:	4b31      	ldr	r3, [pc, #196]	; (84c9c <xTaskResumeAll+0xd8>)
   84bd6:	681a      	ldr	r2, [r3, #0]
   84bd8:	3a01      	subs	r2, #1
   84bda:	601a      	str	r2, [r3, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   84bdc:	681b      	ldr	r3, [r3, #0]
   84bde:	2b00      	cmp	r3, #0
   84be0:	d153      	bne.n	84c8a <xTaskResumeAll+0xc6>
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   84be2:	4b30      	ldr	r3, [pc, #192]	; (84ca4 <xTaskResumeAll+0xe0>)
   84be4:	681b      	ldr	r3, [r3, #0]
   84be6:	2b00      	cmp	r3, #0
   84be8:	d02c      	beq.n	84c44 <xTaskResumeAll+0x80>
   84bea:	2400      	movs	r4, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   84bec:	4e2e      	ldr	r6, [pc, #184]	; (84ca8 <xTaskResumeAll+0xe4>)
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   84bee:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 84cdc <xTaskResumeAll+0x118>
					prvAddTaskToReadyList( pxTCB );
   84bf2:	4f2e      	ldr	r7, [pc, #184]	; (84cac <xTaskResumeAll+0xe8>)
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   84bf4:	6833      	ldr	r3, [r6, #0]
   84bf6:	b33b      	cbz	r3, 84c48 <xTaskResumeAll+0x84>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   84bf8:	68f3      	ldr	r3, [r6, #12]
   84bfa:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   84bfc:	f104 0018 	add.w	r0, r4, #24
   84c00:	47c0      	blx	r8
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
   84c02:	1d25      	adds	r5, r4, #4
   84c04:	4628      	mov	r0, r5
   84c06:	47c0      	blx	r8
					prvAddTaskToReadyList( pxTCB );
   84c08:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   84c0a:	683a      	ldr	r2, [r7, #0]
   84c0c:	2301      	movs	r3, #1
   84c0e:	4083      	lsls	r3, r0
   84c10:	4313      	orrs	r3, r2
   84c12:	603b      	str	r3, [r7, #0]
   84c14:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   84c18:	4629      	mov	r1, r5
   84c1a:	4b25      	ldr	r3, [pc, #148]	; (84cb0 <xTaskResumeAll+0xec>)
   84c1c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   84c20:	4b24      	ldr	r3, [pc, #144]	; (84cb4 <xTaskResumeAll+0xf0>)
   84c22:	4798      	blx	r3
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   84c24:	4b24      	ldr	r3, [pc, #144]	; (84cb8 <xTaskResumeAll+0xf4>)
   84c26:	681b      	ldr	r3, [r3, #0]
   84c28:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   84c2a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   84c2c:	429a      	cmp	r2, r3
   84c2e:	d3e1      	bcc.n	84bf4 <xTaskResumeAll+0x30>
						xYieldPending = pdTRUE;
   84c30:	2201      	movs	r2, #1
   84c32:	4b22      	ldr	r3, [pc, #136]	; (84cbc <xTaskResumeAll+0xf8>)
   84c34:	601a      	str	r2, [r3, #0]
   84c36:	e7dd      	b.n	84bf4 <xTaskResumeAll+0x30>
	configASSERT( uxSchedulerSuspended );
   84c38:	f44f 6104 	mov.w	r1, #2112	; 0x840
   84c3c:	4820      	ldr	r0, [pc, #128]	; (84cc0 <xTaskResumeAll+0xfc>)
   84c3e:	4b21      	ldr	r3, [pc, #132]	; (84cc4 <xTaskResumeAll+0x100>)
   84c40:	4798      	blx	r3
   84c42:	e7c5      	b.n	84bd0 <xTaskResumeAll+0xc>
BaseType_t xAlreadyYielded = pdFALSE;
   84c44:	2400      	movs	r4, #0
   84c46:	e021      	b.n	84c8c <xTaskResumeAll+0xc8>
				if( pxTCB != NULL )
   84c48:	b10c      	cbz	r4, 84c4e <xTaskResumeAll+0x8a>
					prvResetNextTaskUnblockTime();
   84c4a:	4b1f      	ldr	r3, [pc, #124]	; (84cc8 <xTaskResumeAll+0x104>)
   84c4c:	4798      	blx	r3
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
   84c4e:	4b1f      	ldr	r3, [pc, #124]	; (84ccc <xTaskResumeAll+0x108>)
   84c50:	681c      	ldr	r4, [r3, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
   84c52:	b16c      	cbz	r4, 84c70 <xTaskResumeAll+0xac>
							if( xTaskIncrementTick() != pdFALSE )
   84c54:	4d1e      	ldr	r5, [pc, #120]	; (84cd0 <xTaskResumeAll+0x10c>)
								xYieldPending = pdTRUE;
   84c56:	4f19      	ldr	r7, [pc, #100]	; (84cbc <xTaskResumeAll+0xf8>)
   84c58:	2601      	movs	r6, #1
   84c5a:	e001      	b.n	84c60 <xTaskResumeAll+0x9c>
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
   84c5c:	3c01      	subs	r4, #1
   84c5e:	d004      	beq.n	84c6a <xTaskResumeAll+0xa6>
							if( xTaskIncrementTick() != pdFALSE )
   84c60:	47a8      	blx	r5
   84c62:	2800      	cmp	r0, #0
   84c64:	d0fa      	beq.n	84c5c <xTaskResumeAll+0x98>
								xYieldPending = pdTRUE;
   84c66:	603e      	str	r6, [r7, #0]
   84c68:	e7f8      	b.n	84c5c <xTaskResumeAll+0x98>
						uxPendedTicks = 0;
   84c6a:	2200      	movs	r2, #0
   84c6c:	4b17      	ldr	r3, [pc, #92]	; (84ccc <xTaskResumeAll+0x108>)
   84c6e:	601a      	str	r2, [r3, #0]
				if( xYieldPending != pdFALSE )
   84c70:	4b12      	ldr	r3, [pc, #72]	; (84cbc <xTaskResumeAll+0xf8>)
   84c72:	681b      	ldr	r3, [r3, #0]
   84c74:	b17b      	cbz	r3, 84c96 <xTaskResumeAll+0xd2>
					taskYIELD_IF_USING_PREEMPTION();
   84c76:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   84c7a:	4b16      	ldr	r3, [pc, #88]	; (84cd4 <xTaskResumeAll+0x110>)
   84c7c:	601a      	str	r2, [r3, #0]
   84c7e:	f3bf 8f4f 	dsb	sy
   84c82:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
   84c86:	2401      	movs	r4, #1
   84c88:	e000      	b.n	84c8c <xTaskResumeAll+0xc8>
BaseType_t xAlreadyYielded = pdFALSE;
   84c8a:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
   84c8c:	4b12      	ldr	r3, [pc, #72]	; (84cd8 <xTaskResumeAll+0x114>)
   84c8e:	4798      	blx	r3
}
   84c90:	4620      	mov	r0, r4
   84c92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
BaseType_t xAlreadyYielded = pdFALSE;
   84c96:	2400      	movs	r4, #0
   84c98:	e7f8      	b.n	84c8c <xTaskResumeAll+0xc8>
   84c9a:	bf00      	nop
   84c9c:	20075290 	.word	0x20075290
   84ca0:	000839c5 	.word	0x000839c5
   84ca4:	20075284 	.word	0x20075284
   84ca8:	200752d0 	.word	0x200752d0
   84cac:	20075298 	.word	0x20075298
   84cb0:	2007521c 	.word	0x2007521c
   84cb4:	000838a1 	.word	0x000838a1
   84cb8:	20075210 	.word	0x20075210
   84cbc:	20075314 	.word	0x20075314
   84cc0:	000861dc 	.word	0x000861dc
   84cc4:	00085861 	.word	0x00085861
   84cc8:	0008467d 	.word	0x0008467d
   84ccc:	2007528c 	.word	0x2007528c
   84cd0:	00084a89 	.word	0x00084a89
   84cd4:	e000ed04 	.word	0xe000ed04
   84cd8:	00083a0d 	.word	0x00083a0d
   84cdc:	000838ed 	.word	0x000838ed

00084ce0 <vTaskDelay>:
	{
   84ce0:	b510      	push	{r4, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
   84ce2:	b160      	cbz	r0, 84cfe <vTaskDelay+0x1e>
   84ce4:	4604      	mov	r4, r0
			configASSERT( uxSchedulerSuspended == 0 );
   84ce6:	4b0d      	ldr	r3, [pc, #52]	; (84d1c <vTaskDelay+0x3c>)
   84ce8:	681b      	ldr	r3, [r3, #0]
   84cea:	b98b      	cbnz	r3, 84d10 <vTaskDelay+0x30>
			vTaskSuspendAll();
   84cec:	4b0c      	ldr	r3, [pc, #48]	; (84d20 <vTaskDelay+0x40>)
   84cee:	4798      	blx	r3
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
   84cf0:	2100      	movs	r1, #0
   84cf2:	4620      	mov	r0, r4
   84cf4:	4b0b      	ldr	r3, [pc, #44]	; (84d24 <vTaskDelay+0x44>)
   84cf6:	4798      	blx	r3
			xAlreadyYielded = xTaskResumeAll();
   84cf8:	4b0b      	ldr	r3, [pc, #44]	; (84d28 <vTaskDelay+0x48>)
   84cfa:	4798      	blx	r3
		if( xAlreadyYielded == pdFALSE )
   84cfc:	b938      	cbnz	r0, 84d0e <vTaskDelay+0x2e>
			portYIELD_WITHIN_API();
   84cfe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   84d02:	4b0a      	ldr	r3, [pc, #40]	; (84d2c <vTaskDelay+0x4c>)
   84d04:	601a      	str	r2, [r3, #0]
   84d06:	f3bf 8f4f 	dsb	sy
   84d0a:	f3bf 8f6f 	isb	sy
   84d0e:	bd10      	pop	{r4, pc}
			configASSERT( uxSchedulerSuspended == 0 );
   84d10:	f240 510f 	movw	r1, #1295	; 0x50f
   84d14:	4806      	ldr	r0, [pc, #24]	; (84d30 <vTaskDelay+0x50>)
   84d16:	4b07      	ldr	r3, [pc, #28]	; (84d34 <vTaskDelay+0x54>)
   84d18:	4798      	blx	r3
   84d1a:	e7e7      	b.n	84cec <vTaskDelay+0xc>
   84d1c:	20075290 	.word	0x20075290
   84d20:	00084a59 	.word	0x00084a59
   84d24:	00084729 	.word	0x00084729
   84d28:	00084bc5 	.word	0x00084bc5
   84d2c:	e000ed04 	.word	0xe000ed04
   84d30:	000861dc 	.word	0x000861dc
   84d34:	00085861 	.word	0x00085861

00084d38 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   84d38:	4b31      	ldr	r3, [pc, #196]	; (84e00 <vTaskSwitchContext+0xc8>)
   84d3a:	681b      	ldr	r3, [r3, #0]
   84d3c:	b11b      	cbz	r3, 84d46 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
   84d3e:	2201      	movs	r2, #1
   84d40:	4b30      	ldr	r3, [pc, #192]	; (84e04 <vTaskSwitchContext+0xcc>)
   84d42:	601a      	str	r2, [r3, #0]
   84d44:	4770      	bx	lr
{
   84d46:	b510      	push	{r4, lr}
		xYieldPending = pdFALSE;
   84d48:	2200      	movs	r2, #0
   84d4a:	4b2e      	ldr	r3, [pc, #184]	; (84e04 <vTaskSwitchContext+0xcc>)
   84d4c:	601a      	str	r2, [r3, #0]
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   84d4e:	4b2e      	ldr	r3, [pc, #184]	; (84e08 <vTaskSwitchContext+0xd0>)
   84d50:	4798      	blx	r3
				if( ulTotalRunTime > ulTaskSwitchedInTime )
   84d52:	4b2e      	ldr	r3, [pc, #184]	; (84e0c <vTaskSwitchContext+0xd4>)
   84d54:	681a      	ldr	r2, [r3, #0]
   84d56:	4290      	cmp	r0, r2
   84d58:	d905      	bls.n	84d66 <vTaskSwitchContext+0x2e>
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   84d5a:	4b2d      	ldr	r3, [pc, #180]	; (84e10 <vTaskSwitchContext+0xd8>)
   84d5c:	6819      	ldr	r1, [r3, #0]
   84d5e:	6d0b      	ldr	r3, [r1, #80]	; 0x50
   84d60:	1a9b      	subs	r3, r3, r2
   84d62:	4403      	add	r3, r0
   84d64:	650b      	str	r3, [r1, #80]	; 0x50
				ulTaskSwitchedInTime = ulTotalRunTime;
   84d66:	4b29      	ldr	r3, [pc, #164]	; (84e0c <vTaskSwitchContext+0xd4>)
   84d68:	6018      	str	r0, [r3, #0]
		taskCHECK_FOR_STACK_OVERFLOW();
   84d6a:	4b29      	ldr	r3, [pc, #164]	; (84e10 <vTaskSwitchContext+0xd8>)
   84d6c:	681b      	ldr	r3, [r3, #0]
   84d6e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   84d70:	681a      	ldr	r2, [r3, #0]
   84d72:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   84d76:	d029      	beq.n	84dcc <vTaskSwitchContext+0x94>
   84d78:	4b25      	ldr	r3, [pc, #148]	; (84e10 <vTaskSwitchContext+0xd8>)
   84d7a:	6818      	ldr	r0, [r3, #0]
   84d7c:	6819      	ldr	r1, [r3, #0]
   84d7e:	3134      	adds	r1, #52	; 0x34
   84d80:	4b24      	ldr	r3, [pc, #144]	; (84e14 <vTaskSwitchContext+0xdc>)
   84d82:	4798      	blx	r3
		taskSELECT_HIGHEST_PRIORITY_TASK();
   84d84:	4b24      	ldr	r3, [pc, #144]	; (84e18 <vTaskSwitchContext+0xe0>)
   84d86:	681c      	ldr	r4, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
   84d88:	fab4 f484 	clz	r4, r4
   84d8c:	b2e4      	uxtb	r4, r4
   84d8e:	f1c4 041f 	rsb	r4, r4, #31
   84d92:	eb04 0384 	add.w	r3, r4, r4, lsl #2
   84d96:	009b      	lsls	r3, r3, #2
   84d98:	4a20      	ldr	r2, [pc, #128]	; (84e1c <vTaskSwitchContext+0xe4>)
   84d9a:	58d3      	ldr	r3, [r2, r3]
   84d9c:	b31b      	cbz	r3, 84de6 <vTaskSwitchContext+0xae>
   84d9e:	4b1f      	ldr	r3, [pc, #124]	; (84e1c <vTaskSwitchContext+0xe4>)
   84da0:	00a2      	lsls	r2, r4, #2
   84da2:	1911      	adds	r1, r2, r4
   84da4:	eb03 0181 	add.w	r1, r3, r1, lsl #2
   84da8:	6848      	ldr	r0, [r1, #4]
   84daa:	6840      	ldr	r0, [r0, #4]
   84dac:	6048      	str	r0, [r1, #4]
   84dae:	4422      	add	r2, r4
   84db0:	460b      	mov	r3, r1
   84db2:	3308      	adds	r3, #8
   84db4:	4298      	cmp	r0, r3
   84db6:	d01c      	beq.n	84df2 <vTaskSwitchContext+0xba>
   84db8:	eb04 0484 	add.w	r4, r4, r4, lsl #2
   84dbc:	4b17      	ldr	r3, [pc, #92]	; (84e1c <vTaskSwitchContext+0xe4>)
   84dbe:	eb03 0484 	add.w	r4, r3, r4, lsl #2
   84dc2:	6863      	ldr	r3, [r4, #4]
   84dc4:	68da      	ldr	r2, [r3, #12]
   84dc6:	4b12      	ldr	r3, [pc, #72]	; (84e10 <vTaskSwitchContext+0xd8>)
   84dc8:	601a      	str	r2, [r3, #0]
   84dca:	bd10      	pop	{r4, pc}
		taskCHECK_FOR_STACK_OVERFLOW();
   84dcc:	685a      	ldr	r2, [r3, #4]
   84dce:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   84dd2:	d1d1      	bne.n	84d78 <vTaskSwitchContext+0x40>
   84dd4:	689a      	ldr	r2, [r3, #8]
   84dd6:	f1b2 3fa5 	cmp.w	r2, #2779096485	; 0xa5a5a5a5
   84dda:	d1cd      	bne.n	84d78 <vTaskSwitchContext+0x40>
   84ddc:	68db      	ldr	r3, [r3, #12]
   84dde:	f1b3 3fa5 	cmp.w	r3, #2779096485	; 0xa5a5a5a5
   84de2:	d1c9      	bne.n	84d78 <vTaskSwitchContext+0x40>
   84de4:	e7ce      	b.n	84d84 <vTaskSwitchContext+0x4c>
		taskSELECT_HIGHEST_PRIORITY_TASK();
   84de6:	f44f 6135 	mov.w	r1, #2896	; 0xb50
   84dea:	480d      	ldr	r0, [pc, #52]	; (84e20 <vTaskSwitchContext+0xe8>)
   84dec:	4b0d      	ldr	r3, [pc, #52]	; (84e24 <vTaskSwitchContext+0xec>)
   84dee:	4798      	blx	r3
   84df0:	e7d5      	b.n	84d9e <vTaskSwitchContext+0x66>
   84df2:	6841      	ldr	r1, [r0, #4]
   84df4:	4613      	mov	r3, r2
   84df6:	4a09      	ldr	r2, [pc, #36]	; (84e1c <vTaskSwitchContext+0xe4>)
   84df8:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   84dfc:	6059      	str	r1, [r3, #4]
   84dfe:	e7db      	b.n	84db8 <vTaskSwitchContext+0x80>
   84e00:	20075290 	.word	0x20075290
   84e04:	20075314 	.word	0x20075314
   84e08:	00085a01 	.word	0x00085a01
   84e0c:	20075280 	.word	0x20075280
   84e10:	20075210 	.word	0x20075210
   84e14:	0008584f 	.word	0x0008584f
   84e18:	20075298 	.word	0x20075298
   84e1c:	2007521c 	.word	0x2007521c
   84e20:	000861dc 	.word	0x000861dc
   84e24:	00085861 	.word	0x00085861

00084e28 <vTaskPlaceOnEventList>:
{
   84e28:	b538      	push	{r3, r4, r5, lr}
   84e2a:	460c      	mov	r4, r1
	configASSERT( pxEventList );
   84e2c:	4605      	mov	r5, r0
   84e2e:	b150      	cbz	r0, 84e46 <vTaskPlaceOnEventList+0x1e>
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   84e30:	4b08      	ldr	r3, [pc, #32]	; (84e54 <vTaskPlaceOnEventList+0x2c>)
   84e32:	6819      	ldr	r1, [r3, #0]
   84e34:	3118      	adds	r1, #24
   84e36:	4628      	mov	r0, r5
   84e38:	4b07      	ldr	r3, [pc, #28]	; (84e58 <vTaskPlaceOnEventList+0x30>)
   84e3a:	4798      	blx	r3
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
   84e3c:	2101      	movs	r1, #1
   84e3e:	4620      	mov	r0, r4
   84e40:	4b06      	ldr	r3, [pc, #24]	; (84e5c <vTaskPlaceOnEventList+0x34>)
   84e42:	4798      	blx	r3
   84e44:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxEventList );
   84e46:	f44f 6136 	mov.w	r1, #2912	; 0xb60
   84e4a:	4805      	ldr	r0, [pc, #20]	; (84e60 <vTaskPlaceOnEventList+0x38>)
   84e4c:	4b05      	ldr	r3, [pc, #20]	; (84e64 <vTaskPlaceOnEventList+0x3c>)
   84e4e:	4798      	blx	r3
   84e50:	e7ee      	b.n	84e30 <vTaskPlaceOnEventList+0x8>
   84e52:	bf00      	nop
   84e54:	20075210 	.word	0x20075210
   84e58:	000838b9 	.word	0x000838b9
   84e5c:	00084729 	.word	0x00084729
   84e60:	000861dc 	.word	0x000861dc
   84e64:	00085861 	.word	0x00085861

00084e68 <vTaskPlaceOnEventListRestricted>:
	{
   84e68:	b570      	push	{r4, r5, r6, lr}
   84e6a:	460d      	mov	r5, r1
   84e6c:	4614      	mov	r4, r2
		configASSERT( pxEventList );
   84e6e:	4606      	mov	r6, r0
   84e70:	b170      	cbz	r0, 84e90 <vTaskPlaceOnEventListRestricted+0x28>
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   84e72:	4b0a      	ldr	r3, [pc, #40]	; (84e9c <vTaskPlaceOnEventListRestricted+0x34>)
   84e74:	6819      	ldr	r1, [r3, #0]
   84e76:	3118      	adds	r1, #24
   84e78:	4630      	mov	r0, r6
   84e7a:	4b09      	ldr	r3, [pc, #36]	; (84ea0 <vTaskPlaceOnEventListRestricted+0x38>)
   84e7c:	4798      	blx	r3
			xTicksToWait = portMAX_DELAY;
   84e7e:	2c00      	cmp	r4, #0
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
   84e80:	4621      	mov	r1, r4
   84e82:	bf0c      	ite	eq
   84e84:	4628      	moveq	r0, r5
   84e86:	f04f 30ff 	movne.w	r0, #4294967295
   84e8a:	4b06      	ldr	r3, [pc, #24]	; (84ea4 <vTaskPlaceOnEventListRestricted+0x3c>)
   84e8c:	4798      	blx	r3
   84e8e:	bd70      	pop	{r4, r5, r6, pc}
		configASSERT( pxEventList );
   84e90:	f640 318b 	movw	r1, #2955	; 0xb8b
   84e94:	4804      	ldr	r0, [pc, #16]	; (84ea8 <vTaskPlaceOnEventListRestricted+0x40>)
   84e96:	4b05      	ldr	r3, [pc, #20]	; (84eac <vTaskPlaceOnEventListRestricted+0x44>)
   84e98:	4798      	blx	r3
   84e9a:	e7ea      	b.n	84e72 <vTaskPlaceOnEventListRestricted+0xa>
   84e9c:	20075210 	.word	0x20075210
   84ea0:	000838a1 	.word	0x000838a1
   84ea4:	00084729 	.word	0x00084729
   84ea8:	000861dc 	.word	0x000861dc
   84eac:	00085861 	.word	0x00085861

00084eb0 <xTaskRemoveFromEventList>:
{
   84eb0:	b538      	push	{r3, r4, r5, lr}
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   84eb2:	68c3      	ldr	r3, [r0, #12]
   84eb4:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
   84eb6:	b32c      	cbz	r4, 84f04 <xTaskRemoveFromEventList+0x54>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   84eb8:	f104 0518 	add.w	r5, r4, #24
   84ebc:	4628      	mov	r0, r5
   84ebe:	4b17      	ldr	r3, [pc, #92]	; (84f1c <xTaskRemoveFromEventList+0x6c>)
   84ec0:	4798      	blx	r3
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   84ec2:	4b17      	ldr	r3, [pc, #92]	; (84f20 <xTaskRemoveFromEventList+0x70>)
   84ec4:	681b      	ldr	r3, [r3, #0]
   84ec6:	bb1b      	cbnz	r3, 84f10 <xTaskRemoveFromEventList+0x60>
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
   84ec8:	1d25      	adds	r5, r4, #4
   84eca:	4628      	mov	r0, r5
   84ecc:	4b13      	ldr	r3, [pc, #76]	; (84f1c <xTaskRemoveFromEventList+0x6c>)
   84ece:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
   84ed0:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   84ed2:	4a14      	ldr	r2, [pc, #80]	; (84f24 <xTaskRemoveFromEventList+0x74>)
   84ed4:	6811      	ldr	r1, [r2, #0]
   84ed6:	2301      	movs	r3, #1
   84ed8:	4083      	lsls	r3, r0
   84eda:	430b      	orrs	r3, r1
   84edc:	6013      	str	r3, [r2, #0]
   84ede:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   84ee2:	4629      	mov	r1, r5
   84ee4:	4b10      	ldr	r3, [pc, #64]	; (84f28 <xTaskRemoveFromEventList+0x78>)
   84ee6:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   84eea:	4b10      	ldr	r3, [pc, #64]	; (84f2c <xTaskRemoveFromEventList+0x7c>)
   84eec:	4798      	blx	r3
	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   84eee:	4b10      	ldr	r3, [pc, #64]	; (84f30 <xTaskRemoveFromEventList+0x80>)
   84ef0:	681b      	ldr	r3, [r3, #0]
   84ef2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   84ef4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   84ef6:	429a      	cmp	r2, r3
		xYieldPending = pdTRUE;
   84ef8:	bf83      	ittte	hi
   84efa:	2001      	movhi	r0, #1
   84efc:	4b0d      	ldrhi	r3, [pc, #52]	; (84f34 <xTaskRemoveFromEventList+0x84>)
   84efe:	6018      	strhi	r0, [r3, #0]
		xReturn = pdFALSE;
   84f00:	2000      	movls	r0, #0
}
   84f02:	bd38      	pop	{r3, r4, r5, pc}
	configASSERT( pxUnblockedTCB );
   84f04:	f640 31bb 	movw	r1, #3003	; 0xbbb
   84f08:	480b      	ldr	r0, [pc, #44]	; (84f38 <xTaskRemoveFromEventList+0x88>)
   84f0a:	4b0c      	ldr	r3, [pc, #48]	; (84f3c <xTaskRemoveFromEventList+0x8c>)
   84f0c:	4798      	blx	r3
   84f0e:	e7d3      	b.n	84eb8 <xTaskRemoveFromEventList+0x8>
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   84f10:	4629      	mov	r1, r5
   84f12:	480b      	ldr	r0, [pc, #44]	; (84f40 <xTaskRemoveFromEventList+0x90>)
   84f14:	4b05      	ldr	r3, [pc, #20]	; (84f2c <xTaskRemoveFromEventList+0x7c>)
   84f16:	4798      	blx	r3
   84f18:	e7e9      	b.n	84eee <xTaskRemoveFromEventList+0x3e>
   84f1a:	bf00      	nop
   84f1c:	000838ed 	.word	0x000838ed
   84f20:	20075290 	.word	0x20075290
   84f24:	20075298 	.word	0x20075298
   84f28:	2007521c 	.word	0x2007521c
   84f2c:	000838a1 	.word	0x000838a1
   84f30:	20075210 	.word	0x20075210
   84f34:	20075314 	.word	0x20075314
   84f38:	000861dc 	.word	0x000861dc
   84f3c:	00085861 	.word	0x00085861
   84f40:	200752d0 	.word	0x200752d0

00084f44 <vTaskSetTimeOutState>:
{
   84f44:	b510      	push	{r4, lr}
	configASSERT( pxTimeOut );
   84f46:	4604      	mov	r4, r0
   84f48:	b150      	cbz	r0, 84f60 <vTaskSetTimeOutState+0x1c>
	taskENTER_CRITICAL();
   84f4a:	4b08      	ldr	r3, [pc, #32]	; (84f6c <vTaskSetTimeOutState+0x28>)
   84f4c:	4798      	blx	r3
		pxTimeOut->xOverflowCount = xNumOfOverflows;
   84f4e:	4b08      	ldr	r3, [pc, #32]	; (84f70 <vTaskSetTimeOutState+0x2c>)
   84f50:	681b      	ldr	r3, [r3, #0]
   84f52:	6023      	str	r3, [r4, #0]
		pxTimeOut->xTimeOnEntering = xTickCount;
   84f54:	4b07      	ldr	r3, [pc, #28]	; (84f74 <vTaskSetTimeOutState+0x30>)
   84f56:	681b      	ldr	r3, [r3, #0]
   84f58:	6063      	str	r3, [r4, #4]
	taskEXIT_CRITICAL();
   84f5a:	4b07      	ldr	r3, [pc, #28]	; (84f78 <vTaskSetTimeOutState+0x34>)
   84f5c:	4798      	blx	r3
   84f5e:	bd10      	pop	{r4, pc}
	configASSERT( pxTimeOut );
   84f60:	f44f 6141 	mov.w	r1, #3088	; 0xc10
   84f64:	4805      	ldr	r0, [pc, #20]	; (84f7c <vTaskSetTimeOutState+0x38>)
   84f66:	4b06      	ldr	r3, [pc, #24]	; (84f80 <vTaskSetTimeOutState+0x3c>)
   84f68:	4798      	blx	r3
   84f6a:	e7ee      	b.n	84f4a <vTaskSetTimeOutState+0x6>
   84f6c:	000839c5 	.word	0x000839c5
   84f70:	200752cc 	.word	0x200752cc
   84f74:	20075310 	.word	0x20075310
   84f78:	00083a0d 	.word	0x00083a0d
   84f7c:	000861dc 	.word	0x000861dc
   84f80:	00085861 	.word	0x00085861

00084f84 <vTaskInternalSetTimeOutState>:
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   84f84:	4b03      	ldr	r3, [pc, #12]	; (84f94 <vTaskInternalSetTimeOutState+0x10>)
   84f86:	681b      	ldr	r3, [r3, #0]
   84f88:	6003      	str	r3, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   84f8a:	4b03      	ldr	r3, [pc, #12]	; (84f98 <vTaskInternalSetTimeOutState+0x14>)
   84f8c:	681b      	ldr	r3, [r3, #0]
   84f8e:	6043      	str	r3, [r0, #4]
   84f90:	4770      	bx	lr
   84f92:	bf00      	nop
   84f94:	200752cc 	.word	0x200752cc
   84f98:	20075310 	.word	0x20075310

00084f9c <xTaskCheckForTimeOut>:
{
   84f9c:	b570      	push	{r4, r5, r6, lr}
   84f9e:	460c      	mov	r4, r1
	configASSERT( pxTimeOut );
   84fa0:	4605      	mov	r5, r0
   84fa2:	b1d0      	cbz	r0, 84fda <xTaskCheckForTimeOut+0x3e>
	configASSERT( pxTicksToWait );
   84fa4:	b1fc      	cbz	r4, 84fe6 <xTaskCheckForTimeOut+0x4a>
	taskENTER_CRITICAL();
   84fa6:	4b18      	ldr	r3, [pc, #96]	; (85008 <xTaskCheckForTimeOut+0x6c>)
   84fa8:	4798      	blx	r3
		const TickType_t xConstTickCount = xTickCount;
   84faa:	4b18      	ldr	r3, [pc, #96]	; (8500c <xTaskCheckForTimeOut+0x70>)
   84fac:	681b      	ldr	r3, [r3, #0]
			if( *pxTicksToWait == portMAX_DELAY )
   84fae:	6822      	ldr	r2, [r4, #0]
   84fb0:	f1b2 3fff 	cmp.w	r2, #4294967295
   84fb4:	d024      	beq.n	85000 <xTaskCheckForTimeOut+0x64>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   84fb6:	6869      	ldr	r1, [r5, #4]
		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   84fb8:	4815      	ldr	r0, [pc, #84]	; (85010 <xTaskCheckForTimeOut+0x74>)
   84fba:	6800      	ldr	r0, [r0, #0]
   84fbc:	682e      	ldr	r6, [r5, #0]
   84fbe:	4286      	cmp	r6, r0
   84fc0:	d001      	beq.n	84fc6 <xTaskCheckForTimeOut+0x2a>
   84fc2:	428b      	cmp	r3, r1
   84fc4:	d21e      	bcs.n	85004 <xTaskCheckForTimeOut+0x68>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
   84fc6:	1a5b      	subs	r3, r3, r1
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
   84fc8:	4293      	cmp	r3, r2
   84fca:	d312      	bcc.n	84ff2 <xTaskCheckForTimeOut+0x56>
			*pxTicksToWait = 0;
   84fcc:	2300      	movs	r3, #0
   84fce:	6023      	str	r3, [r4, #0]
			xReturn = pdTRUE;
   84fd0:	2401      	movs	r4, #1
	taskEXIT_CRITICAL();
   84fd2:	4b10      	ldr	r3, [pc, #64]	; (85014 <xTaskCheckForTimeOut+0x78>)
   84fd4:	4798      	blx	r3
}
   84fd6:	4620      	mov	r0, r4
   84fd8:	bd70      	pop	{r4, r5, r6, pc}
	configASSERT( pxTimeOut );
   84fda:	f640 4126 	movw	r1, #3110	; 0xc26
   84fde:	480e      	ldr	r0, [pc, #56]	; (85018 <xTaskCheckForTimeOut+0x7c>)
   84fe0:	4b0e      	ldr	r3, [pc, #56]	; (8501c <xTaskCheckForTimeOut+0x80>)
   84fe2:	4798      	blx	r3
   84fe4:	e7de      	b.n	84fa4 <xTaskCheckForTimeOut+0x8>
	configASSERT( pxTicksToWait );
   84fe6:	f640 4127 	movw	r1, #3111	; 0xc27
   84fea:	480b      	ldr	r0, [pc, #44]	; (85018 <xTaskCheckForTimeOut+0x7c>)
   84fec:	4b0b      	ldr	r3, [pc, #44]	; (8501c <xTaskCheckForTimeOut+0x80>)
   84fee:	4798      	blx	r3
   84ff0:	e7d9      	b.n	84fa6 <xTaskCheckForTimeOut+0xa>
			*pxTicksToWait -= xElapsedTime;
   84ff2:	1ad3      	subs	r3, r2, r3
   84ff4:	6023      	str	r3, [r4, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
   84ff6:	4628      	mov	r0, r5
   84ff8:	4b09      	ldr	r3, [pc, #36]	; (85020 <xTaskCheckForTimeOut+0x84>)
   84ffa:	4798      	blx	r3
			xReturn = pdFALSE;
   84ffc:	2400      	movs	r4, #0
   84ffe:	e7e8      	b.n	84fd2 <xTaskCheckForTimeOut+0x36>
				xReturn = pdFALSE;
   85000:	2400      	movs	r4, #0
   85002:	e7e6      	b.n	84fd2 <xTaskCheckForTimeOut+0x36>
			xReturn = pdTRUE;
   85004:	2401      	movs	r4, #1
   85006:	e7e4      	b.n	84fd2 <xTaskCheckForTimeOut+0x36>
   85008:	000839c5 	.word	0x000839c5
   8500c:	20075310 	.word	0x20075310
   85010:	200752cc 	.word	0x200752cc
   85014:	00083a0d 	.word	0x00083a0d
   85018:	000861dc 	.word	0x000861dc
   8501c:	00085861 	.word	0x00085861
   85020:	00084f85 	.word	0x00084f85

00085024 <vTaskMissedYield>:
	xYieldPending = pdTRUE;
   85024:	2201      	movs	r2, #1
   85026:	4b01      	ldr	r3, [pc, #4]	; (8502c <vTaskMissedYield+0x8>)
   85028:	601a      	str	r2, [r3, #0]
   8502a:	4770      	bx	lr
   8502c:	20075314 	.word	0x20075314

00085030 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
   85030:	4b05      	ldr	r3, [pc, #20]	; (85048 <xTaskGetSchedulerState+0x18>)
   85032:	681b      	ldr	r3, [r3, #0]
   85034:	b133      	cbz	r3, 85044 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   85036:	4b05      	ldr	r3, [pc, #20]	; (8504c <xTaskGetSchedulerState+0x1c>)
   85038:	681b      	ldr	r3, [r3, #0]
				xReturn = taskSCHEDULER_SUSPENDED;
   8503a:	2b00      	cmp	r3, #0
   8503c:	bf0c      	ite	eq
   8503e:	2002      	moveq	r0, #2
   85040:	2000      	movne	r0, #0
   85042:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
   85044:	2001      	movs	r0, #1
	}
   85046:	4770      	bx	lr
   85048:	200752e4 	.word	0x200752e4
   8504c:	20075290 	.word	0x20075290

00085050 <xTaskPriorityInherit>:
		if( pxMutexHolder != NULL )
   85050:	2800      	cmp	r0, #0
   85052:	d050      	beq.n	850f6 <xTaskPriorityInherit+0xa6>
	{
   85054:	b538      	push	{r3, r4, r5, lr}
   85056:	4604      	mov	r4, r0
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
   85058:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
   8505a:	4928      	ldr	r1, [pc, #160]	; (850fc <xTaskPriorityInherit+0xac>)
   8505c:	6809      	ldr	r1, [r1, #0]
   8505e:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   85060:	428a      	cmp	r2, r1
   85062:	d23f      	bcs.n	850e4 <xTaskPriorityInherit+0x94>
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   85064:	6981      	ldr	r1, [r0, #24]
   85066:	2900      	cmp	r1, #0
   85068:	db05      	blt.n	85076 <xTaskPriorityInherit+0x26>
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8506a:	4924      	ldr	r1, [pc, #144]	; (850fc <xTaskPriorityInherit+0xac>)
   8506c:	6809      	ldr	r1, [r1, #0]
   8506e:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
   85070:	f1c1 0105 	rsb	r1, r1, #5
   85074:	6181      	str	r1, [r0, #24]
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
   85076:	eb02 0282 	add.w	r2, r2, r2, lsl #2
   8507a:	4921      	ldr	r1, [pc, #132]	; (85100 <xTaskPriorityInherit+0xb0>)
   8507c:	eb01 0282 	add.w	r2, r1, r2, lsl #2
   85080:	6961      	ldr	r1, [r4, #20]
   85082:	4291      	cmp	r1, r2
   85084:	d005      	beq.n	85092 <xTaskPriorityInherit+0x42>
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   85086:	4a1d      	ldr	r2, [pc, #116]	; (850fc <xTaskPriorityInherit+0xac>)
   85088:	6812      	ldr	r2, [r2, #0]
   8508a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
   8508c:	62e2      	str	r2, [r4, #44]	; 0x2c
				xReturn = pdTRUE;
   8508e:	2001      	movs	r0, #1
   85090:	bd38      	pop	{r3, r4, r5, pc}
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   85092:	1d25      	adds	r5, r4, #4
   85094:	4628      	mov	r0, r5
   85096:	4b1b      	ldr	r3, [pc, #108]	; (85104 <xTaskPriorityInherit+0xb4>)
   85098:	4798      	blx	r3
   8509a:	b970      	cbnz	r0, 850ba <xTaskPriorityInherit+0x6a>
						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
   8509c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   8509e:	eb02 0382 	add.w	r3, r2, r2, lsl #2
   850a2:	009b      	lsls	r3, r3, #2
   850a4:	4916      	ldr	r1, [pc, #88]	; (85100 <xTaskPriorityInherit+0xb0>)
   850a6:	58cb      	ldr	r3, [r1, r3]
   850a8:	b93b      	cbnz	r3, 850ba <xTaskPriorityInherit+0x6a>
   850aa:	4817      	ldr	r0, [pc, #92]	; (85108 <xTaskPriorityInherit+0xb8>)
   850ac:	6803      	ldr	r3, [r0, #0]
   850ae:	2101      	movs	r1, #1
   850b0:	fa01 f202 	lsl.w	r2, r1, r2
   850b4:	ea23 0202 	bic.w	r2, r3, r2
   850b8:	6002      	str	r2, [r0, #0]
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
   850ba:	4b10      	ldr	r3, [pc, #64]	; (850fc <xTaskPriorityInherit+0xac>)
   850bc:	681b      	ldr	r3, [r3, #0]
   850be:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
   850c0:	62e0      	str	r0, [r4, #44]	; 0x2c
					prvAddTaskToReadyList( pxMutexHolderTCB );
   850c2:	4a11      	ldr	r2, [pc, #68]	; (85108 <xTaskPriorityInherit+0xb8>)
   850c4:	6811      	ldr	r1, [r2, #0]
   850c6:	2401      	movs	r4, #1
   850c8:	fa04 f300 	lsl.w	r3, r4, r0
   850cc:	430b      	orrs	r3, r1
   850ce:	6013      	str	r3, [r2, #0]
   850d0:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   850d4:	4629      	mov	r1, r5
   850d6:	4b0a      	ldr	r3, [pc, #40]	; (85100 <xTaskPriorityInherit+0xb0>)
   850d8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   850dc:	4b0b      	ldr	r3, [pc, #44]	; (8510c <xTaskPriorityInherit+0xbc>)
   850de:	4798      	blx	r3
				xReturn = pdTRUE;
   850e0:	4620      	mov	r0, r4
   850e2:	bd38      	pop	{r3, r4, r5, pc}
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
   850e4:	4a05      	ldr	r2, [pc, #20]	; (850fc <xTaskPriorityInherit+0xac>)
   850e6:	6812      	ldr	r2, [r2, #0]
   850e8:	6c80      	ldr	r0, [r0, #72]	; 0x48
   850ea:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
   850ec:	4298      	cmp	r0, r3
   850ee:	bf2c      	ite	cs
   850f0:	2000      	movcs	r0, #0
   850f2:	2001      	movcc	r0, #1
   850f4:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t xReturn = pdFALSE;
   850f6:	2000      	movs	r0, #0
		return xReturn;
   850f8:	4770      	bx	lr
   850fa:	bf00      	nop
   850fc:	20075210 	.word	0x20075210
   85100:	2007521c 	.word	0x2007521c
   85104:	000838ed 	.word	0x000838ed
   85108:	20075298 	.word	0x20075298
   8510c:	000838a1 	.word	0x000838a1

00085110 <xTaskPriorityDisinherit>:
		if( pxMutexHolder != NULL )
   85110:	2800      	cmp	r0, #0
   85112:	d046      	beq.n	851a2 <xTaskPriorityDisinherit+0x92>
	{
   85114:	b538      	push	{r3, r4, r5, lr}
   85116:	4604      	mov	r4, r0
			configASSERT( pxTCB == pxCurrentTCB );
   85118:	4b24      	ldr	r3, [pc, #144]	; (851ac <xTaskPriorityDisinherit+0x9c>)
   8511a:	681b      	ldr	r3, [r3, #0]
   8511c:	4298      	cmp	r0, r3
   8511e:	d004      	beq.n	8512a <xTaskPriorityDisinherit+0x1a>
   85120:	f640 713b 	movw	r1, #3899	; 0xf3b
   85124:	4822      	ldr	r0, [pc, #136]	; (851b0 <xTaskPriorityDisinherit+0xa0>)
   85126:	4b23      	ldr	r3, [pc, #140]	; (851b4 <xTaskPriorityDisinherit+0xa4>)
   85128:	4798      	blx	r3
			configASSERT( pxTCB->uxMutexesHeld );
   8512a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   8512c:	b14b      	cbz	r3, 85142 <xTaskPriorityDisinherit+0x32>
			( pxTCB->uxMutexesHeld )--;
   8512e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   85130:	3b01      	subs	r3, #1
   85132:	64e3      	str	r3, [r4, #76]	; 0x4c
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   85134:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
   85136:	6ca2      	ldr	r2, [r4, #72]	; 0x48
   85138:	4291      	cmp	r1, r2
   8513a:	d034      	beq.n	851a6 <xTaskPriorityDisinherit+0x96>
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   8513c:	b13b      	cbz	r3, 8514e <xTaskPriorityDisinherit+0x3e>
	BaseType_t xReturn = pdFALSE;
   8513e:	2000      	movs	r0, #0
	}
   85140:	bd38      	pop	{r3, r4, r5, pc}
			configASSERT( pxTCB->uxMutexesHeld );
   85142:	f640 713c 	movw	r1, #3900	; 0xf3c
   85146:	481a      	ldr	r0, [pc, #104]	; (851b0 <xTaskPriorityDisinherit+0xa0>)
   85148:	4b1a      	ldr	r3, [pc, #104]	; (851b4 <xTaskPriorityDisinherit+0xa4>)
   8514a:	4798      	blx	r3
   8514c:	e7ef      	b.n	8512e <xTaskPriorityDisinherit+0x1e>
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   8514e:	1d25      	adds	r5, r4, #4
   85150:	4628      	mov	r0, r5
   85152:	4b19      	ldr	r3, [pc, #100]	; (851b8 <xTaskPriorityDisinherit+0xa8>)
   85154:	4798      	blx	r3
   85156:	b970      	cbnz	r0, 85176 <xTaskPriorityDisinherit+0x66>
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   85158:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   8515a:	eb02 0382 	add.w	r3, r2, r2, lsl #2
   8515e:	009b      	lsls	r3, r3, #2
   85160:	4916      	ldr	r1, [pc, #88]	; (851bc <xTaskPriorityDisinherit+0xac>)
   85162:	58cb      	ldr	r3, [r1, r3]
   85164:	b93b      	cbnz	r3, 85176 <xTaskPriorityDisinherit+0x66>
   85166:	4816      	ldr	r0, [pc, #88]	; (851c0 <xTaskPriorityDisinherit+0xb0>)
   85168:	6803      	ldr	r3, [r0, #0]
   8516a:	2101      	movs	r1, #1
   8516c:	fa01 f202 	lsl.w	r2, r1, r2
   85170:	ea23 0202 	bic.w	r2, r3, r2
   85174:	6002      	str	r2, [r0, #0]
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   85176:	6ca0      	ldr	r0, [r4, #72]	; 0x48
   85178:	62e0      	str	r0, [r4, #44]	; 0x2c
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   8517a:	f1c0 0305 	rsb	r3, r0, #5
   8517e:	61a3      	str	r3, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
   85180:	4a0f      	ldr	r2, [pc, #60]	; (851c0 <xTaskPriorityDisinherit+0xb0>)
   85182:	6811      	ldr	r1, [r2, #0]
   85184:	2401      	movs	r4, #1
   85186:	fa04 f300 	lsl.w	r3, r4, r0
   8518a:	430b      	orrs	r3, r1
   8518c:	6013      	str	r3, [r2, #0]
   8518e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   85192:	4629      	mov	r1, r5
   85194:	4b09      	ldr	r3, [pc, #36]	; (851bc <xTaskPriorityDisinherit+0xac>)
   85196:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   8519a:	4b0a      	ldr	r3, [pc, #40]	; (851c4 <xTaskPriorityDisinherit+0xb4>)
   8519c:	4798      	blx	r3
					xReturn = pdTRUE;
   8519e:	4620      	mov	r0, r4
   851a0:	bd38      	pop	{r3, r4, r5, pc}
	BaseType_t xReturn = pdFALSE;
   851a2:	2000      	movs	r0, #0
   851a4:	4770      	bx	lr
   851a6:	2000      	movs	r0, #0
   851a8:	bd38      	pop	{r3, r4, r5, pc}
   851aa:	bf00      	nop
   851ac:	20075210 	.word	0x20075210
   851b0:	000861dc 	.word	0x000861dc
   851b4:	00085861 	.word	0x00085861
   851b8:	000838ed 	.word	0x000838ed
   851bc:	2007521c 	.word	0x2007521c
   851c0:	20075298 	.word	0x20075298
   851c4:	000838a1 	.word	0x000838a1

000851c8 <vTaskPriorityDisinheritAfterTimeout>:
		if( pxMutexHolder != NULL )
   851c8:	2800      	cmp	r0, #0
   851ca:	d053      	beq.n	85274 <vTaskPriorityDisinheritAfterTimeout+0xac>
	{
   851cc:	b538      	push	{r3, r4, r5, lr}
   851ce:	4604      	mov	r4, r0
   851d0:	460d      	mov	r5, r1
			configASSERT( pxTCB->uxMutexesHeld );
   851d2:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
   851d4:	b153      	cbz	r3, 851ec <vTaskPriorityDisinheritAfterTimeout+0x24>
   851d6:	6ca1      	ldr	r1, [r4, #72]	; 0x48
   851d8:	428d      	cmp	r5, r1
   851da:	bf38      	it	cc
   851dc:	460d      	movcc	r5, r1
			if( pxTCB->uxPriority != uxPriorityToUse )
   851de:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
   851e0:	42ab      	cmp	r3, r5
   851e2:	d002      	beq.n	851ea <vTaskPriorityDisinheritAfterTimeout+0x22>
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
   851e4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
   851e6:	2b01      	cmp	r3, #1
   851e8:	d006      	beq.n	851f8 <vTaskPriorityDisinheritAfterTimeout+0x30>
   851ea:	bd38      	pop	{r3, r4, r5, pc}
			configASSERT( pxTCB->uxMutexesHeld );
   851ec:	f640 718a 	movw	r1, #3978	; 0xf8a
   851f0:	4821      	ldr	r0, [pc, #132]	; (85278 <vTaskPriorityDisinheritAfterTimeout+0xb0>)
   851f2:	4b22      	ldr	r3, [pc, #136]	; (8527c <vTaskPriorityDisinheritAfterTimeout+0xb4>)
   851f4:	4798      	blx	r3
   851f6:	e7ee      	b.n	851d6 <vTaskPriorityDisinheritAfterTimeout+0xe>
					configASSERT( pxTCB != pxCurrentTCB );
   851f8:	4b21      	ldr	r3, [pc, #132]	; (85280 <vTaskPriorityDisinheritAfterTimeout+0xb8>)
   851fa:	681b      	ldr	r3, [r3, #0]
   851fc:	429c      	cmp	r4, r3
   851fe:	d033      	beq.n	85268 <vTaskPriorityDisinheritAfterTimeout+0xa0>
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
   85200:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
					pxTCB->uxPriority = uxPriorityToUse;
   85202:	62e5      	str	r5, [r4, #44]	; 0x2c
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   85204:	69a2      	ldr	r2, [r4, #24]
   85206:	2a00      	cmp	r2, #0
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   85208:	bfa4      	itt	ge
   8520a:	f1c5 0505 	rsbge	r5, r5, #5
   8520e:	61a5      	strge	r5, [r4, #24]
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
   85210:	eb03 0383 	add.w	r3, r3, r3, lsl #2
   85214:	4a1b      	ldr	r2, [pc, #108]	; (85284 <vTaskPriorityDisinheritAfterTimeout+0xbc>)
   85216:	eb02 0383 	add.w	r3, r2, r3, lsl #2
   8521a:	6962      	ldr	r2, [r4, #20]
   8521c:	429a      	cmp	r2, r3
   8521e:	d1e4      	bne.n	851ea <vTaskPriorityDisinheritAfterTimeout+0x22>
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
   85220:	1d25      	adds	r5, r4, #4
   85222:	4628      	mov	r0, r5
   85224:	4b18      	ldr	r3, [pc, #96]	; (85288 <vTaskPriorityDisinheritAfterTimeout+0xc0>)
   85226:	4798      	blx	r3
   85228:	b970      	cbnz	r0, 85248 <vTaskPriorityDisinheritAfterTimeout+0x80>
							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   8522a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
   8522c:	eb02 0382 	add.w	r3, r2, r2, lsl #2
   85230:	009b      	lsls	r3, r3, #2
   85232:	4914      	ldr	r1, [pc, #80]	; (85284 <vTaskPriorityDisinheritAfterTimeout+0xbc>)
   85234:	58cb      	ldr	r3, [r1, r3]
   85236:	b93b      	cbnz	r3, 85248 <vTaskPriorityDisinheritAfterTimeout+0x80>
   85238:	4814      	ldr	r0, [pc, #80]	; (8528c <vTaskPriorityDisinheritAfterTimeout+0xc4>)
   8523a:	6803      	ldr	r3, [r0, #0]
   8523c:	2101      	movs	r1, #1
   8523e:	fa01 f202 	lsl.w	r2, r1, r2
   85242:	ea23 0202 	bic.w	r2, r3, r2
   85246:	6002      	str	r2, [r0, #0]
						prvAddTaskToReadyList( pxTCB );
   85248:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
   8524a:	4a10      	ldr	r2, [pc, #64]	; (8528c <vTaskPriorityDisinheritAfterTimeout+0xc4>)
   8524c:	6811      	ldr	r1, [r2, #0]
   8524e:	2301      	movs	r3, #1
   85250:	4083      	lsls	r3, r0
   85252:	430b      	orrs	r3, r1
   85254:	6013      	str	r3, [r2, #0]
   85256:	eb00 0080 	add.w	r0, r0, r0, lsl #2
   8525a:	4629      	mov	r1, r5
   8525c:	4b09      	ldr	r3, [pc, #36]	; (85284 <vTaskPriorityDisinheritAfterTimeout+0xbc>)
   8525e:	eb03 0080 	add.w	r0, r3, r0, lsl #2
   85262:	4b0b      	ldr	r3, [pc, #44]	; (85290 <vTaskPriorityDisinheritAfterTimeout+0xc8>)
   85264:	4798      	blx	r3
	}
   85266:	e7c0      	b.n	851ea <vTaskPriorityDisinheritAfterTimeout+0x22>
					configASSERT( pxTCB != pxCurrentTCB );
   85268:	f640 71a5 	movw	r1, #4005	; 0xfa5
   8526c:	4802      	ldr	r0, [pc, #8]	; (85278 <vTaskPriorityDisinheritAfterTimeout+0xb0>)
   8526e:	4b03      	ldr	r3, [pc, #12]	; (8527c <vTaskPriorityDisinheritAfterTimeout+0xb4>)
   85270:	4798      	blx	r3
   85272:	e7c5      	b.n	85200 <vTaskPriorityDisinheritAfterTimeout+0x38>
   85274:	4770      	bx	lr
   85276:	bf00      	nop
   85278:	000861dc 	.word	0x000861dc
   8527c:	00085861 	.word	0x00085861
   85280:	20075210 	.word	0x20075210
   85284:	2007521c 	.word	0x2007521c
   85288:	000838ed 	.word	0x000838ed
   8528c:	20075298 	.word	0x20075298
   85290:	000838a1 	.word	0x000838a1

00085294 <pvTaskIncrementMutexHeldCount>:
		if( pxCurrentTCB != NULL )
   85294:	4b05      	ldr	r3, [pc, #20]	; (852ac <pvTaskIncrementMutexHeldCount+0x18>)
   85296:	681b      	ldr	r3, [r3, #0]
   85298:	b123      	cbz	r3, 852a4 <pvTaskIncrementMutexHeldCount+0x10>
			( pxCurrentTCB->uxMutexesHeld )++;
   8529a:	4b04      	ldr	r3, [pc, #16]	; (852ac <pvTaskIncrementMutexHeldCount+0x18>)
   8529c:	681a      	ldr	r2, [r3, #0]
   8529e:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
   852a0:	3301      	adds	r3, #1
   852a2:	64d3      	str	r3, [r2, #76]	; 0x4c
		return pxCurrentTCB;
   852a4:	4b01      	ldr	r3, [pc, #4]	; (852ac <pvTaskIncrementMutexHeldCount+0x18>)
   852a6:	6818      	ldr	r0, [r3, #0]
	}
   852a8:	4770      	bx	lr
   852aa:	bf00      	nop
   852ac:	20075210 	.word	0x20075210

000852b0 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
   852b0:	b508      	push	{r3, lr}
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   852b2:	6041      	str	r1, [r0, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   852b4:	6100      	str	r0, [r0, #16]

	if( xNextExpiryTime <= xTimeNow )
   852b6:	4291      	cmp	r1, r2
   852b8:	d80c      	bhi.n	852d4 <prvInsertTimerInActiveList+0x24>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   852ba:	1ad2      	subs	r2, r2, r3
   852bc:	6983      	ldr	r3, [r0, #24]
   852be:	429a      	cmp	r2, r3
   852c0:	d301      	bcc.n	852c6 <prvInsertTimerInActiveList+0x16>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   852c2:	2001      	movs	r0, #1
   852c4:	bd08      	pop	{r3, pc}
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   852c6:	1d01      	adds	r1, r0, #4
   852c8:	4b09      	ldr	r3, [pc, #36]	; (852f0 <prvInsertTimerInActiveList+0x40>)
   852ca:	6818      	ldr	r0, [r3, #0]
   852cc:	4b09      	ldr	r3, [pc, #36]	; (852f4 <prvInsertTimerInActiveList+0x44>)
   852ce:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
   852d0:	2000      	movs	r0, #0
   852d2:	bd08      	pop	{r3, pc}
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   852d4:	429a      	cmp	r2, r3
   852d6:	d201      	bcs.n	852dc <prvInsertTimerInActiveList+0x2c>
   852d8:	4299      	cmp	r1, r3
   852da:	d206      	bcs.n	852ea <prvInsertTimerInActiveList+0x3a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   852dc:	1d01      	adds	r1, r0, #4
   852de:	4b06      	ldr	r3, [pc, #24]	; (852f8 <prvInsertTimerInActiveList+0x48>)
   852e0:	6818      	ldr	r0, [r3, #0]
   852e2:	4b04      	ldr	r3, [pc, #16]	; (852f4 <prvInsertTimerInActiveList+0x44>)
   852e4:	4798      	blx	r3
BaseType_t xProcessTimerNow = pdFALSE;
   852e6:	2000      	movs	r0, #0
   852e8:	bd08      	pop	{r3, pc}
			xProcessTimerNow = pdTRUE;
   852ea:	2001      	movs	r0, #1
		}
	}

	return xProcessTimerNow;
}
   852ec:	bd08      	pop	{r3, pc}
   852ee:	bf00      	nop
   852f0:	2007531c 	.word	0x2007531c
   852f4:	000838b9 	.word	0x000838b9
   852f8:	20075318 	.word	0x20075318

000852fc <prvCheckForValidListAndQueue>:
	pxOverflowTimerList = pxTemp;
}
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   852fc:	b570      	push	{r4, r5, r6, lr}
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   852fe:	4b10      	ldr	r3, [pc, #64]	; (85340 <prvCheckForValidListAndQueue+0x44>)
   85300:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
   85302:	4b10      	ldr	r3, [pc, #64]	; (85344 <prvCheckForValidListAndQueue+0x48>)
   85304:	681b      	ldr	r3, [r3, #0]
   85306:	b113      	cbz	r3, 8530e <prvCheckForValidListAndQueue+0x12>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   85308:	4b0f      	ldr	r3, [pc, #60]	; (85348 <prvCheckForValidListAndQueue+0x4c>)
   8530a:	4798      	blx	r3
   8530c:	bd70      	pop	{r4, r5, r6, pc}
			vListInitialise( &xActiveTimerList1 );
   8530e:	4d0f      	ldr	r5, [pc, #60]	; (8534c <prvCheckForValidListAndQueue+0x50>)
   85310:	4628      	mov	r0, r5
   85312:	4e0f      	ldr	r6, [pc, #60]	; (85350 <prvCheckForValidListAndQueue+0x54>)
   85314:	47b0      	blx	r6
			vListInitialise( &xActiveTimerList2 );
   85316:	4c0f      	ldr	r4, [pc, #60]	; (85354 <prvCheckForValidListAndQueue+0x58>)
   85318:	4620      	mov	r0, r4
   8531a:	47b0      	blx	r6
			pxCurrentTimerList = &xActiveTimerList1;
   8531c:	4b0e      	ldr	r3, [pc, #56]	; (85358 <prvCheckForValidListAndQueue+0x5c>)
   8531e:	601d      	str	r5, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   85320:	4b0e      	ldr	r3, [pc, #56]	; (8535c <prvCheckForValidListAndQueue+0x60>)
   85322:	601c      	str	r4, [r3, #0]
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   85324:	2200      	movs	r2, #0
   85326:	210c      	movs	r1, #12
   85328:	2005      	movs	r0, #5
   8532a:	4b0d      	ldr	r3, [pc, #52]	; (85360 <prvCheckForValidListAndQueue+0x64>)
   8532c:	4798      	blx	r3
   8532e:	4b05      	ldr	r3, [pc, #20]	; (85344 <prvCheckForValidListAndQueue+0x48>)
   85330:	6018      	str	r0, [r3, #0]
				if( xTimerQueue != NULL )
   85332:	2800      	cmp	r0, #0
   85334:	d0e8      	beq.n	85308 <prvCheckForValidListAndQueue+0xc>
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
   85336:	490b      	ldr	r1, [pc, #44]	; (85364 <prvCheckForValidListAndQueue+0x68>)
   85338:	4b0b      	ldr	r3, [pc, #44]	; (85368 <prvCheckForValidListAndQueue+0x6c>)
   8533a:	4798      	blx	r3
   8533c:	e7e4      	b.n	85308 <prvCheckForValidListAndQueue+0xc>
   8533e:	bf00      	nop
   85340:	000839c5 	.word	0x000839c5
   85344:	2007534c 	.word	0x2007534c
   85348:	00083a0d 	.word	0x00083a0d
   8534c:	20075320 	.word	0x20075320
   85350:	00083885 	.word	0x00083885
   85354:	20075334 	.word	0x20075334
   85358:	20075318 	.word	0x20075318
   8535c:	2007531c 	.word	0x2007531c
   85360:	00083e99 	.word	0x00083e99
   85364:	00086224 	.word	0x00086224
   85368:	000845ed 	.word	0x000845ed

0008536c <xTimerCreateTimerTask>:
{
   8536c:	b510      	push	{r4, lr}
   8536e:	b082      	sub	sp, #8
	prvCheckForValidListAndQueue();
   85370:	4b0d      	ldr	r3, [pc, #52]	; (853a8 <xTimerCreateTimerTask+0x3c>)
   85372:	4798      	blx	r3
	if( xTimerQueue != NULL )
   85374:	4b0d      	ldr	r3, [pc, #52]	; (853ac <xTimerCreateTimerTask+0x40>)
   85376:	681b      	ldr	r3, [r3, #0]
   85378:	b17b      	cbz	r3, 8539a <xTimerCreateTimerTask+0x2e>
			xReturn = xTaskCreate(	prvTimerTask,
   8537a:	4b0d      	ldr	r3, [pc, #52]	; (853b0 <xTimerCreateTimerTask+0x44>)
   8537c:	9301      	str	r3, [sp, #4]
   8537e:	2304      	movs	r3, #4
   85380:	9300      	str	r3, [sp, #0]
   85382:	2300      	movs	r3, #0
   85384:	f44f 72a0 	mov.w	r2, #320	; 0x140
   85388:	490a      	ldr	r1, [pc, #40]	; (853b4 <xTimerCreateTimerTask+0x48>)
   8538a:	480b      	ldr	r0, [pc, #44]	; (853b8 <xTimerCreateTimerTask+0x4c>)
   8538c:	4c0b      	ldr	r4, [pc, #44]	; (853bc <xTimerCreateTimerTask+0x50>)
   8538e:	47a0      	blx	r4
	configASSERT( xReturn );
   85390:	4603      	mov	r3, r0
   85392:	b110      	cbz	r0, 8539a <xTimerCreateTimerTask+0x2e>
}
   85394:	4618      	mov	r0, r3
   85396:	b002      	add	sp, #8
   85398:	bd10      	pop	{r4, pc}
	configASSERT( xReturn );
   8539a:	f44f 7188 	mov.w	r1, #272	; 0x110
   8539e:	4808      	ldr	r0, [pc, #32]	; (853c0 <xTimerCreateTimerTask+0x54>)
   853a0:	4b08      	ldr	r3, [pc, #32]	; (853c4 <xTimerCreateTimerTask+0x58>)
   853a2:	4798      	blx	r3
   853a4:	2300      	movs	r3, #0
	return xReturn;
   853a6:	e7f5      	b.n	85394 <xTimerCreateTimerTask+0x28>
   853a8:	000852fd 	.word	0x000852fd
   853ac:	2007534c 	.word	0x2007534c
   853b0:	20075350 	.word	0x20075350
   853b4:	0008622c 	.word	0x0008622c
   853b8:	000854f1 	.word	0x000854f1
   853bc:	000847cd 	.word	0x000847cd
   853c0:	00086234 	.word	0x00086234
   853c4:	00085861 	.word	0x00085861

000853c8 <xTimerGenericCommand>:
{
   853c8:	b5f0      	push	{r4, r5, r6, r7, lr}
   853ca:	b085      	sub	sp, #20
   853cc:	460c      	mov	r4, r1
   853ce:	4616      	mov	r6, r2
   853d0:	461f      	mov	r7, r3
	configASSERT( xTimer );
   853d2:	4605      	mov	r5, r0
   853d4:	b1b0      	cbz	r0, 85404 <xTimerGenericCommand+0x3c>
	if( xTimerQueue != NULL )
   853d6:	4b12      	ldr	r3, [pc, #72]	; (85420 <xTimerGenericCommand+0x58>)
   853d8:	6818      	ldr	r0, [r3, #0]
   853da:	b1f8      	cbz	r0, 8541c <xTimerGenericCommand+0x54>
		xMessage.xMessageID = xCommandID;
   853dc:	9401      	str	r4, [sp, #4]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   853de:	9602      	str	r6, [sp, #8]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
   853e0:	9503      	str	r5, [sp, #12]
		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   853e2:	2c05      	cmp	r4, #5
   853e4:	dc14      	bgt.n	85410 <xTimerGenericCommand+0x48>
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   853e6:	4b0f      	ldr	r3, [pc, #60]	; (85424 <xTimerGenericCommand+0x5c>)
   853e8:	4798      	blx	r3
   853ea:	2802      	cmp	r0, #2
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   853ec:	f04f 0300 	mov.w	r3, #0
   853f0:	bf0c      	ite	eq
   853f2:	9a0a      	ldreq	r2, [sp, #40]	; 0x28
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   853f4:	461a      	movne	r2, r3
   853f6:	a901      	add	r1, sp, #4
   853f8:	4809      	ldr	r0, [pc, #36]	; (85420 <xTimerGenericCommand+0x58>)
   853fa:	6800      	ldr	r0, [r0, #0]
   853fc:	4c0a      	ldr	r4, [pc, #40]	; (85428 <xTimerGenericCommand+0x60>)
   853fe:	47a0      	blx	r4
}
   85400:	b005      	add	sp, #20
   85402:	bdf0      	pop	{r4, r5, r6, r7, pc}
	configASSERT( xTimer );
   85404:	f240 1183 	movw	r1, #387	; 0x183
   85408:	4808      	ldr	r0, [pc, #32]	; (8542c <xTimerGenericCommand+0x64>)
   8540a:	4b09      	ldr	r3, [pc, #36]	; (85430 <xTimerGenericCommand+0x68>)
   8540c:	4798      	blx	r3
   8540e:	e7e2      	b.n	853d6 <xTimerGenericCommand+0xe>
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   85410:	2300      	movs	r3, #0
   85412:	463a      	mov	r2, r7
   85414:	a901      	add	r1, sp, #4
   85416:	4c07      	ldr	r4, [pc, #28]	; (85434 <xTimerGenericCommand+0x6c>)
   85418:	47a0      	blx	r4
   8541a:	e7f1      	b.n	85400 <xTimerGenericCommand+0x38>
BaseType_t xReturn = pdFAIL;
   8541c:	2000      	movs	r0, #0
	return xReturn;
   8541e:	e7ef      	b.n	85400 <xTimerGenericCommand+0x38>
   85420:	2007534c 	.word	0x2007534c
   85424:	00085031 	.word	0x00085031
   85428:	00083f31 	.word	0x00083f31
   8542c:	00086234 	.word	0x00086234
   85430:	00085861 	.word	0x00085861
   85434:	00084109 	.word	0x00084109

00085438 <prvSampleTimeNow>:
{
   85438:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   8543c:	b082      	sub	sp, #8
   8543e:	4680      	mov	r8, r0
	xTimeNow = xTaskGetTickCount();
   85440:	4b22      	ldr	r3, [pc, #136]	; (854cc <prvSampleTimeNow+0x94>)
   85442:	4798      	blx	r3
   85444:	4607      	mov	r7, r0
	if( xTimeNow < xLastTime )
   85446:	4b22      	ldr	r3, [pc, #136]	; (854d0 <prvSampleTimeNow+0x98>)
   85448:	681b      	ldr	r3, [r3, #0]
   8544a:	4298      	cmp	r0, r3
   8544c:	d316      	bcc.n	8547c <prvSampleTimeNow+0x44>
		*pxTimerListsWereSwitched = pdFALSE;
   8544e:	2300      	movs	r3, #0
   85450:	f8c8 3000 	str.w	r3, [r8]
	xLastTime = xTimeNow;
   85454:	4b1e      	ldr	r3, [pc, #120]	; (854d0 <prvSampleTimeNow+0x98>)
   85456:	601f      	str	r7, [r3, #0]
}
   85458:	4638      	mov	r0, r7
   8545a:	b002      	add	sp, #8
   8545c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   85460:	2100      	movs	r1, #0
   85462:	9100      	str	r1, [sp, #0]
   85464:	460b      	mov	r3, r1
   85466:	4652      	mov	r2, sl
   85468:	4620      	mov	r0, r4
   8546a:	4c1a      	ldr	r4, [pc, #104]	; (854d4 <prvSampleTimeNow+0x9c>)
   8546c:	47a0      	blx	r4
				configASSERT( xResult );
   8546e:	b938      	cbnz	r0, 85480 <prvSampleTimeNow+0x48>
   85470:	f240 316f 	movw	r1, #879	; 0x36f
   85474:	4818      	ldr	r0, [pc, #96]	; (854d8 <prvSampleTimeNow+0xa0>)
   85476:	4b19      	ldr	r3, [pc, #100]	; (854dc <prvSampleTimeNow+0xa4>)
   85478:	4798      	blx	r3
   8547a:	e001      	b.n	85480 <prvSampleTimeNow+0x48>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   8547c:	4d18      	ldr	r5, [pc, #96]	; (854e0 <prvSampleTimeNow+0xa8>)
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   8547e:	4e19      	ldr	r6, [pc, #100]	; (854e4 <prvSampleTimeNow+0xac>)
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   85480:	682b      	ldr	r3, [r5, #0]
   85482:	681a      	ldr	r2, [r3, #0]
   85484:	b1c2      	cbz	r2, 854b8 <prvSampleTimeNow+0x80>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   85486:	68db      	ldr	r3, [r3, #12]
   85488:	f8d3 a000 	ldr.w	sl, [r3]
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   8548c:	68dc      	ldr	r4, [r3, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   8548e:	f104 0904 	add.w	r9, r4, #4
   85492:	4648      	mov	r0, r9
   85494:	47b0      	blx	r6
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   85496:	6a63      	ldr	r3, [r4, #36]	; 0x24
   85498:	4620      	mov	r0, r4
   8549a:	4798      	blx	r3
		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   8549c:	69e3      	ldr	r3, [r4, #28]
   8549e:	2b01      	cmp	r3, #1
   854a0:	d1ee      	bne.n	85480 <prvSampleTimeNow+0x48>
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   854a2:	69a3      	ldr	r3, [r4, #24]
   854a4:	4453      	add	r3, sl
			if( xReloadTime > xNextExpireTime )
   854a6:	459a      	cmp	sl, r3
   854a8:	d2da      	bcs.n	85460 <prvSampleTimeNow+0x28>
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   854aa:	6063      	str	r3, [r4, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   854ac:	6124      	str	r4, [r4, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   854ae:	4649      	mov	r1, r9
   854b0:	6828      	ldr	r0, [r5, #0]
   854b2:	4b0d      	ldr	r3, [pc, #52]	; (854e8 <prvSampleTimeNow+0xb0>)
   854b4:	4798      	blx	r3
   854b6:	e7e3      	b.n	85480 <prvSampleTimeNow+0x48>
	pxCurrentTimerList = pxOverflowTimerList;
   854b8:	4a0c      	ldr	r2, [pc, #48]	; (854ec <prvSampleTimeNow+0xb4>)
   854ba:	6810      	ldr	r0, [r2, #0]
   854bc:	4908      	ldr	r1, [pc, #32]	; (854e0 <prvSampleTimeNow+0xa8>)
   854be:	6008      	str	r0, [r1, #0]
	pxOverflowTimerList = pxTemp;
   854c0:	6013      	str	r3, [r2, #0]
		*pxTimerListsWereSwitched = pdTRUE;
   854c2:	2301      	movs	r3, #1
   854c4:	f8c8 3000 	str.w	r3, [r8]
   854c8:	e7c4      	b.n	85454 <prvSampleTimeNow+0x1c>
   854ca:	bf00      	nop
   854cc:	00084a69 	.word	0x00084a69
   854d0:	20075348 	.word	0x20075348
   854d4:	000853c9 	.word	0x000853c9
   854d8:	00086234 	.word	0x00086234
   854dc:	00085861 	.word	0x00085861
   854e0:	20075318 	.word	0x20075318
   854e4:	000838ed 	.word	0x000838ed
   854e8:	000838b9 	.word	0x000838b9
   854ec:	2007531c 	.word	0x2007531c

000854f0 <prvTimerTask>:
{
   854f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   854f4:	b087      	sub	sp, #28
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   854f6:	4f63      	ldr	r7, [pc, #396]	; (85684 <prvTimerTask+0x194>)
			( void ) xTaskResumeAll();
   854f8:	f8df 81b8 	ldr.w	r8, [pc, #440]	; 856b4 <prvTimerTask+0x1c4>
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   854fc:	4d62      	ldr	r5, [pc, #392]	; (85688 <prvTimerTask+0x198>)
					portYIELD_WITHIN_API();
   854fe:	f8df a1b8 	ldr.w	sl, [pc, #440]	; 856b8 <prvTimerTask+0x1c8>
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   85502:	f8df 91b8 	ldr.w	r9, [pc, #440]	; 856bc <prvTimerTask+0x1cc>
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   85506:	683b      	ldr	r3, [r7, #0]
   85508:	681a      	ldr	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
   8550a:	b172      	cbz	r2, 8552a <prvTimerTask+0x3a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   8550c:	68db      	ldr	r3, [r3, #12]
   8550e:	681e      	ldr	r6, [r3, #0]
	vTaskSuspendAll();
   85510:	4b5e      	ldr	r3, [pc, #376]	; (8568c <prvTimerTask+0x19c>)
   85512:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   85514:	a803      	add	r0, sp, #12
   85516:	4b5e      	ldr	r3, [pc, #376]	; (85690 <prvTimerTask+0x1a0>)
   85518:	4798      	blx	r3
   8551a:	4604      	mov	r4, r0
		if( xTimerListsWereSwitched == pdFALSE )
   8551c:	9b03      	ldr	r3, [sp, #12]
   8551e:	2b00      	cmp	r3, #0
   85520:	d178      	bne.n	85614 <prvTimerTask+0x124>
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   85522:	42b0      	cmp	r0, r6
   85524:	d24c      	bcs.n	855c0 <prvTimerTask+0xd0>
   85526:	2200      	movs	r2, #0
   85528:	e00f      	b.n	8554a <prvTimerTask+0x5a>
	vTaskSuspendAll();
   8552a:	4b58      	ldr	r3, [pc, #352]	; (8568c <prvTimerTask+0x19c>)
   8552c:	4798      	blx	r3
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   8552e:	a803      	add	r0, sp, #12
   85530:	4b57      	ldr	r3, [pc, #348]	; (85690 <prvTimerTask+0x1a0>)
   85532:	4798      	blx	r3
   85534:	4604      	mov	r4, r0
		if( xTimerListsWereSwitched == pdFALSE )
   85536:	9b03      	ldr	r3, [sp, #12]
   85538:	2b00      	cmp	r3, #0
   8553a:	d16b      	bne.n	85614 <prvTimerTask+0x124>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
   8553c:	4b55      	ldr	r3, [pc, #340]	; (85694 <prvTimerTask+0x1a4>)
   8553e:	681b      	ldr	r3, [r3, #0]
   85540:	681a      	ldr	r2, [r3, #0]
   85542:	fab2 f282 	clz	r2, r2
   85546:	0952      	lsrs	r2, r2, #5
   85548:	2600      	movs	r6, #0
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
   8554a:	1b31      	subs	r1, r6, r4
   8554c:	6828      	ldr	r0, [r5, #0]
   8554e:	4b52      	ldr	r3, [pc, #328]	; (85698 <prvTimerTask+0x1a8>)
   85550:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   85552:	47c0      	blx	r8
   85554:	b938      	cbnz	r0, 85566 <prvTimerTask+0x76>
					portYIELD_WITHIN_API();
   85556:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   8555a:	f8ca 3000 	str.w	r3, [sl]
   8555e:	f3bf 8f4f 	dsb	sy
   85562:	f3bf 8f6f 	isb	sy
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   85566:	4c4d      	ldr	r4, [pc, #308]	; (8569c <prvTimerTask+0x1ac>)
   85568:	2200      	movs	r2, #0
   8556a:	a903      	add	r1, sp, #12
   8556c:	6828      	ldr	r0, [r5, #0]
   8556e:	47a0      	blx	r4
   85570:	2800      	cmp	r0, #0
   85572:	d0c8      	beq.n	85506 <prvTimerTask+0x16>
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
   85574:	9b03      	ldr	r3, [sp, #12]
   85576:	2b00      	cmp	r3, #0
   85578:	dbf6      	blt.n	85568 <prvTimerTask+0x78>
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
   8557a:	9e05      	ldr	r6, [sp, #20]
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
   8557c:	6973      	ldr	r3, [r6, #20]
   8557e:	b10b      	cbz	r3, 85584 <prvTimerTask+0x94>
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   85580:	1d30      	adds	r0, r6, #4
   85582:	47c8      	blx	r9
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   85584:	a802      	add	r0, sp, #8
   85586:	4b42      	ldr	r3, [pc, #264]	; (85690 <prvTimerTask+0x1a0>)
   85588:	4798      	blx	r3
   8558a:	4683      	mov	fp, r0
			switch( xMessage.xMessageID )
   8558c:	9b03      	ldr	r3, [sp, #12]
   8558e:	2b09      	cmp	r3, #9
   85590:	d8ea      	bhi.n	85568 <prvTimerTask+0x78>
   85592:	a201      	add	r2, pc, #4	; (adr r2, 85598 <prvTimerTask+0xa8>)
   85594:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   85598:	00085619 	.word	0x00085619
   8559c:	00085619 	.word	0x00085619
   855a0:	00085619 	.word	0x00085619
   855a4:	00085569 	.word	0x00085569
   855a8:	0008565b 	.word	0x0008565b
   855ac:	0008567d 	.word	0x0008567d
   855b0:	00085619 	.word	0x00085619
   855b4:	00085619 	.word	0x00085619
   855b8:	00085569 	.word	0x00085569
   855bc:	0008565b 	.word	0x0008565b
				( void ) xTaskResumeAll();
   855c0:	47c0      	blx	r8
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   855c2:	683b      	ldr	r3, [r7, #0]
   855c4:	68db      	ldr	r3, [r3, #12]
   855c6:	f8d3 b00c 	ldr.w	fp, [r3, #12]
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   855ca:	f10b 0004 	add.w	r0, fp, #4
   855ce:	47c8      	blx	r9
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   855d0:	f8db 301c 	ldr.w	r3, [fp, #28]
   855d4:	2b01      	cmp	r3, #1
   855d6:	d004      	beq.n	855e2 <prvTimerTask+0xf2>
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   855d8:	f8db 3024 	ldr.w	r3, [fp, #36]	; 0x24
   855dc:	4658      	mov	r0, fp
   855de:	4798      	blx	r3
   855e0:	e7c1      	b.n	85566 <prvTimerTask+0x76>
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
   855e2:	f8db 1018 	ldr.w	r1, [fp, #24]
   855e6:	4633      	mov	r3, r6
   855e8:	4622      	mov	r2, r4
   855ea:	4431      	add	r1, r6
   855ec:	4658      	mov	r0, fp
   855ee:	4c2c      	ldr	r4, [pc, #176]	; (856a0 <prvTimerTask+0x1b0>)
   855f0:	47a0      	blx	r4
   855f2:	2800      	cmp	r0, #0
   855f4:	d0f0      	beq.n	855d8 <prvTimerTask+0xe8>
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   855f6:	2100      	movs	r1, #0
   855f8:	9100      	str	r1, [sp, #0]
   855fa:	460b      	mov	r3, r1
   855fc:	4632      	mov	r2, r6
   855fe:	4658      	mov	r0, fp
   85600:	4c28      	ldr	r4, [pc, #160]	; (856a4 <prvTimerTask+0x1b4>)
   85602:	47a0      	blx	r4
			configASSERT( xResult );
   85604:	2800      	cmp	r0, #0
   85606:	d1e7      	bne.n	855d8 <prvTimerTask+0xe8>
   85608:	f240 11e5 	movw	r1, #485	; 0x1e5
   8560c:	4826      	ldr	r0, [pc, #152]	; (856a8 <prvTimerTask+0x1b8>)
   8560e:	4b27      	ldr	r3, [pc, #156]	; (856ac <prvTimerTask+0x1bc>)
   85610:	4798      	blx	r3
   85612:	e7e1      	b.n	855d8 <prvTimerTask+0xe8>
			( void ) xTaskResumeAll();
   85614:	47c0      	blx	r8
   85616:	e7a6      	b.n	85566 <prvTimerTask+0x76>
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
   85618:	9904      	ldr	r1, [sp, #16]
   8561a:	69b0      	ldr	r0, [r6, #24]
   8561c:	460b      	mov	r3, r1
   8561e:	465a      	mov	r2, fp
   85620:	4401      	add	r1, r0
   85622:	4630      	mov	r0, r6
   85624:	4c1e      	ldr	r4, [pc, #120]	; (856a0 <prvTimerTask+0x1b0>)
   85626:	47a0      	blx	r4
   85628:	2800      	cmp	r0, #0
   8562a:	d09c      	beq.n	85566 <prvTimerTask+0x76>
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   8562c:	6a73      	ldr	r3, [r6, #36]	; 0x24
   8562e:	4630      	mov	r0, r6
   85630:	4798      	blx	r3
						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   85632:	69f3      	ldr	r3, [r6, #28]
   85634:	2b01      	cmp	r3, #1
   85636:	d196      	bne.n	85566 <prvTimerTask+0x76>
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   85638:	69b2      	ldr	r2, [r6, #24]
   8563a:	2100      	movs	r1, #0
   8563c:	9100      	str	r1, [sp, #0]
   8563e:	460b      	mov	r3, r1
   85640:	9804      	ldr	r0, [sp, #16]
   85642:	4402      	add	r2, r0
   85644:	4630      	mov	r0, r6
   85646:	4c17      	ldr	r4, [pc, #92]	; (856a4 <prvTimerTask+0x1b4>)
   85648:	47a0      	blx	r4
							configASSERT( xResult );
   8564a:	2800      	cmp	r0, #0
   8564c:	d18b      	bne.n	85566 <prvTimerTask+0x76>
   8564e:	f240 21fe 	movw	r1, #766	; 0x2fe
   85652:	4815      	ldr	r0, [pc, #84]	; (856a8 <prvTimerTask+0x1b8>)
   85654:	4b15      	ldr	r3, [pc, #84]	; (856ac <prvTimerTask+0x1bc>)
   85656:	4798      	blx	r3
   85658:	e785      	b.n	85566 <prvTimerTask+0x76>
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
   8565a:	9b04      	ldr	r3, [sp, #16]
   8565c:	61b3      	str	r3, [r6, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   8565e:	b13b      	cbz	r3, 85670 <prvTimerTask+0x180>
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   85660:	69b1      	ldr	r1, [r6, #24]
   85662:	465b      	mov	r3, fp
   85664:	465a      	mov	r2, fp
   85666:	4459      	add	r1, fp
   85668:	4630      	mov	r0, r6
   8566a:	4c0d      	ldr	r4, [pc, #52]	; (856a0 <prvTimerTask+0x1b0>)
   8566c:	47a0      	blx	r4
   8566e:	e77a      	b.n	85566 <prvTimerTask+0x76>
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   85670:	f240 3115 	movw	r1, #789	; 0x315
   85674:	480c      	ldr	r0, [pc, #48]	; (856a8 <prvTimerTask+0x1b8>)
   85676:	4b0d      	ldr	r3, [pc, #52]	; (856ac <prvTimerTask+0x1bc>)
   85678:	4798      	blx	r3
   8567a:	e7f1      	b.n	85660 <prvTimerTask+0x170>
						vPortFree( pxTimer );
   8567c:	4630      	mov	r0, r6
   8567e:	4b0c      	ldr	r3, [pc, #48]	; (856b0 <prvTimerTask+0x1c0>)
   85680:	4798      	blx	r3
   85682:	e770      	b.n	85566 <prvTimerTask+0x76>
   85684:	20075318 	.word	0x20075318
   85688:	2007534c 	.word	0x2007534c
   8568c:	00084a59 	.word	0x00084a59
   85690:	00085439 	.word	0x00085439
   85694:	2007531c 	.word	0x2007531c
   85698:	0008461d 	.word	0x0008461d
   8569c:	00084289 	.word	0x00084289
   856a0:	000852b1 	.word	0x000852b1
   856a4:	000853c9 	.word	0x000853c9
   856a8:	00086234 	.word	0x00086234
   856ac:	00085861 	.word	0x00085861
   856b0:	00083c8d 	.word	0x00083c8d
   856b4:	00084bc5 	.word	0x00084bc5
   856b8:	e000ed04 	.word	0xe000ed04
   856bc:	000838ed 	.word	0x000838ed

000856c0 <Sm_DISCONNECTED>:
	}
}


void Sm_DISCONNECTED(void)
{
   856c0:	b508      	push	{r3, lr}
	vTaskDelay(100);
   856c2:	2064      	movs	r0, #100	; 0x64
   856c4:	4b01      	ldr	r3, [pc, #4]	; (856cc <Sm_DISCONNECTED+0xc>)
   856c6:	4798      	blx	r3
   856c8:	bd08      	pop	{r3, pc}
   856ca:	bf00      	nop
   856cc:	00084ce1 	.word	0x00084ce1

000856d0 <Sm_TURNING_RIGHT>:
}

void Sm_TURNING_RIGHT(void)
{
   856d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   856d2:	4e07      	ldr	r6, [pc, #28]	; (856f0 <Sm_TURNING_RIGHT+0x20>)
   856d4:	f04f 5700 	mov.w	r7, #536870912	; 0x20000000
   856d8:	6337      	str	r7, [r6, #48]	; 0x30
   856da:	4c06      	ldr	r4, [pc, #24]	; (856f4 <Sm_TURNING_RIGHT+0x24>)
   856dc:	f44f 7580 	mov.w	r5, #256	; 0x100
   856e0:	6325      	str	r5, [r4, #48]	; 0x30
	ioport_set_pin_level(IN12,HIGH);
	ioport_set_pin_level(IN13,HIGH);
	vTaskDelay(100);
   856e2:	2064      	movs	r0, #100	; 0x64
   856e4:	4b04      	ldr	r3, [pc, #16]	; (856f8 <Sm_TURNING_RIGHT+0x28>)
   856e6:	4798      	blx	r3
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   856e8:	6377      	str	r7, [r6, #52]	; 0x34
   856ea:	6365      	str	r5, [r4, #52]	; 0x34
   856ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   856ee:	bf00      	nop
   856f0:	400e1200 	.word	0x400e1200
   856f4:	400e1400 	.word	0x400e1400
   856f8:	00084ce1 	.word	0x00084ce1

000856fc <Sm_TURNING_LEFT>:
	ioport_set_pin_level(IN12,LOW);
	ioport_set_pin_level(IN13,LOW);
}

void Sm_TURNING_LEFT(void)
{
   856fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   856fe:	4e07      	ldr	r6, [pc, #28]	; (8571c <Sm_TURNING_LEFT+0x20>)
   85700:	f44f 1700 	mov.w	r7, #2097152	; 0x200000
   85704:	6337      	str	r7, [r6, #48]	; 0x30
   85706:	4c06      	ldr	r4, [pc, #24]	; (85720 <Sm_TURNING_LEFT+0x24>)
   85708:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   8570c:	6325      	str	r5, [r4, #48]	; 0x30
	ioport_set_pin_level(IN11,HIGH);
	ioport_set_pin_level(IN14,HIGH);
	vTaskDelay(100);
   8570e:	2064      	movs	r0, #100	; 0x64
   85710:	4b04      	ldr	r3, [pc, #16]	; (85724 <Sm_TURNING_LEFT+0x28>)
   85712:	4798      	blx	r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   85714:	6377      	str	r7, [r6, #52]	; 0x34
   85716:	6365      	str	r5, [r4, #52]	; 0x34
   85718:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   8571a:	bf00      	nop
   8571c:	400e1200 	.word	0x400e1200
   85720:	400e1000 	.word	0x400e1000
   85724:	00084ce1 	.word	0x00084ce1

00085728 <Sm_STANDBY>:
	ioport_set_pin_level(IN11,LOW);
	ioport_set_pin_level(IN14,LOW);
}

void Sm_STANDBY(void)
{
   85728:	b508      	push	{r3, lr}
	vTaskDelay(100);
   8572a:	2064      	movs	r0, #100	; 0x64
   8572c:	4b01      	ldr	r3, [pc, #4]	; (85734 <Sm_STANDBY+0xc>)
   8572e:	4798      	blx	r3
   85730:	bd08      	pop	{r3, pc}
   85732:	bf00      	nop
   85734:	00084ce1 	.word	0x00084ce1

00085738 <Sm_MOVING_REVERSE>:
}

void Sm_MOVING_REVERSE(void)
{
   85738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   8573a:	4e07      	ldr	r6, [pc, #28]	; (85758 <Sm_MOVING_REVERSE+0x20>)
   8573c:	f04f 5700 	mov.w	r7, #536870912	; 0x20000000
   85740:	6337      	str	r7, [r6, #48]	; 0x30
   85742:	4c06      	ldr	r4, [pc, #24]	; (8575c <Sm_MOVING_REVERSE+0x24>)
   85744:	f04f 6500 	mov.w	r5, #134217728	; 0x8000000
   85748:	6325      	str	r5, [r4, #48]	; 0x30
	{
		// Frente: ENA1 IN11 ENB1 IN13
		// Tras: ENA1 IN12 ENB1 IN14
		ioport_set_pin_level(IN12,HIGH);
		ioport_set_pin_level(IN14,HIGH);
		vTaskDelay(100);
   8574a:	2064      	movs	r0, #100	; 0x64
   8574c:	4b04      	ldr	r3, [pc, #16]	; (85760 <Sm_MOVING_REVERSE+0x28>)
   8574e:	4798      	blx	r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   85750:	6377      	str	r7, [r6, #52]	; 0x34
   85752:	6365      	str	r5, [r4, #52]	; 0x34
   85754:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   85756:	bf00      	nop
   85758:	400e1200 	.word	0x400e1200
   8575c:	400e1000 	.word	0x400e1000
   85760:	00084ce1 	.word	0x00084ce1

00085764 <Sm_MOVING_FORWARD>:
	//taskEXIT_CRITICAL();
}

\
void Sm_MOVING_FORWARD(void)
{
   85764:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   85766:	4e07      	ldr	r6, [pc, #28]	; (85784 <Sm_MOVING_FORWARD+0x20>)
   85768:	f44f 1700 	mov.w	r7, #2097152	; 0x200000
   8576c:	6337      	str	r7, [r6, #48]	; 0x30
   8576e:	4c06      	ldr	r4, [pc, #24]	; (85788 <Sm_MOVING_FORWARD+0x24>)
   85770:	f44f 7580 	mov.w	r5, #256	; 0x100
   85774:	6325      	str	r5, [r4, #48]	; 0x30
//taskENTER_CRITICAL();
	ioport_set_pin_level(IN11,HIGH);
	ioport_set_pin_level(IN13,HIGH);
	vTaskDelay(100);
   85776:	2064      	movs	r0, #100	; 0x64
   85778:	4b04      	ldr	r3, [pc, #16]	; (8578c <Sm_MOVING_FORWARD+0x28>)
   8577a:	4798      	blx	r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   8577c:	6377      	str	r7, [r6, #52]	; 0x34
   8577e:	6365      	str	r5, [r4, #52]	; 0x34
   85780:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
   85782:	bf00      	nop
   85784:	400e1200 	.word	0x400e1200
   85788:	400e1400 	.word	0x400e1400
   8578c:	00084ce1 	.word	0x00084ce1

00085790 <Rodar_Maquina>:
{
   85790:	b508      	push	{r3, lr}
	if(SmState < NUM_STATES)
   85792:	4b05      	ldr	r3, [pc, #20]	; (857a8 <Rodar_Maquina+0x18>)
   85794:	781b      	ldrb	r3, [r3, #0]
   85796:	2b05      	cmp	r3, #5
   85798:	d900      	bls.n	8579c <Rodar_Maquina+0xc>
   8579a:	bd08      	pop	{r3, pc}
		(*StateMachine[SmState].func)();
   8579c:	4a03      	ldr	r2, [pc, #12]	; (857ac <Rodar_Maquina+0x1c>)
   8579e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
   857a2:	685b      	ldr	r3, [r3, #4]
   857a4:	4798      	blx	r3
   857a6:	e7f8      	b.n	8579a <Rodar_Maquina+0xa>
   857a8:	20075354 	.word	0x20075354
   857ac:	20070290 	.word	0x20070290

000857b0 <vTaskFunction>:

/*-----------------------------------------------------------*/


void vTaskFunction( void * pvParameters )
{
   857b0:	b570      	push	{r4, r5, r6, lr}
	const TickType_t xDelay = 10 / portTICK_PERIOD_MS;

	for( ;; )
	{
		/* Simply toggle the LED every 500ms, blocking between each toggle. */
		Rodar_Maquina();
   857b2:	4e03      	ldr	r6, [pc, #12]	; (857c0 <vTaskFunction+0x10>)
		vTaskDelay( xDelay );
   857b4:	250a      	movs	r5, #10
   857b6:	4c03      	ldr	r4, [pc, #12]	; (857c4 <vTaskFunction+0x14>)
		Rodar_Maquina();
   857b8:	47b0      	blx	r6
		vTaskDelay( xDelay );
   857ba:	4628      	mov	r0, r5
   857bc:	47a0      	blx	r4
   857be:	e7fb      	b.n	857b8 <vTaskFunction+0x8>
   857c0:	00085791 	.word	0x00085791
   857c4:	00084ce1 	.word	0x00084ce1

000857c8 <main>:
{
   857c8:	b500      	push	{lr}
   857ca:	b083      	sub	sp, #12
/*-----------------------------------------------------------*/

static void prvSetupHardware(void)
{
	/* ASF function to setup clocking. */
	sysclk_init();
   857cc:	4b11      	ldr	r3, [pc, #68]	; (85814 <main+0x4c>)
   857ce:	4798      	blx	r3
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
   857d0:	4a11      	ldr	r2, [pc, #68]	; (85818 <main+0x50>)
   857d2:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
   857d4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
   857d8:	041b      	lsls	r3, r3, #16
   857da:	0c1b      	lsrs	r3, r3, #16
  reg_value  =  (reg_value                                   |
   857dc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
   857e0:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
   857e4:	60d3      	str	r3, [r2, #12]

	/* Ensure all priority bits are assigned as preemption priority bits. */
	NVIC_SetPriorityGrouping(0);

	/* Atmel library function to setup for the evaluation kit being used. */
	board_init();
   857e6:	4b0d      	ldr	r3, [pc, #52]	; (8581c <main+0x54>)
   857e8:	4798      	blx	r3

	/* Perform any initialisation required by the partest LED IO functions. */
	vParTestInitialise();
   857ea:	4b0d      	ldr	r3, [pc, #52]	; (85820 <main+0x58>)
   857ec:	4798      	blx	r3
	create_usart_echo_test_tasks(BOARD_USART,
   857ee:	2200      	movs	r2, #0
   857f0:	21a0      	movs	r1, #160	; 0xa0
   857f2:	480c      	ldr	r0, [pc, #48]	; (85824 <main+0x5c>)
   857f4:	4b0c      	ldr	r3, [pc, #48]	; (85828 <main+0x60>)
   857f6:	4798      	blx	r3
	xTaskCreate(vTaskFunction,			/* The task that implements the command console. */
   857f8:	2300      	movs	r3, #0
   857fa:	9301      	str	r3, [sp, #4]
   857fc:	2301      	movs	r3, #1
   857fe:	9300      	str	r3, [sp, #0]
   85800:	f44f 72a0 	mov.w	r2, #320	; 0x140
   85804:	4909      	ldr	r1, [pc, #36]	; (8582c <main+0x64>)
   85806:	480a      	ldr	r0, [pc, #40]	; (85830 <main+0x68>)
   85808:	4c0a      	ldr	r4, [pc, #40]	; (85834 <main+0x6c>)
   8580a:	47a0      	blx	r4
	vTaskStartScheduler();
   8580c:	4b0a      	ldr	r3, [pc, #40]	; (85838 <main+0x70>)
   8580e:	4798      	blx	r3
   85810:	e7fe      	b.n	85810 <main+0x48>
   85812:	bf00      	nop
   85814:	00080161 	.word	0x00080161
   85818:	e000ed00 	.word	0xe000ed00
   8581c:	00081c45 	.word	0x00081c45
   85820:	00085945 	.word	0x00085945
   85824:	40098000 	.word	0x40098000
   85828:	00083775 	.word	0x00083775
   8582c:	00086274 	.word	0x00086274
   85830:	000857b1 	.word	0x000857b1
   85834:	000847cd 	.word	0x000847cd
   85838:	000849c1 	.word	0x000849c1

0008583c <vApplicationMallocFailedHook>:
	__asm volatile
   8583c:	f04f 03a0 	mov.w	r3, #160	; 0xa0
   85840:	f383 8811 	msr	BASEPRI, r3
   85844:	f3bf 8f6f 	isb	sy
   85848:	f3bf 8f4f 	dsb	sy
   8584c:	e7fe      	b.n	8584c <vApplicationMallocFailedHook+0x10>

0008584e <vApplicationStackOverflowHook>:
   8584e:	f04f 03a0 	mov.w	r3, #160	; 0xa0
   85852:	f383 8811 	msr	BASEPRI, r3
   85856:	f3bf 8f6f 	isb	sy
   8585a:	f3bf 8f4f 	dsb	sy
   8585e:	e7fe      	b.n	8585e <vApplicationStackOverflowHook+0x10>

00085860 <assert_triggered>:
}

/*-----------------------------------------------------------*/

void assert_triggered(const char *file, uint32_t line)
{
   85860:	b500      	push	{lr}
   85862:	b083      	sub	sp, #12
	volatile uint32_t block_var = 0, line_in;
   85864:	2300      	movs	r3, #0
   85866:	9301      	str	r3, [sp, #4]
	const char *file_in;

	/* These assignments are made to prevent the compiler optimizing the
	values away. */
	file_in = file;
	line_in = line;
   85868:	9100      	str	r1, [sp, #0]
	(void) file_in;
	(void) line_in;
   8586a:	9b00      	ldr	r3, [sp, #0]

	taskENTER_CRITICAL();
   8586c:	4b04      	ldr	r3, [pc, #16]	; (85880 <assert_triggered+0x20>)
   8586e:	4798      	blx	r3
	{
		while (block_var == 0) {
   85870:	9b01      	ldr	r3, [sp, #4]
   85872:	2b00      	cmp	r3, #0
   85874:	d0fc      	beq.n	85870 <assert_triggered+0x10>
			/* Set block_var to a non-zero value in the debugger to
			step out of this function. */
		}
	}
	taskEXIT_CRITICAL();
   85876:	4b03      	ldr	r3, [pc, #12]	; (85884 <assert_triggered+0x24>)
   85878:	4798      	blx	r3
}
   8587a:	b003      	add	sp, #12
   8587c:	f85d fb04 	ldr.w	pc, [sp], #4
   85880:	000839c5 	.word	0x000839c5
   85884:	00083a0d 	.word	0x00083a0d

00085888 <vParTestSetLED>:

/*-----------------------------------------------------------*/

void vParTestSetLED(unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue)
{
	if (uxLED < partestNUM_LEDS) {
   85888:	2802      	cmp	r0, #2
   8588a:	d852      	bhi.n	85932 <vParTestSetLED+0xaa>
{
   8588c:	b510      	push	{r4, lr}
   8588e:	4604      	mov	r4, r0
		if (xValue != pdFALSE) {
   85890:	b339      	cbz	r1, 858e2 <vParTestSetLED+0x5a>
			/* Turn the LED on. */
			taskENTER_CRITICAL();
   85892:	4b28      	ldr	r3, [pc, #160]	; (85934 <vParTestSetLED+0xac>)
   85894:	4798      	blx	r3
			{
				if (xActiveStates[ uxLED ] == 0) {
   85896:	4b28      	ldr	r3, [pc, #160]	; (85938 <vParTestSetLED+0xb0>)
   85898:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   8589c:	b98b      	cbnz	r3, 858c2 <vParTestSetLED+0x3a>
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
   8589e:	4b27      	ldr	r3, [pc, #156]	; (8593c <vParTestSetLED+0xb4>)
   858a0:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
	return pin >> 5;
   858a4:	0953      	lsrs	r3, r2, #5
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   858a6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   858aa:	f203 7307 	addw	r3, r3, #1799	; 0x707
   858ae:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
   858b0:	f002 021f 	and.w	r2, r2, #31
   858b4:	2101      	movs	r1, #1
   858b6:	fa01 f202 	lsl.w	r2, r1, r2
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   858ba:	635a      	str	r2, [r3, #52]	; 0x34
				} else {
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
				}
			}
			taskEXIT_CRITICAL();
   858bc:	4b20      	ldr	r3, [pc, #128]	; (85940 <vParTestSetLED+0xb8>)
   858be:	4798      	blx	r3
   858c0:	bd10      	pop	{r4, pc}
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
   858c2:	4b1e      	ldr	r3, [pc, #120]	; (8593c <vParTestSetLED+0xb4>)
   858c4:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
	return pin >> 5;
   858c8:	0953      	lsrs	r3, r2, #5
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   858ca:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   858ce:	f203 7307 	addw	r3, r3, #1799	; 0x707
   858d2:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
   858d4:	f002 021f 	and.w	r2, r2, #31
   858d8:	2101      	movs	r1, #1
   858da:	fa01 f202 	lsl.w	r2, r1, r2
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   858de:	631a      	str	r2, [r3, #48]	; 0x30
   858e0:	e7ec      	b.n	858bc <vParTestSetLED+0x34>
		} else {
			/* Turn the LED off. */
			taskENTER_CRITICAL();
   858e2:	4b14      	ldr	r3, [pc, #80]	; (85934 <vParTestSetLED+0xac>)
   858e4:	4798      	blx	r3
			{
				if (xActiveStates[ uxLED ] == 0) {
   858e6:	4b14      	ldr	r3, [pc, #80]	; (85938 <vParTestSetLED+0xb0>)
   858e8:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
   858ec:	b98b      	cbnz	r3, 85912 <vParTestSetLED+0x8a>
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_HIGH);
   858ee:	4b13      	ldr	r3, [pc, #76]	; (8593c <vParTestSetLED+0xb4>)
   858f0:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
	return pin >> 5;
   858f4:	0953      	lsrs	r3, r2, #5
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   858f6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   858fa:	f203 7307 	addw	r3, r3, #1799	; 0x707
   858fe:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
   85900:	f002 021f 	and.w	r2, r2, #31
   85904:	2101      	movs	r1, #1
   85906:	fa01 f202 	lsl.w	r2, r1, r2
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   8590a:	631a      	str	r2, [r3, #48]	; 0x30
				} else {
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
				}
			}
			taskEXIT_CRITICAL();
   8590c:	4b0c      	ldr	r3, [pc, #48]	; (85940 <vParTestSetLED+0xb8>)
   8590e:	4798      	blx	r3
   85910:	bd10      	pop	{r4, pc}
					ioport_set_pin_level(ulLED[ uxLED ], IOPORT_PIN_LEVEL_LOW);
   85912:	4b0a      	ldr	r3, [pc, #40]	; (8593c <vParTestSetLED+0xb4>)
   85914:	f853 2024 	ldr.w	r2, [r3, r4, lsl #2]
	return pin >> 5;
   85918:	0953      	lsrs	r3, r2, #5
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   8591a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   8591e:	f203 7307 	addw	r3, r3, #1799	; 0x707
   85922:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
   85924:	f002 021f 	and.w	r2, r2, #31
   85928:	2101      	movs	r1, #1
   8592a:	fa01 f202 	lsl.w	r2, r1, r2
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   8592e:	635a      	str	r2, [r3, #52]	; 0x34
   85930:	e7ec      	b.n	8590c <vParTestSetLED+0x84>
   85932:	4770      	bx	lr
   85934:	000839c5 	.word	0x000839c5
   85938:	00086288 	.word	0x00086288
   8593c:	0008627c 	.word	0x0008627c
   85940:	00083a0d 	.word	0x00083a0d

00085944 <vParTestInitialise>:
{
   85944:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	for (ul = 0; ul < partestNUM_LEDS; ul++) {
   85948:	2600      	movs	r6, #0
		ioport_set_pin_dir(ulLED[ ul ], IOPORT_DIR_OUTPUT);
   8594a:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 859ec <vParTestInitialise+0xa8>
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   8594e:	4c22      	ldr	r4, [pc, #136]	; (859d8 <vParTestInitialise+0x94>)
   85950:	f44f 1800 	mov.w	r8, #2097152	; 0x200000
   85954:	4d21      	ldr	r5, [pc, #132]	; (859dc <vParTestInitialise+0x98>)
   85956:	4f22      	ldr	r7, [pc, #136]	; (859e0 <vParTestInitialise+0x9c>)
   85958:	f859 1026 	ldr.w	r1, [r9, r6, lsl #2]
	return pin >> 5;
   8595c:	094b      	lsrs	r3, r1, #5
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
   8595e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   85962:	f203 7307 	addw	r3, r3, #1799	; 0x707
   85966:	025b      	lsls	r3, r3, #9
	return 1U << (pin & 0x1F);
   85968:	f001 011f 	and.w	r1, r1, #31
   8596c:	2201      	movs	r2, #1
   8596e:	408a      	lsls	r2, r1
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   85970:	611a      	str	r2, [r3, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
   85972:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   85976:	f8c4 8010 	str.w	r8, [r4, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
   8597a:	f8c4 80a0 	str.w	r8, [r4, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   8597e:	f04f 5e00 	mov.w	lr, #536870912	; 0x20000000
   85982:	f8c4 e010 	str.w	lr, [r4, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
   85986:	f8c4 e0a0 	str.w	lr, [r4, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   8598a:	f44f 7080 	mov.w	r0, #256	; 0x100
   8598e:	6128      	str	r0, [r5, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
   85990:	f8c5 00a0 	str.w	r0, [r5, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   85994:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   85998:	6139      	str	r1, [r7, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
   8599a:	f8c7 10a0 	str.w	r1, [r7, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   8599e:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
   859a2:	6123      	str	r3, [r4, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
   859a4:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
   859a8:	2280      	movs	r2, #128	; 0x80
   859aa:	612a      	str	r2, [r5, #16]
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
   859ac:	f8c5 20a0 	str.w	r2, [r5, #160]	; 0xa0
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
   859b0:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
   859b4:	f8c4 e034 	str.w	lr, [r4, #52]	; 0x34
   859b8:	6368      	str	r0, [r5, #52]	; 0x34
   859ba:	6379      	str	r1, [r7, #52]	; 0x34
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
   859bc:	632a      	str	r2, [r5, #48]	; 0x30
   859be:	6323      	str	r3, [r4, #48]	; 0x30
		vParTestSetLED(ul, xActiveStates[ ul ]);
   859c0:	4b08      	ldr	r3, [pc, #32]	; (859e4 <vParTestInitialise+0xa0>)
   859c2:	f853 1026 	ldr.w	r1, [r3, r6, lsl #2]
   859c6:	4630      	mov	r0, r6
   859c8:	4b07      	ldr	r3, [pc, #28]	; (859e8 <vParTestInitialise+0xa4>)
   859ca:	4798      	blx	r3
	for (ul = 0; ul < partestNUM_LEDS; ul++) {
   859cc:	3601      	adds	r6, #1
   859ce:	2e03      	cmp	r6, #3
   859d0:	d1c2      	bne.n	85958 <vParTestInitialise+0x14>
}
   859d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   859d6:	bf00      	nop
   859d8:	400e1200 	.word	0x400e1200
   859dc:	400e1400 	.word	0x400e1400
   859e0:	400e1000 	.word	0x400e1000
   859e4:	00086288 	.word	0x00086288
   859e8:	00085889 	.word	0x00085889
   859ec:	0008627c 	.word	0x0008627c

000859f0 <configure_timer_for_run_time_stats>:
/*-----------------------------------------------------------*/

void configure_timer_for_run_time_stats(void)
{
	/* How many clocks are there per tenth of a millisecond? */
	clocks_per_10th_ms = configCPU_CLOCK_HZ / 10000UL;
   859f0:	f242 02d0 	movw	r2, #8400	; 0x20d0
   859f4:	4b01      	ldr	r3, [pc, #4]	; (859fc <configure_timer_for_run_time_stats+0xc>)
   859f6:	601a      	str	r2, [r3, #0]
   859f8:	4770      	bx	lr
   859fa:	bf00      	nop
   859fc:	20075358 	.word	0x20075358

00085a00 <get_run_time_counter_value>:
}

/*-----------------------------------------------------------*/

uint32_t get_run_time_counter_value(void)
{
   85a00:	b510      	push	{r4, lr}
	used anyway to keep the examples simple, and to avoid reliance on a
	separate timer peripheral. */

	/* The SysTick is a down counter.  How many clocks have passed since it
	was last reloaded? */
	sys_tick_counts = sys_tick_reload_value - *current_sys_tick_count;
   85a02:	4b13      	ldr	r3, [pc, #76]	; (85a50 <get_run_time_counter_value+0x50>)
   85a04:	681c      	ldr	r4, [r3, #0]

	/* How many times has it overflowed? */
	tick_count = xTaskGetTickCountFromISR();
   85a06:	4b13      	ldr	r3, [pc, #76]	; (85a54 <get_run_time_counter_value+0x54>)
   85a08:	4798      	blx	r3
	__asm volatile
   85a0a:	f3ef 8311 	mrs	r3, BASEPRI
   85a0e:	f04f 02a0 	mov.w	r2, #160	; 0xa0
   85a12:	f382 8811 	msr	BASEPRI, r2
   85a16:	f3bf 8f6f 	isb	sy
   85a1a:	f3bf 8f4f 	dsb	sy
	so reset the critical section. */
	ulReturn = portSET_INTERRUPT_MASK_FROM_ISR();
	(void) ulReturn;

	/* Is there a SysTick interrupt pending? */
	if ((*interrupt_ctrl_statee & sys_tick_pending_bit) != 0UL) {
   85a1e:	4b0e      	ldr	r3, [pc, #56]	; (85a58 <get_run_time_counter_value+0x58>)
   85a20:	681b      	ldr	r3, [r3, #0]
   85a22:	f013 6f80 	tst.w	r3, #67108864	; 0x4000000
   85a26:	d00e      	beq.n	85a46 <get_run_time_counter_value+0x46>
		/* There is a SysTick interrupt pending, so the SysTick has overflowed
		but the tick count not yet incremented. */
		tick_count++;
   85a28:	3001      	adds	r0, #1

		/* Read the SysTick again, as the overflow might have occurred since
		it was read last. */
		sys_tick_counts = sys_tick_reload_value -
				*current_sys_tick_count;
   85a2a:	4b09      	ldr	r3, [pc, #36]	; (85a50 <get_run_time_counter_value+0x50>)
   85a2c:	681b      	ldr	r3, [r3, #0]
		sys_tick_counts = sys_tick_reload_value -
   85a2e:	f5c3 33a4 	rsb	r3, r3, #83968	; 0x14800
   85a32:	331f      	adds	r3, #31
	}

	/* Convert the tick count into tenths of a millisecond.  THIS ASSUMES
	configTICK_RATE_HZ is 1000! */
	ulReturn = (tick_count * 10UL);
   85a34:	eb00 0080 	add.w	r0, r0, r0, lsl #2

	/* Add on the number of tenths of a millisecond that have passed since
	the tick count last got updated. */
	ulReturn += (sys_tick_counts / clocks_per_10th_ms);
   85a38:	4a08      	ldr	r2, [pc, #32]	; (85a5c <get_run_time_counter_value+0x5c>)
   85a3a:	6812      	ldr	r2, [r2, #0]
   85a3c:	fbb3 f3f2 	udiv	r3, r3, r2

	return ulReturn;
}
   85a40:	eb03 0040 	add.w	r0, r3, r0, lsl #1
   85a44:	bd10      	pop	{r4, pc}
	sys_tick_counts = sys_tick_reload_value - *current_sys_tick_count;
   85a46:	f5c4 33a4 	rsb	r3, r4, #83968	; 0x14800
   85a4a:	331f      	adds	r3, #31
   85a4c:	e7f2      	b.n	85a34 <get_run_time_counter_value+0x34>
   85a4e:	bf00      	nop
   85a50:	e000e018 	.word	0xe000e018
   85a54:	00084a75 	.word	0x00084a75
   85a58:	e000ed04 	.word	0xe000ed04
   85a5c:	20075358 	.word	0x20075358

00085a60 <__libc_init_array>:
   85a60:	b570      	push	{r4, r5, r6, lr}
   85a62:	4e0f      	ldr	r6, [pc, #60]	; (85aa0 <__libc_init_array+0x40>)
   85a64:	4d0f      	ldr	r5, [pc, #60]	; (85aa4 <__libc_init_array+0x44>)
   85a66:	1b76      	subs	r6, r6, r5
   85a68:	10b6      	asrs	r6, r6, #2
   85a6a:	bf18      	it	ne
   85a6c:	2400      	movne	r4, #0
   85a6e:	d005      	beq.n	85a7c <__libc_init_array+0x1c>
   85a70:	3401      	adds	r4, #1
   85a72:	f855 3b04 	ldr.w	r3, [r5], #4
   85a76:	4798      	blx	r3
   85a78:	42a6      	cmp	r6, r4
   85a7a:	d1f9      	bne.n	85a70 <__libc_init_array+0x10>
   85a7c:	4e0a      	ldr	r6, [pc, #40]	; (85aa8 <__libc_init_array+0x48>)
   85a7e:	4d0b      	ldr	r5, [pc, #44]	; (85aac <__libc_init_array+0x4c>)
   85a80:	f000 fc0a 	bl	86298 <_init>
   85a84:	1b76      	subs	r6, r6, r5
   85a86:	10b6      	asrs	r6, r6, #2
   85a88:	bf18      	it	ne
   85a8a:	2400      	movne	r4, #0
   85a8c:	d006      	beq.n	85a9c <__libc_init_array+0x3c>
   85a8e:	3401      	adds	r4, #1
   85a90:	f855 3b04 	ldr.w	r3, [r5], #4
   85a94:	4798      	blx	r3
   85a96:	42a6      	cmp	r6, r4
   85a98:	d1f9      	bne.n	85a8e <__libc_init_array+0x2e>
   85a9a:	bd70      	pop	{r4, r5, r6, pc}
   85a9c:	bd70      	pop	{r4, r5, r6, pc}
   85a9e:	bf00      	nop
   85aa0:	000862a4 	.word	0x000862a4
   85aa4:	000862a4 	.word	0x000862a4
   85aa8:	000862ac 	.word	0x000862ac
   85aac:	000862a4 	.word	0x000862a4

00085ab0 <memcpy>:
   85ab0:	4684      	mov	ip, r0
   85ab2:	ea41 0300 	orr.w	r3, r1, r0
   85ab6:	f013 0303 	ands.w	r3, r3, #3
   85aba:	d149      	bne.n	85b50 <memcpy+0xa0>
   85abc:	3a40      	subs	r2, #64	; 0x40
   85abe:	d323      	bcc.n	85b08 <memcpy+0x58>
   85ac0:	680b      	ldr	r3, [r1, #0]
   85ac2:	6003      	str	r3, [r0, #0]
   85ac4:	684b      	ldr	r3, [r1, #4]
   85ac6:	6043      	str	r3, [r0, #4]
   85ac8:	688b      	ldr	r3, [r1, #8]
   85aca:	6083      	str	r3, [r0, #8]
   85acc:	68cb      	ldr	r3, [r1, #12]
   85ace:	60c3      	str	r3, [r0, #12]
   85ad0:	690b      	ldr	r3, [r1, #16]
   85ad2:	6103      	str	r3, [r0, #16]
   85ad4:	694b      	ldr	r3, [r1, #20]
   85ad6:	6143      	str	r3, [r0, #20]
   85ad8:	698b      	ldr	r3, [r1, #24]
   85ada:	6183      	str	r3, [r0, #24]
   85adc:	69cb      	ldr	r3, [r1, #28]
   85ade:	61c3      	str	r3, [r0, #28]
   85ae0:	6a0b      	ldr	r3, [r1, #32]
   85ae2:	6203      	str	r3, [r0, #32]
   85ae4:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   85ae6:	6243      	str	r3, [r0, #36]	; 0x24
   85ae8:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   85aea:	6283      	str	r3, [r0, #40]	; 0x28
   85aec:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   85aee:	62c3      	str	r3, [r0, #44]	; 0x2c
   85af0:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   85af2:	6303      	str	r3, [r0, #48]	; 0x30
   85af4:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   85af6:	6343      	str	r3, [r0, #52]	; 0x34
   85af8:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   85afa:	6383      	str	r3, [r0, #56]	; 0x38
   85afc:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   85afe:	63c3      	str	r3, [r0, #60]	; 0x3c
   85b00:	3040      	adds	r0, #64	; 0x40
   85b02:	3140      	adds	r1, #64	; 0x40
   85b04:	3a40      	subs	r2, #64	; 0x40
   85b06:	d2db      	bcs.n	85ac0 <memcpy+0x10>
   85b08:	3230      	adds	r2, #48	; 0x30
   85b0a:	d30b      	bcc.n	85b24 <memcpy+0x74>
   85b0c:	680b      	ldr	r3, [r1, #0]
   85b0e:	6003      	str	r3, [r0, #0]
   85b10:	684b      	ldr	r3, [r1, #4]
   85b12:	6043      	str	r3, [r0, #4]
   85b14:	688b      	ldr	r3, [r1, #8]
   85b16:	6083      	str	r3, [r0, #8]
   85b18:	68cb      	ldr	r3, [r1, #12]
   85b1a:	60c3      	str	r3, [r0, #12]
   85b1c:	3010      	adds	r0, #16
   85b1e:	3110      	adds	r1, #16
   85b20:	3a10      	subs	r2, #16
   85b22:	d2f3      	bcs.n	85b0c <memcpy+0x5c>
   85b24:	320c      	adds	r2, #12
   85b26:	d305      	bcc.n	85b34 <memcpy+0x84>
   85b28:	f851 3b04 	ldr.w	r3, [r1], #4
   85b2c:	f840 3b04 	str.w	r3, [r0], #4
   85b30:	3a04      	subs	r2, #4
   85b32:	d2f9      	bcs.n	85b28 <memcpy+0x78>
   85b34:	3204      	adds	r2, #4
   85b36:	d008      	beq.n	85b4a <memcpy+0x9a>
   85b38:	07d2      	lsls	r2, r2, #31
   85b3a:	bf1c      	itt	ne
   85b3c:	f811 3b01 	ldrbne.w	r3, [r1], #1
   85b40:	f800 3b01 	strbne.w	r3, [r0], #1
   85b44:	d301      	bcc.n	85b4a <memcpy+0x9a>
   85b46:	880b      	ldrh	r3, [r1, #0]
   85b48:	8003      	strh	r3, [r0, #0]
   85b4a:	4660      	mov	r0, ip
   85b4c:	4770      	bx	lr
   85b4e:	bf00      	nop
   85b50:	2a08      	cmp	r2, #8
   85b52:	d313      	bcc.n	85b7c <memcpy+0xcc>
   85b54:	078b      	lsls	r3, r1, #30
   85b56:	d0b1      	beq.n	85abc <memcpy+0xc>
   85b58:	f010 0303 	ands.w	r3, r0, #3
   85b5c:	d0ae      	beq.n	85abc <memcpy+0xc>
   85b5e:	f1c3 0304 	rsb	r3, r3, #4
   85b62:	1ad2      	subs	r2, r2, r3
   85b64:	07db      	lsls	r3, r3, #31
   85b66:	bf1c      	itt	ne
   85b68:	f811 3b01 	ldrbne.w	r3, [r1], #1
   85b6c:	f800 3b01 	strbne.w	r3, [r0], #1
   85b70:	d3a4      	bcc.n	85abc <memcpy+0xc>
   85b72:	f831 3b02 	ldrh.w	r3, [r1], #2
   85b76:	f820 3b02 	strh.w	r3, [r0], #2
   85b7a:	e79f      	b.n	85abc <memcpy+0xc>
   85b7c:	3a04      	subs	r2, #4
   85b7e:	d3d9      	bcc.n	85b34 <memcpy+0x84>
   85b80:	3a01      	subs	r2, #1
   85b82:	f811 3b01 	ldrb.w	r3, [r1], #1
   85b86:	f800 3b01 	strb.w	r3, [r0], #1
   85b8a:	d2f9      	bcs.n	85b80 <memcpy+0xd0>
   85b8c:	780b      	ldrb	r3, [r1, #0]
   85b8e:	7003      	strb	r3, [r0, #0]
   85b90:	784b      	ldrb	r3, [r1, #1]
   85b92:	7043      	strb	r3, [r0, #1]
   85b94:	788b      	ldrb	r3, [r1, #2]
   85b96:	7083      	strb	r3, [r0, #2]
   85b98:	4660      	mov	r0, ip
   85b9a:	4770      	bx	lr

00085b9c <memset>:
   85b9c:	b470      	push	{r4, r5, r6}
   85b9e:	0786      	lsls	r6, r0, #30
   85ba0:	d046      	beq.n	85c30 <memset+0x94>
   85ba2:	1e54      	subs	r4, r2, #1
   85ba4:	2a00      	cmp	r2, #0
   85ba6:	d041      	beq.n	85c2c <memset+0x90>
   85ba8:	b2ca      	uxtb	r2, r1
   85baa:	4603      	mov	r3, r0
   85bac:	e002      	b.n	85bb4 <memset+0x18>
   85bae:	f114 34ff 	adds.w	r4, r4, #4294967295
   85bb2:	d33b      	bcc.n	85c2c <memset+0x90>
   85bb4:	f803 2b01 	strb.w	r2, [r3], #1
   85bb8:	079d      	lsls	r5, r3, #30
   85bba:	d1f8      	bne.n	85bae <memset+0x12>
   85bbc:	2c03      	cmp	r4, #3
   85bbe:	d92e      	bls.n	85c1e <memset+0x82>
   85bc0:	b2cd      	uxtb	r5, r1
   85bc2:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   85bc6:	2c0f      	cmp	r4, #15
   85bc8:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   85bcc:	d919      	bls.n	85c02 <memset+0x66>
   85bce:	4626      	mov	r6, r4
   85bd0:	f103 0210 	add.w	r2, r3, #16
   85bd4:	3e10      	subs	r6, #16
   85bd6:	2e0f      	cmp	r6, #15
   85bd8:	f842 5c10 	str.w	r5, [r2, #-16]
   85bdc:	f842 5c0c 	str.w	r5, [r2, #-12]
   85be0:	f842 5c08 	str.w	r5, [r2, #-8]
   85be4:	f842 5c04 	str.w	r5, [r2, #-4]
   85be8:	f102 0210 	add.w	r2, r2, #16
   85bec:	d8f2      	bhi.n	85bd4 <memset+0x38>
   85bee:	f1a4 0210 	sub.w	r2, r4, #16
   85bf2:	f022 020f 	bic.w	r2, r2, #15
   85bf6:	f004 040f 	and.w	r4, r4, #15
   85bfa:	3210      	adds	r2, #16
   85bfc:	2c03      	cmp	r4, #3
   85bfe:	4413      	add	r3, r2
   85c00:	d90d      	bls.n	85c1e <memset+0x82>
   85c02:	461e      	mov	r6, r3
   85c04:	4622      	mov	r2, r4
   85c06:	3a04      	subs	r2, #4
   85c08:	2a03      	cmp	r2, #3
   85c0a:	f846 5b04 	str.w	r5, [r6], #4
   85c0e:	d8fa      	bhi.n	85c06 <memset+0x6a>
   85c10:	1f22      	subs	r2, r4, #4
   85c12:	f022 0203 	bic.w	r2, r2, #3
   85c16:	3204      	adds	r2, #4
   85c18:	4413      	add	r3, r2
   85c1a:	f004 0403 	and.w	r4, r4, #3
   85c1e:	b12c      	cbz	r4, 85c2c <memset+0x90>
   85c20:	b2c9      	uxtb	r1, r1
   85c22:	441c      	add	r4, r3
   85c24:	f803 1b01 	strb.w	r1, [r3], #1
   85c28:	429c      	cmp	r4, r3
   85c2a:	d1fb      	bne.n	85c24 <memset+0x88>
   85c2c:	bc70      	pop	{r4, r5, r6}
   85c2e:	4770      	bx	lr
   85c30:	4614      	mov	r4, r2
   85c32:	4603      	mov	r3, r0
   85c34:	e7c2      	b.n	85bbc <memset+0x20>
   85c36:	bf00      	nop

00085c38 <strcpy>:
   85c38:	ea80 0201 	eor.w	r2, r0, r1
   85c3c:	4684      	mov	ip, r0
   85c3e:	f012 0f03 	tst.w	r2, #3
   85c42:	d14f      	bne.n	85ce4 <strcpy+0xac>
   85c44:	f011 0f03 	tst.w	r1, #3
   85c48:	d132      	bne.n	85cb0 <strcpy+0x78>
   85c4a:	f84d 4d04 	str.w	r4, [sp, #-4]!
   85c4e:	f011 0f04 	tst.w	r1, #4
   85c52:	f851 3b04 	ldr.w	r3, [r1], #4
   85c56:	d00b      	beq.n	85c70 <strcpy+0x38>
   85c58:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   85c5c:	439a      	bics	r2, r3
   85c5e:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   85c62:	bf04      	itt	eq
   85c64:	f84c 3b04 	streq.w	r3, [ip], #4
   85c68:	f851 3b04 	ldreq.w	r3, [r1], #4
   85c6c:	d116      	bne.n	85c9c <strcpy+0x64>
   85c6e:	bf00      	nop
   85c70:	f851 4b04 	ldr.w	r4, [r1], #4
   85c74:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
   85c78:	439a      	bics	r2, r3
   85c7a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   85c7e:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
   85c82:	d10b      	bne.n	85c9c <strcpy+0x64>
   85c84:	f84c 3b04 	str.w	r3, [ip], #4
   85c88:	43a2      	bics	r2, r4
   85c8a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
   85c8e:	bf04      	itt	eq
   85c90:	f851 3b04 	ldreq.w	r3, [r1], #4
   85c94:	f84c 4b04 	streq.w	r4, [ip], #4
   85c98:	d0ea      	beq.n	85c70 <strcpy+0x38>
   85c9a:	4623      	mov	r3, r4
   85c9c:	f80c 3b01 	strb.w	r3, [ip], #1
   85ca0:	f013 0fff 	tst.w	r3, #255	; 0xff
   85ca4:	ea4f 2333 	mov.w	r3, r3, ror #8
   85ca8:	d1f8      	bne.n	85c9c <strcpy+0x64>
   85caa:	f85d 4b04 	ldr.w	r4, [sp], #4
   85cae:	4770      	bx	lr
   85cb0:	f011 0f01 	tst.w	r1, #1
   85cb4:	d006      	beq.n	85cc4 <strcpy+0x8c>
   85cb6:	f811 2b01 	ldrb.w	r2, [r1], #1
   85cba:	f80c 2b01 	strb.w	r2, [ip], #1
   85cbe:	2a00      	cmp	r2, #0
   85cc0:	bf08      	it	eq
   85cc2:	4770      	bxeq	lr
   85cc4:	f011 0f02 	tst.w	r1, #2
   85cc8:	d0bf      	beq.n	85c4a <strcpy+0x12>
   85cca:	f831 2b02 	ldrh.w	r2, [r1], #2
   85cce:	f012 0fff 	tst.w	r2, #255	; 0xff
   85cd2:	bf16      	itet	ne
   85cd4:	f82c 2b02 	strhne.w	r2, [ip], #2
   85cd8:	f88c 2000 	strbeq.w	r2, [ip]
   85cdc:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
   85ce0:	d1b3      	bne.n	85c4a <strcpy+0x12>
   85ce2:	4770      	bx	lr
   85ce4:	f811 2b01 	ldrb.w	r2, [r1], #1
   85ce8:	f80c 2b01 	strb.w	r2, [ip], #1
   85cec:	2a00      	cmp	r2, #0
   85cee:	d1f9      	bne.n	85ce4 <strcpy+0xac>
   85cf0:	4770      	bx	lr
   85cf2:	bf00      	nop

00085cf4 <strlen>:
   85cf4:	f020 0103 	bic.w	r1, r0, #3
   85cf8:	f010 0003 	ands.w	r0, r0, #3
   85cfc:	f1c0 0000 	rsb	r0, r0, #0
   85d00:	f851 3b04 	ldr.w	r3, [r1], #4
   85d04:	f100 0c04 	add.w	ip, r0, #4
   85d08:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
   85d0c:	f06f 0200 	mvn.w	r2, #0
   85d10:	bf1c      	itt	ne
   85d12:	fa22 f20c 	lsrne.w	r2, r2, ip
   85d16:	4313      	orrne	r3, r2
   85d18:	f04f 0c01 	mov.w	ip, #1
   85d1c:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
   85d20:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
   85d24:	eba3 020c 	sub.w	r2, r3, ip
   85d28:	ea22 0203 	bic.w	r2, r2, r3
   85d2c:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
   85d30:	bf04      	itt	eq
   85d32:	f851 3b04 	ldreq.w	r3, [r1], #4
   85d36:	3004      	addeq	r0, #4
   85d38:	d0f4      	beq.n	85d24 <strlen+0x30>
   85d3a:	f1c2 0100 	rsb	r1, r2, #0
   85d3e:	ea02 0201 	and.w	r2, r2, r1
   85d42:	fab2 f282 	clz	r2, r2
   85d46:	f1c2 021f 	rsb	r2, r2, #31
   85d4a:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
   85d4e:	4770      	bx	lr

00085d50 <register_fini>:
   85d50:	4b02      	ldr	r3, [pc, #8]	; (85d5c <register_fini+0xc>)
   85d52:	b113      	cbz	r3, 85d5a <register_fini+0xa>
   85d54:	4802      	ldr	r0, [pc, #8]	; (85d60 <register_fini+0x10>)
   85d56:	f000 b805 	b.w	85d64 <atexit>
   85d5a:	4770      	bx	lr
   85d5c:	00000000 	.word	0x00000000
   85d60:	00085d71 	.word	0x00085d71

00085d64 <atexit>:
   85d64:	2300      	movs	r3, #0
   85d66:	4601      	mov	r1, r0
   85d68:	461a      	mov	r2, r3
   85d6a:	4618      	mov	r0, r3
   85d6c:	f000 b81e 	b.w	85dac <__register_exitproc>

00085d70 <__libc_fini_array>:
   85d70:	b538      	push	{r3, r4, r5, lr}
   85d72:	4c0a      	ldr	r4, [pc, #40]	; (85d9c <__libc_fini_array+0x2c>)
   85d74:	4d0a      	ldr	r5, [pc, #40]	; (85da0 <__libc_fini_array+0x30>)
   85d76:	1b64      	subs	r4, r4, r5
   85d78:	10a4      	asrs	r4, r4, #2
   85d7a:	d00a      	beq.n	85d92 <__libc_fini_array+0x22>
   85d7c:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
   85d80:	3b01      	subs	r3, #1
   85d82:	eb05 0583 	add.w	r5, r5, r3, lsl #2
   85d86:	3c01      	subs	r4, #1
   85d88:	f855 3904 	ldr.w	r3, [r5], #-4
   85d8c:	4798      	blx	r3
   85d8e:	2c00      	cmp	r4, #0
   85d90:	d1f9      	bne.n	85d86 <__libc_fini_array+0x16>
   85d92:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   85d96:	f000 ba89 	b.w	862ac <_fini>
   85d9a:	bf00      	nop
   85d9c:	000862bc 	.word	0x000862bc
   85da0:	000862b8 	.word	0x000862b8

00085da4 <__retarget_lock_acquire_recursive>:
   85da4:	4770      	bx	lr
   85da6:	bf00      	nop

00085da8 <__retarget_lock_release_recursive>:
   85da8:	4770      	bx	lr
   85daa:	bf00      	nop

00085dac <__register_exitproc>:
   85dac:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
   85db0:	4d2c      	ldr	r5, [pc, #176]	; (85e64 <__register_exitproc+0xb8>)
   85db2:	4606      	mov	r6, r0
   85db4:	6828      	ldr	r0, [r5, #0]
   85db6:	4698      	mov	r8, r3
   85db8:	460f      	mov	r7, r1
   85dba:	4691      	mov	r9, r2
   85dbc:	f7ff fff2 	bl	85da4 <__retarget_lock_acquire_recursive>
   85dc0:	4b29      	ldr	r3, [pc, #164]	; (85e68 <__register_exitproc+0xbc>)
   85dc2:	681c      	ldr	r4, [r3, #0]
   85dc4:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
   85dc8:	2b00      	cmp	r3, #0
   85dca:	d03e      	beq.n	85e4a <__register_exitproc+0x9e>
   85dcc:	685a      	ldr	r2, [r3, #4]
   85dce:	2a1f      	cmp	r2, #31
   85dd0:	dc1c      	bgt.n	85e0c <__register_exitproc+0x60>
   85dd2:	f102 0e01 	add.w	lr, r2, #1
   85dd6:	b176      	cbz	r6, 85df6 <__register_exitproc+0x4a>
   85dd8:	2101      	movs	r1, #1
   85dda:	eb03 0482 	add.w	r4, r3, r2, lsl #2
   85dde:	f8c4 9088 	str.w	r9, [r4, #136]	; 0x88
   85de2:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
   85de6:	4091      	lsls	r1, r2
   85de8:	4308      	orrs	r0, r1
   85dea:	2e02      	cmp	r6, #2
   85dec:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
   85df0:	f8c4 8108 	str.w	r8, [r4, #264]	; 0x108
   85df4:	d023      	beq.n	85e3e <__register_exitproc+0x92>
   85df6:	3202      	adds	r2, #2
   85df8:	f8c3 e004 	str.w	lr, [r3, #4]
   85dfc:	6828      	ldr	r0, [r5, #0]
   85dfe:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
   85e02:	f7ff ffd1 	bl	85da8 <__retarget_lock_release_recursive>
   85e06:	2000      	movs	r0, #0
   85e08:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   85e0c:	4b17      	ldr	r3, [pc, #92]	; (85e6c <__register_exitproc+0xc0>)
   85e0e:	b30b      	cbz	r3, 85e54 <__register_exitproc+0xa8>
   85e10:	f44f 70c8 	mov.w	r0, #400	; 0x190
   85e14:	f3af 8000 	nop.w
   85e18:	4603      	mov	r3, r0
   85e1a:	b1d8      	cbz	r0, 85e54 <__register_exitproc+0xa8>
   85e1c:	2000      	movs	r0, #0
   85e1e:	f8d4 1148 	ldr.w	r1, [r4, #328]	; 0x148
   85e22:	f04f 0e01 	mov.w	lr, #1
   85e26:	6058      	str	r0, [r3, #4]
   85e28:	6019      	str	r1, [r3, #0]
   85e2a:	4602      	mov	r2, r0
   85e2c:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   85e30:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
   85e34:	f8c3 018c 	str.w	r0, [r3, #396]	; 0x18c
   85e38:	2e00      	cmp	r6, #0
   85e3a:	d0dc      	beq.n	85df6 <__register_exitproc+0x4a>
   85e3c:	e7cc      	b.n	85dd8 <__register_exitproc+0x2c>
   85e3e:	f8d3 018c 	ldr.w	r0, [r3, #396]	; 0x18c
   85e42:	4301      	orrs	r1, r0
   85e44:	f8c3 118c 	str.w	r1, [r3, #396]	; 0x18c
   85e48:	e7d5      	b.n	85df6 <__register_exitproc+0x4a>
   85e4a:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
   85e4e:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
   85e52:	e7bb      	b.n	85dcc <__register_exitproc+0x20>
   85e54:	6828      	ldr	r0, [r5, #0]
   85e56:	f7ff ffa7 	bl	85da8 <__retarget_lock_release_recursive>
   85e5a:	f04f 30ff 	mov.w	r0, #4294967295
   85e5e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
   85e62:	bf00      	nop
   85e64:	200706e8 	.word	0x200706e8
   85e68:	00086294 	.word	0x00086294
   85e6c:	00000000 	.word	0x00000000
   85e70:	732f2e2e 	.word	0x732f2e2e
   85e74:	412f6372 	.word	0x412f6372
   85e78:	632f4653 	.word	0x632f4653
   85e7c:	6f6d6d6f 	.word	0x6f6d6d6f
   85e80:	65732f6e 	.word	0x65732f6e
   85e84:	63697672 	.word	0x63697672
   85e88:	662f7365 	.word	0x662f7365
   85e8c:	72656572 	.word	0x72656572
   85e90:	2f736f74 	.word	0x2f736f74
   85e94:	2f6d6173 	.word	0x2f6d6173
   85e98:	65657266 	.word	0x65657266
   85e9c:	736f7472 	.word	0x736f7472
   85ea0:	7265705f 	.word	0x7265705f
   85ea4:	65687069 	.word	0x65687069
   85ea8:	5f6c6172 	.word	0x5f6c6172
   85eac:	746e6f63 	.word	0x746e6f63
   85eb0:	2e6c6f72 	.word	0x2e6c6f72
   85eb4:	00000063 	.word	0x00000063

00085eb8 <all_twi_definitions>:
   85eb8:	4008c000 4008c100 00000016 00000016     ...@...@........
   85ec8:	40090000 40090100 00000017 00000017     ...@...@........

00085ed8 <all_uart_definitions>:
   85ed8:	400e0800 400e0900 00000008 00000008     ...@...@........
   85ee8:	732f2e2e 412f6372 632f4653 6f6d6d6f     ../src/ASF/commo
   85ef8:	65732f6e 63697672 662f7365 72656572     n/services/freer
   85f08:	2f736f74 2f6d6173 65657266 736f7472     tos/sam/freertos
   85f18:	7261755f 65735f74 6c616972 0000632e     _uart_serial.c..

00085f28 <all_usart_definitions>:
   85f28:	40098000 40098100 00000011 00000011     ...@...@........
   85f38:	4009c000 4009c100 00000012 00000012     ...@...@........
   85f48:	400a0000 400a0100 00000013 00000013     ...@...@........
   85f58:	400a4000 400a4100 00000014 00000014     .@.@.A.@........
   85f68:	732f2e2e 412f6372 632f4653 6f6d6d6f     ../src/ASF/commo
   85f78:	65732f6e 63697672 662f7365 72656572     n/services/freer
   85f88:	2f736f74 2f6d6173 65657266 736f7472     tos/sam/freertos
   85f98:	6173755f 735f7472 61697265 00632e6c     _usart_serial.c.
	...
   85fb0:	aaaaaa00 aaaaaaaa eeeeeeaa eeeeeeee     ................
   85fc0:	fffffeee ffffffff ffffffff dfbf7fff     ................
   85fd0:	fdfbf7ef dfbf7efc fdfbf7ef 0000007e     .....~......~...
   85fe0:	2007115c 0000004f 0000000a 00000300     \.. O...........
   85ff0:	00002580 000000c0 00000800 00000000     .%..............
	...
   86008:	00007854 00007852 23534944 00000000     Tx..Rx..DIS#....
   86018:	23594253 00000000 23445746 00000000     SBY#....FWD#....
   86028:	2354464c 00000000 23544752 00000000     LFT#....RGT#....
   86038:	234b4142 00000000 732f2e2e 412f6372     BAK#....../src/A
   86048:	742f4653 64726968 74726170 72662f79     SF/thirdparty/fr
   86058:	74726565 642f736f 2f6f6d65 69726570     eertos/demo/peri
   86068:	72656870 635f6c61 72746e6f 642f6c6f     pheral_control/d
   86078:	2d6f6d65 6b736174 53552f73 2d545241     emo-tasks/USART-
   86088:	6f686365 7361742d 632e736b 00000000     echo-tasks.c....
   86098:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
   860a8:	74726170 72662f79 74726565 642f736f     party/freertos/d
   860b8:	2f6f6d65 69726570 72656870 635f6c61     emo/peripheral_c
   860c8:	72746e6f 642f6c6f 2d6f6d65 6b736174     ontrol/demo-task
   860d8:	53552f73 44432d42 4c432d43 61742d49     s/USB-CDC-CLI-ta
   860e8:	632e6b73 00000000 5f434443 00494c43     sk.c....CDC_CLI.
   860f8:	732f2e2e 412f6372 742f4653 64726968     ../src/ASF/third
   86108:	74726170 72662f79 74726565 662f736f     party/freertos/f
   86118:	72656572 2d736f74 302e3031 532f302e     reertos-10.0.0/S
   86128:	6372756f 6f702f65 62617472 472f656c     ource/portable/G
   86138:	412f4343 435f4d52 702f334d 2e74726f     CC/ARM_CM3/port.
   86148:	00000063 732f2e2e 412f6372 742f4653     c...../src/ASF/t
   86158:	64726968 74726170 72662f79 74726565     hirdparty/freert
   86168:	662f736f 72656572 2d736f74 302e3031     os/freertos-10.0
   86178:	532f302e 6372756f 6f702f65 62617472     .0/Source/portab
   86188:	4d2f656c 614d6d65 682f676e 5f706165     le/MemMang/heap_
   86198:	00632e31 732f2e2e 412f6372 742f4653     1.c.../src/ASF/t
   861a8:	64726968 74726170 72662f79 74726565     hirdparty/freert
   861b8:	662f736f 72656572 2d736f74 302e3031     os/freertos-10.0
   861c8:	532f302e 6372756f 75712f65 2e657565     .0/Source/queue.
   861d8:	00000063 732f2e2e 412f6372 742f4653     c...../src/ASF/t
   861e8:	64726968 74726170 72662f79 74726565     hirdparty/freert
   861f8:	662f736f 72656572 2d736f74 302e3031     os/freertos-10.0
   86208:	532f302e 6372756f 61742f65 2e736b73     .0/Source/tasks.
   86218:	00000063 454c4449 00000000 51726d54     c...IDLE....TmrQ
   86228:	00000000 20726d54 00637653 732f2e2e     ....Tmr Svc.../s
   86238:	412f6372 742f4653 64726968 74726170     rc/ASF/thirdpart
   86248:	72662f79 74726565 662f736f 72656572     y/freertos/freer
   86258:	2d736f74 302e3031 532f302e 6372756f     tos-10.0.0/Sourc
   86268:	69742f65 7372656d 0000632e 6b637566     e/timers.c..fuck
   86278:	00000000                                ....

0008627c <ulLED>:
   8627c:	0000003b 00000055 00000056              ;...U...V...

00086288 <xActiveStates>:
	...

00086294 <_global_impure_ptr>:
   86294:	200702c0                                ... 

00086298 <_init>:
   86298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8629a:	bf00      	nop
   8629c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   8629e:	bc08      	pop	{r3}
   862a0:	469e      	mov	lr, r3
   862a2:	4770      	bx	lr

000862a4 <__init_array_start>:
   862a4:	00085d51 	.word	0x00085d51

000862a8 <__frame_dummy_init_array_entry>:
   862a8:	00080119                                ....

000862ac <_fini>:
   862ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   862ae:	bf00      	nop
   862b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
   862b2:	bc08      	pop	{r3}
   862b4:	469e      	mov	lr, r3
   862b6:	4770      	bx	lr

000862b8 <__fini_array_start>:
   862b8:	000800f5 	.word	0x000800f5

Disassembly of section .relocate:

20070000 <SystemInit>:
	EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
20070000:	f44f 6380 	mov.w	r3, #1024	; 0x400
20070004:	4a20      	ldr	r2, [pc, #128]	; (20070088 <SystemInit+0x88>)
20070006:	6013      	str	r3, [r2, #0]
	EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
20070008:	f502 7200 	add.w	r2, r2, #512	; 0x200
2007000c:	6013      	str	r3, [r2, #0]
	if (!(PMC->CKGR_MOR & CKGR_MOR_MOSCSEL)) {
2007000e:	4b1f      	ldr	r3, [pc, #124]	; (2007008c <SystemInit+0x8c>)
20070010:	6a1b      	ldr	r3, [r3, #32]
20070012:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
20070016:	d107      	bne.n	20070028 <SystemInit+0x28>
		PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT | 
20070018:	4a1d      	ldr	r2, [pc, #116]	; (20070090 <SystemInit+0x90>)
2007001a:	4b1c      	ldr	r3, [pc, #112]	; (2007008c <SystemInit+0x8c>)
2007001c:	621a      	str	r2, [r3, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS)) {
2007001e:	461a      	mov	r2, r3
20070020:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070022:	f013 0f01 	tst.w	r3, #1
20070026:	d0fb      	beq.n	20070020 <SystemInit+0x20>
	PMC->CKGR_MOR = SYS_CKGR_MOR_KEY_VALUE | SYS_BOARD_OSCOUNT | 
20070028:	4a1a      	ldr	r2, [pc, #104]	; (20070094 <SystemInit+0x94>)
2007002a:	4b18      	ldr	r3, [pc, #96]	; (2007008c <SystemInit+0x8c>)
2007002c:	621a      	str	r2, [r3, #32]
	while (!(PMC->PMC_SR & PMC_SR_MOSCSELS)) {
2007002e:	461a      	mov	r2, r3
20070030:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070032:	f413 3f80 	tst.w	r3, #65536	; 0x10000
20070036:	d0fb      	beq.n	20070030 <SystemInit+0x30>
 	PMC->PMC_MCKR = (PMC->PMC_MCKR & ~(uint32_t)PMC_MCKR_CSS_Msk) | 
20070038:	4a14      	ldr	r2, [pc, #80]	; (2007008c <SystemInit+0x8c>)
2007003a:	6b13      	ldr	r3, [r2, #48]	; 0x30
2007003c:	f023 0303 	bic.w	r3, r3, #3
20070040:	f043 0301 	orr.w	r3, r3, #1
20070044:	6313      	str	r3, [r2, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070046:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070048:	f013 0f08 	tst.w	r3, #8
2007004c:	d0fb      	beq.n	20070046 <SystemInit+0x46>
	PMC->CKGR_PLLAR = SYS_BOARD_PLLAR;
2007004e:	4a12      	ldr	r2, [pc, #72]	; (20070098 <SystemInit+0x98>)
20070050:	4b0e      	ldr	r3, [pc, #56]	; (2007008c <SystemInit+0x8c>)
20070052:	629a      	str	r2, [r3, #40]	; 0x28
	while (!(PMC->PMC_SR & PMC_SR_LOCKA)) {
20070054:	461a      	mov	r2, r3
20070056:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070058:	f013 0f02 	tst.w	r3, #2
2007005c:	d0fb      	beq.n	20070056 <SystemInit+0x56>
	PMC->PMC_MCKR = (SYS_BOARD_MCKR & ~PMC_MCKR_CSS_Msk) | PMC_MCKR_CSS_MAIN_CLK;
2007005e:	2211      	movs	r2, #17
20070060:	4b0a      	ldr	r3, [pc, #40]	; (2007008c <SystemInit+0x8c>)
20070062:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070064:	461a      	mov	r2, r3
20070066:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070068:	f013 0f08 	tst.w	r3, #8
2007006c:	d0fb      	beq.n	20070066 <SystemInit+0x66>
	PMC->PMC_MCKR = SYS_BOARD_MCKR;
2007006e:	2212      	movs	r2, #18
20070070:	4b06      	ldr	r3, [pc, #24]	; (2007008c <SystemInit+0x8c>)
20070072:	631a      	str	r2, [r3, #48]	; 0x30
	while (!(PMC->PMC_SR & PMC_SR_MCKRDY)) {
20070074:	461a      	mov	r2, r3
20070076:	6e93      	ldr	r3, [r2, #104]	; 0x68
20070078:	f013 0f08 	tst.w	r3, #8
2007007c:	d0fb      	beq.n	20070076 <SystemInit+0x76>
	SystemCoreClock = CHIP_FREQ_CPU_MAX;
2007007e:	4a07      	ldr	r2, [pc, #28]	; (2007009c <SystemInit+0x9c>)
20070080:	4b07      	ldr	r3, [pc, #28]	; (200700a0 <SystemInit+0xa0>)
20070082:	601a      	str	r2, [r3, #0]
20070084:	4770      	bx	lr
20070086:	bf00      	nop
20070088:	400e0a00 	.word	0x400e0a00
2007008c:	400e0600 	.word	0x400e0600
20070090:	00370809 	.word	0x00370809
20070094:	01370809 	.word	0x01370809
20070098:	200d3f01 	.word	0x200d3f01
2007009c:	0501bd00 	.word	0x0501bd00
200700a0:	20070270 	.word	0x20070270

200700a4 <system_init_flash>:
__no_inline
RAMFUNC
void system_init_flash(uint32_t ul_clk)
{
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
200700a4:	4b1b      	ldr	r3, [pc, #108]	; (20070114 <system_init_flash+0x70>)
200700a6:	4298      	cmp	r0, r3
200700a8:	d915      	bls.n	200700d6 <system_init_flash+0x32>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0);
		EFC1->EEFC_FMR = EEFC_FMR_FWS(0);
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
200700aa:	4b1b      	ldr	r3, [pc, #108]	; (20070118 <system_init_flash+0x74>)
200700ac:	4298      	cmp	r0, r3
200700ae:	d919      	bls.n	200700e4 <system_init_flash+0x40>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
		EFC1->EEFC_FMR = EEFC_FMR_FWS(1);
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
200700b0:	4b1a      	ldr	r3, [pc, #104]	; (2007011c <system_init_flash+0x78>)
200700b2:	4298      	cmp	r0, r3
200700b4:	d91e      	bls.n	200700f4 <system_init_flash+0x50>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(2);
		EFC1->EEFC_FMR = EEFC_FMR_FWS(2);
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
200700b6:	4b1a      	ldr	r3, [pc, #104]	; (20070120 <system_init_flash+0x7c>)
200700b8:	4298      	cmp	r0, r3
200700ba:	d923      	bls.n	20070104 <system_init_flash+0x60>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(3);
		EFC1->EEFC_FMR = EEFC_FMR_FWS(3);
	} else if (ul_clk < CHIP_FREQ_FWS_4) {
200700bc:	4b19      	ldr	r3, [pc, #100]	; (20070124 <system_init_flash+0x80>)
200700be:	4298      	cmp	r0, r3
		EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
200700c0:	bf94      	ite	ls
200700c2:	f44f 6380 	movls.w	r3, #1024	; 0x400
		EFC1->EEFC_FMR = EEFC_FMR_FWS(4);	
	} else {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(5);
200700c6:	f44f 63a0 	movhi.w	r3, #1280	; 0x500
200700ca:	4a17      	ldr	r2, [pc, #92]	; (20070128 <system_init_flash+0x84>)
200700cc:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(5);
200700ce:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700d2:	6013      	str	r3, [r2, #0]
200700d4:	4770      	bx	lr
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0);
200700d6:	2300      	movs	r3, #0
200700d8:	4a13      	ldr	r2, [pc, #76]	; (20070128 <system_init_flash+0x84>)
200700da:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(0);
200700dc:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700e0:	6013      	str	r3, [r2, #0]
200700e2:	4770      	bx	lr
		EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
200700e4:	f44f 7380 	mov.w	r3, #256	; 0x100
200700e8:	4a0f      	ldr	r2, [pc, #60]	; (20070128 <system_init_flash+0x84>)
200700ea:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(1);
200700ec:	f502 7200 	add.w	r2, r2, #512	; 0x200
200700f0:	6013      	str	r3, [r2, #0]
200700f2:	4770      	bx	lr
		EFC0->EEFC_FMR = EEFC_FMR_FWS(2);
200700f4:	f44f 7300 	mov.w	r3, #512	; 0x200
200700f8:	4a0b      	ldr	r2, [pc, #44]	; (20070128 <system_init_flash+0x84>)
200700fa:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(2);
200700fc:	f502 7200 	add.w	r2, r2, #512	; 0x200
20070100:	6013      	str	r3, [r2, #0]
20070102:	4770      	bx	lr
		EFC0->EEFC_FMR = EEFC_FMR_FWS(3);
20070104:	f44f 7340 	mov.w	r3, #768	; 0x300
20070108:	4a07      	ldr	r2, [pc, #28]	; (20070128 <system_init_flash+0x84>)
2007010a:	6013      	str	r3, [r2, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(3);
2007010c:	f502 7200 	add.w	r2, r2, #512	; 0x200
20070110:	6013      	str	r3, [r2, #0]
20070112:	4770      	bx	lr
20070114:	0121eabf 	.word	0x0121eabf
20070118:	02faf07f 	.word	0x02faf07f
2007011c:	03d08fff 	.word	0x03d08fff
20070120:	04c4b3ff 	.word	0x04c4b3ff
20070124:	055d4a7f 	.word	0x055d4a7f
20070128:	400e0a00 	.word	0x400e0a00

2007012c <udi_api_cdc_comm>:
2007012c:	0008103d 00080f9d 00080fb5 00080fb1     =...............
2007013c:	00000000                                ....

20070140 <udi_api_cdc_data>:
20070140:	00081381 00081229 00080fad 00080fb1     ....)...........
20070150:	00081219                                ....

20070154 <udc_config>:
20070154:	20070204 2007016c 20070204 20070218     ... l.. ... ... 
20070164:	20070174 00000000                       t.. ....

2007016c <udc_config_fs>:
2007016c:	2007017c 20070224                       |.. $.. 

20070174 <udc_config_hs>:
20070174:	200701c0 20070224                       ... $.. 

2007017c <udc_desc_fs>:
2007017c:	00430209 c0000102 00040932 02020100     ..C.....2.......
2007018c:	24050001 04011000 05020224 01000624     ...$....$...$...
2007019c:	03012405 83050701 10004003 00010409     .$.......@......
200701ac:	00000a02 81050700 00004002 02020507     .........@......
200701bc:	00000040                                @...

200701c0 <udc_desc_hs>:
200701c0:	00430209 c0000102 00040932 02020100     ..C.....2.......
200701d0:	24050001 04011000 05020224 01000624     ...$....$...$...
200701e0:	03012405 83050701 10004003 00010409     .$.......@......
200701f0:	00000a02 81050700 00020002 02020507     ................
20070200:	00000200                                ....

20070204 <udc_device_desc>:
20070204:	02000112 40000002 240403eb 02010100     .......@...$....
20070214:	00000100                                ....

20070218 <udc_device_qual>:
20070218:	0200060a 40000002 00000001              .......@....

20070224 <udi_apis>:
20070224:	2007012c 20070140                       ,.. @.. 

2007022c <udc_string_desc>:
2007022c:	00000300 00000000 00000000 00000000     ................
	...

20070250 <udc_string_desc_languageid>:
20070250:	04090304                                ....

20070254 <udc_string_manufacturer_name>:
20070254:	656d7441 0000006c                       Atmel...

2007025c <udc_string_product_name>:
2007025c:	6c6c6942 6f422079 75422062 6e6f7474     Billy Bob Button
2007026c:	00010073                                         s.

2007026e <g_interrupt_enabled>:
2007026e:	09000001                                         ..

20070270 <SystemCoreClock>:
20070270:	003d0900                                ..=.

20070274 <estado_atual>:
20070274:	00086010 00086018 00086020 00086028     .`...`.. `..(`..
20070284:	00086030 00086038                       0`..8`..

2007028c <uxCriticalNesting>:
2007028c:	aaaaaaaa                                ....

20070290 <StateMachine>:
20070290:	00000000 000856c1 00000001 00085729     .....V......)W..
200702a0:	00000002 00085765 00000003 000856fd     ....eW.......V..
200702b0:	00000004 000856d1 00000005 00085739     .....V......9W..

200702c0 <impure_data>:
200702c0:	00000000 200705ac 20070614 2007067c     ....... ... |.. 
	...
20070368:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
20070378:	0005deec 0000000b 00000000 00000000     ................
	...

200706e8 <__atexit_recursive_mutex>:
200706e8:	200753bc                                .S. 
